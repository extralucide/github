#!/usr/bin/env python 2.7.3# -*- coding: utf-8 -*-__author__ = 'Olivier.Appere'from openpyxl import load_workbookfrom copy import deepcopyimport refrom check_llr import CheckLLRfrom datetime import datetimetry:    from Tkinter import *    ##    import Tkinter              # Python 2    import ttkexcept ImportError:    from tkinter import *from tool import Toolfrom synergy import Synergyfrom math import floorimport timefrom os.path import joinfrom openpyxl import load_workbook,Workbookfrom openpyxl.worksheet import range_boundariesfrom openpyxl.compat import rangefrom openpyxl.cell import get_column_letterfrom openpyxl.drawing import Imagefrom openpyxl.styles import Style,Font,PatternFill,Border,Side,Alignmentfrom openpyxl.styles.colors import RED,YELLOW,WHITE,GREENfrom openpyxl.styles.borders import BORDER_THIN,BORDER_MEDIUMfrom openpyxl.worksheet.datavalidation import DataValidation, ValidationTypefrom openpyxl.formatting import ColorScaleRule, CellIsRule, FormulaRuleclass CheckIS(CheckLLR,Synergy):    #nb_expected_srs_rules = 33    nb_expected_srs_req_rules = 22    # TODO: Make configurable    expected_srs_rules = ["SRS_01","SRS_06","SRS_07","SRS_09","SRS_10","SRS_11","SRS_12","SRS_13","SRS_14","SRS_15",                          "SRS_23","SRS_16","SRS_18","SRS_19","SRS_20","SRS_21","SRS_22","SRS_24","SRS_25","SRS_52",                          "SRS_59","SRS_60","SRS_28","SRS_29","SRS_30","SRS_31","SRS_32","SRS_33","SRS_34","SRS_35",                          "SRS_36","SRS_08","SRS_17"]    expected_srs_req_rules_dico = {"SRS_REQ_37":"Both",                                   "SRS_REQ_38":"Both",                                   "SRS_REQ_38":"Both",                                   "SRS_REQ_40":"Existent",                                   "SRS_REQ_41":"Both",                                   "SRS_REQ_42":"Both",                                   "SRS_REQ_43":"Both",                                   "SRS_REQ_44":"Both",                                   "SRS_REQ_45":"Both",                                   "SRS_REQ_46":"Both",                                   "SRS_REQ_47":"Both",                                   "SRS_REQ_48":"Both",                                   "SRS_REQ_49":"Both",                                   "SRS_REQ_50":"Deleted",                                   "SRS_REQ_51":"Existent",                                   "SRS_REQ_53":"Existent",                                   "SRS_REQ_54":"Existent",                                   "SRS_REQ_56":"Existent",                                   "SRS_REQ_57":"Existent",                                   "SRS_REQ_61":"Existent",                                   "SRS_REQ_62":"Existent",                                   "SRS_REQ_63":"Existent"}    def set_border_is(self,ws, cell_range,bg=WHITE,align=True):        font = Font(name='Arial',size=10,bold=False)        if align:            alignment=Alignment(horizontal='center',vertical='center',wrap_text=False,shrink_to_fit=True)        else:            alignment=Alignment(wrap_text=False,shrink_to_fit=True)        if bg != WHITE:            style_border = Style(border=Border(left=Side(border_style=BORDER_MEDIUM),                                               right=Side(border_style=BORDER_MEDIUM),                                                    top=Side(border_style=BORDER_MEDIUM),                                                    bottom=Side(border_style=BORDER_MEDIUM)),                                      alignment=alignment,                                      fill=PatternFill(patternType='solid',start_color=bg),                                      font=font)        else:            style_border = Style(border=Border(left=Side(border_style=BORDER_MEDIUM),                                               right=Side(border_style=BORDER_MEDIUM),                                                    top=Side(border_style=BORDER_MEDIUM),                                                    bottom=Side(border_style=BORDER_MEDIUM)),                                      alignment=alignment,                                      font=font)        #row = ws.iter_rows(cell_range)        min_col, min_row, max_col, max_row = range_boundaries(cell_range.upper())        #print "TEST:",min_col, min_row, max_col, max_row        for index_row, rows in enumerate(ws.iter_rows(cell_range)):        #for row in rows:            index_column = 0            for row in rows:                row.style = style_border                index_column +=1    def getIssue(self,                 req,                 dico_upper):        """        Check upper requirement in IS is included in upper specification        :param req: upper requirement from UPPER REQ ANALYSIS worksheet of IS workbook        :param dico_upper: dictionary of requirement like ex:                            SSCS_ACLog_790 {'status': u'MATURE',                                            'terminal': 'EMPTY',                                            'additional': 'EMPTY',                                            'conformity': u'YES',                                            'derived': 'EMPTY',                                            'allocation': u'HW',                                            'body': u'The ACLog shall meet the Power Input requirements defined in section 16 of RTCA/DO-160G Category A(NF) with the exceptions described in Power Quality document RAE-BA700-103 rev C.',                                            'safety': 'EMPTY',                                            'verification': 'EMPTY',                                            'rationale': 'EMPTY',                                            'issue': u'3',                                            'refer': u'[SES-ACEPC-292]'}        :return:        """        #for document,tbl_reqs_in_upper_doc in dico_upper.iteritems():        if req in dico_upper:            value = dico_upper[req]            # Get issue of upper requirement from IS UPPER_REQ_ANALYSIS worksheet            result = CheckLLR.getAtribute(value,"issue")            if result not in (None,'None','EMPTY'):                try:                    issue = int(result)                except ValueError,e:                    print "getIssue",e                    issue = "Unknown"            else:                issue = "Unknown"        else:            issue = "Unknown"        return issue    @staticmethod    def validationReqAnalysis(prompt_txt="Please select from the list OK, NOK or NOT VERIFIED"):        # Create a data-validation object with list validation        dv = DataValidation(type="list", formula1='"OK,NOK,NOT VERIFIED"', allow_blank=True)        # Optionally set a custom error message        dv.error ='Your entry is not in the list'        dv.errorTitle = 'Invalid Entry'        # Optionally set a custom prompt message        dv.prompt = prompt_txt        dv.promptTitle = 'List Selection'        return dv    @staticmethod    def validationReqReview(prompt_txt="Please select from the list OK, NOK, PARTIALLY VERIFIED (NOK) and PARTIALLY VERIFIED (OK)"):        # Create a data-validation object with list validation        dv = DataValidation(type="list", formula1='"OK,NOK,PARTIALLY VERIFIED (NOK),PARTIALLY VERIFIED (OK)"', allow_blank=True)        # Optionally set a custom error message        dv.error ='Your entry is not in the list'        dv.errorTitle = 'Invalid Entry'        # Optionally set a custom prompt message        dv.prompt = prompt_txt        dv.promptTitle = 'List Selection'        return dv    def exportIS(self,                 filename_is="",                 project="",                 reference="",                 issue="",                 release="",                 author="",                 title="Software Requirement Data",                 default_status = "OK",                 reviewer_name = "Nobody",                 dico_upper={},                 tbl_cr=[]):        """        Create Inspection Sheet from specification document        :param filename_is:        :param reference:        :param issue:        :param release:        :param dico_upper:        :return:        """        # Init        dv_review = self.validationReqAnalysis("OK: if objective is completely covered, NOK: if objective i not at all or partially covered, NOT VERIFIED: if objective is not verified on current version")        dv_doc_review = self.validationReqAnalysis("SVP 4.2.4.7: NOK if the verified item does not comply or complies partially with the SRTS rule, NOT VERIFIED if the high-level requirement is not verified, OK if one of the verified item complies with the SRTS rule")        req_analysis_prompt = "NOK if SwRD requirement does not comply with at least one or more linked upper requirement or derived requirement justification is not correct. " \                              "NOT VERIFIED if SwRD requirement compliance is not verified, " \                              "OK if SwRD requirement complies with all linked upper requirements or derived requirement justification is correct."        req_analysis_prompt = "OK if SwRD requirement complies with all linked upper requirements or derived requirement justification is correct."        dv_req_analysis = self.validationReqAnalysis(req_analysis_prompt)        dv_upper_req_analysis = self.validationReqAnalysis("NOK if upper requirement is not fully developed into SwRD requirements, NOT VERIFIED if upper requirement refinement is not verified, OK if upper requirement is fully developed into SwRD requirements.")        req_review_prompt = "SVP 4.2.4.8: NOK if the verified requirement does not comply with at least one rule, " \                            "PARTIALLY VERIFIED (NOK) if one of the rules is not verified on the last requirement issue and at least one verified rule is NOK, " \                            "PARTIALLY VERIFIED (OK) if one of the rule is not verified on the last requirement issue and all verified rules are OK, " \                            "OK otherwise."        req_review_prompt = "SVP 4.2.4.8: OK if the verified requirement does comply with all rules"        dv_req_review = self.validationReqReview(req_review_prompt)        redFill = PatternFill(start_color=RED,end_color=RED,fill_type='solid')        greenFill = PatternFill(start_color=GREEN,end_color=GREEN,fill_type='solid')        orangeFill = PatternFill(start_color=YELLOW,end_color=YELLOW,fill_type='solid')        # Workbook loading        wb = load_workbook(filename = join('template',self.is_export_tpl_name))        # CONTEXT        ws = wb.get_sheet_by_name(name = 'CONTEXT')        self.putLogo(ws,image="very_small_logo_zodiac.jpeg")        style_border = Style(border=Border(            left=Side(border_style=BORDER_MEDIUM),            right=Side(border_style=BORDER_MEDIUM),            top=Side(border_style=BORDER_MEDIUM),            bottom=Side(border_style=BORDER_MEDIUM)))        for position in ('C5','C10','C16','C21'):            c = ws[position]            c.style = style_border        ws.cell('C6').value = project        ws.cell('C7').value = release        ws.cell('C8').value = reviewer_name        ws.cell('C9').value = datetime.now()        # Document inspected        ws.cell('C11').value = title        ws.cell('C12').value = reference        ws.cell('C13').value = issue        ws.cell('C14').value = author        row = 22        cr_line = 1        for cr in tbl_cr:            if cr_line > 1:                ws.cell('B%s'%(row)).value = "CR {:s}".format(cr[0].zfill(4))                ws.cell('C%s'%(row)).value = cr[1]                row += 1            cr_line += 1        self.set_border_is(ws, "C22:C38",align=False)        # REVIEW        ws = wb.get_sheet_by_name(name = 'REVIEW')        for row_id in range (2,13):            current_cell = ws.cell('C%s'%(row_id))            current_cell.value = default_status            ws.cell('D%s'%(row_id)).value = reviewer_name            ws.cell('E%s'%(row_id)).value = issue        ws.add_data_validation(dv_review)        row = 13        dv_review.ranges.append('C1:C%s'%(row - 1))        cell_square = 'C3:C%s'%(row - 1)        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"OK"'],                                                 stopIfTrue=True,                                                 fill=greenFill))        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"NOK"'],                                                 stopIfTrue=True,                                                 fill=redFill))        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"NOT VERIFIED"'],                                                 stopIfTrue=True,                                                 fill=orangeFill))        # DOC REVIEW        # NOK if the verified item does not comply or complies partially to the SRTS rule        # NOT VERIFIED if the high-level requirement is not verified,        # OK if one the verified item complies to the SRTS rule        ws = wb.get_sheet_by_name(name = 'DOC REVIEW')        for row_id in range (2,35):            current_cell = ws.cell('C%s'%(row_id))            current_cell.value = default_status            ws.cell('D%s'%(row_id)).value = reviewer_name            ws.cell('E%s'%(row_id)).value = issue        ws.add_data_validation(dv_doc_review)        row = 35        dv_doc_review.ranges.append('C1:C%s'%(row - 1))        cell_square = 'C3:C%s'%(row - 1)        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"OK"'],                                                 stopIfTrue=True,                                                 fill=greenFill))        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"NOK"'],                                                 stopIfTrue=True,                                                 fill=redFill))        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"NOT VERIFIED"'],                                                 stopIfTrue=True,                                                 fill=orangeFill))        # REQ REVIEW        ws = wb.get_sheet_by_name(name = 'REQ REVIEW')        row = 3        self.set_border_is(ws, "F2:BS2")        # sort requirements        #print "List requirements",self.tbl_file_llr_wo_del        tbl_list_req=[]        for name,list_req in self.tbl_file_llr_wo_del.iteritems():            for req in list_req:                tbl_list_req.append(req)        tbl_list_req.sort()        for req in tbl_list_req:            value = self.tbl_list_llr[req]            # Discard deleted requirements            current_cell = ws.cell('A%s'%(row))            current_cell.value = '%s' % (req)            issue = CheckLLR.getAtribute(value,"issue")            current_cell = ws.cell('B%s'%(row))            current_cell.value = '%s' % (issue)            current_cell = ws.cell('C%s'%(row))            current_cell.value = default_status            current_cell = ws.cell('D%s'%(row))            current_cell.value = ""            current_cell = ws.cell('E%s'%(row))            current_cell.value = reviewer_name            for col_idx in range(6,72,3):                col = get_column_letter(col_idx)                current_cell = ws.cell('%s%s'%(col, row))                current_cell.value = reviewer_name                col = get_column_letter(col_idx + 1)                current_cell = ws.cell('%s%s'%(col, row))                current_cell.value = issue            self.set_border_is(ws, "A{:d}:BS{:d}".format(row,row))            row += 1        cell_square = 'C3:C%s'%(row - 1)        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"OK"'],                                                 stopIfTrue=True,                                                 fill=greenFill))        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"NOK"'],                                                 stopIfTrue=True,                                                 fill=redFill))        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"NOT VERIFIED"'],                                                 stopIfTrue=True,                                                 fill=orangeFill))        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"PARTIIALLY VERIFIED (OK)"'],                                                 stopIfTrue=True,                                                 fill=orangeFill,                                                 font=Font(color=GREEN)))        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"PARTIIALLY VERIFIED (NOK)"'],                                                 stopIfTrue=True,                                                 fill=orangeFill,                                                 font=Font(color=RED)))        ws.add_data_validation(dv_req_review)        dv_req_review.ranges.append('C1:C%s'%(row - 1))        ws = wb.get_sheet_by_name(name = 'REQ ANALYSIS')        self.set_border_is(ws, "A1:A2",bg="BBBBBBBB")        self.set_border_is(ws, "B1:B2",bg="BBBBBBBB")        self.set_border_is(ws, "E1:E2",bg="BBBBBBBB")        self.set_border_is(ws, "F1:F2",bg="BBBBBBBB")        row = 3        for req in tbl_list_req:            value = self.tbl_list_llr[req]            # Discard deleted requirements            current_cell = ws.cell('A%s'%(row))            current_cell.value = '%s' % (req)            issue = CheckLLR.getAtribute(value,"issue")            current_cell = ws.cell('B%s'%(row))            current_cell.value = '%s' % (issue)            current_cell = ws.cell('E%s'%(row))            current_cell.value = '%s' % (issue)            current_cell = ws.cell('C%s'%(row))            current_cell.value = default_status            current_cell = ws.cell('D%s'%(row))            current_cell.value = reviewer_name            self.set_border_is(ws, "A{:d}:F{:d}".format(row,row))            row += 1        cell_square = 'C3:C%s'%(row - 1)        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"OK"'],                                                 stopIfTrue=True,                                                 fill=greenFill))        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"NOK"'],                                                 stopIfTrue=True,                                                 fill=redFill))        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"NOT VERIFIED"'],                                                 stopIfTrue=True,                                                 fill=orangeFill))        ws.add_data_validation(dv_req_analysis)        dv_req_analysis.ranges.append('C1:C%s'%(row - 1))        ws = wb.get_sheet_by_name(name = 'UPPER REQ ANALYSIS')        self.set_border_is(ws, "A1:A2",bg="BBBBBBBB")        self.set_border_is(ws, "B1:B2",bg="BBBBBBBB")        self.set_border_is(ws, "D1:D2",bg="BBBBBBBB")        self.set_border_is(ws, "F1:F2",bg="BBBBBBBB")        row = 3        # Create a data-validation object with list validation        #dv = DataValidation(type="list", formula1='"OK,NOK,NOT VERIFIED"', allow_blank=True)        # Optionally set a custom error message        #dv.error ='Your entry is not in the list'        #dv.errorTitle = 'Invalid Entry'        # Optionally set a custom prompt message        #dv.prompt = 'Please select from the list OK, NOK or NOT VERIFIED'        #dv.promptTitle = 'List Selection'        # Add the data-validation object to the worksheet        ws.add_data_validation(dv_upper_req_analysis)        for req in self.list_upper_req:            current_cell = ws.cell('A%s'%(row))            current_cell.value = '%s' % (req)            self.set_border_is(ws, "A{:d}:F{:d}".format(row,row))            current_cell = ws.cell('B%s'%(row))            if req in dico_upper:                value = dico_upper[req]                issue_str = CheckLLR.getAtribute(value,"issue")                if issue_str not in (None,"None"):                    try:                        issue = int(issue_str)                    except ValueError:                        issue = "Unknown"                else:                    issue = "Unknown"            else:                issue = "Unknown"            current_cell.value = issue            current_cell = ws.cell('C%s'%(row))            current_cell.value = default_status            current_cell = ws.cell('E%s'%(row))            current_cell.value = issue            current_cell = ws.cell('D%s'%(row))            current_cell.value = reviewer_name            row += 1        dv_upper_req_analysis.ranges.append('C1:C%s'%(row - 1))        # Format if cell is NOK        font = Font(name='Arial',size=10,bold=False,color=RED)        cell_square = 'C3:C%s'%(row - 1)        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"OK"'],                                                 stopIfTrue=True,                                                 fill=greenFill))        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"NOK"'],                                                 stopIfTrue=True,                                                 fill=redFill))        ws.conditional_formatting.add(cell_square,                                      CellIsRule(operator='equal',                                                 formula=['"NOT VERIFIED"'],                                                 stopIfTrue=True,                                                 fill=orangeFill))        #fill=redFill))        #ws.conditional_formatting.add('C3:C%s'%(row - 1),FormulaRule(formula=['E1=NOK'],fill=redFill))        ws = wb.get_sheet_by_name(name = 'CONTEXT')        # save the file        filename = "IS_%s_%d.xlsx" % (filename_is,floor(time.time()))        # Patch for conditional formatting        ws.conditional_formatting.setDxfStyles(wb)        wb.save(join("result",filename))        return filename    def __init__(self,                 basename="",                 hlr_selected=False,                 **kwargs):        for key in kwargs:            self.__dict__[key] = kwargs[key]        if "session_started" in self.__dict__:            Synergy.__init__(self,self.session_started)        if "general_output_txt" in self.__dict__:            CheckLLR.__init__(self,                              basename,                              hlr_selected,                              general_output_txt=self.__dict__["general_output_txt"])        else:            CheckLLR.__init__(self,                              basename,                              hlr_selected)        self.index_row = 0        self.index_column = 0        self.nb_cell_read = 0        self.context_issue = ""        self.log_filename = None        self.log_handler = None        self.tbl_cr = []        self.tbl_is_cr_id = []        self.applicable_docs = {}        self.is_release = ""        self.is_baseline = ""        self.resetKeywords()        self.dico_remarks = {}        self.resetSheetsList()        # Patch temporaire        self.component = ""    def getRemarkInOverfolders(self,tbl_remarks_other_folders):        nb_remarks = len(self.dico_remarks)        # list_remarks_other_folders = []        #print "DICO:",self.dico_remarks        list_remarks_other_folders = self.dico_remarks.values()        #print "list_remarks_other_folders",list_remarks_other_folders        for tbl_remark in list_remarks_other_folders:            for remark_id in tbl_remark:                if remark_id not in tbl_remarks_other_folders:                    try:                        remark_id_int = int(remark_id)                    except ValueError:                        remark_id_int = 0                    tbl_remarks_other_folders.append(remark_id_int)        return nb_remarks    def CheckISGeneric(self,filename_is,skip_change_synergy_var=False,verif_issue_cr_process_start=999):        self.dico_remarks = {}        self.nb_error = 0        # Launch clock        dico_timestamp={}        dico_timestamp["begin_script"] = datetime.now()        #try:        #    wb = load_workbook(filename = filename_is, use_iterators = True)        #except: # InvalidFileException:        #    self.log("File {:s} opening error.".format(filename_is),gui_display=True)        #    return False        wb = self.loadWorkbook(filename_is)        # CONTEXT        self.current_folder = "CONTEXT"        self.log(CheckIS.header("CONTEXT"),gui_display=True)        # Le status de la cellule E6 et la somme des "Open Items Count"        # Pour chaque onglet on compte le nombre de cellules contenant un identifiant de remarque        dico_context = deepcopy(self.keywords)        self.parseContext(wb,dico_context)        #for row,value  in dico_context.iteritems():        #    print "DICO_CONTEXT:",row,value        tbl_cr = []        doc_inspected = self.checkContext(dico_context)        context_issue = doc_inspected[1]        self.log("Document inspected has the reference {:s} and the version {:s}".format(doc_inspected[0],context_issue),gui_display=True)        self.log(CheckIS.header("SPECIFICATION PARSING PART 2"),gui_display=True)        self.log("Modifications implemented in the release {:s}".format(self.is_release),gui_display=True)        for modif in self.tbl_dico_modifs:            # Display only the last modifications in the release of specification            context_version = CheckIS.getVersion(context_issue)            modif_version = CheckIS.getVersion(modif["issue"])            if context_version == modif_version:                line = "Issue {:s}: {:s}".format(modif["issue"],Tool.removeNonAscii(modif["modif"]))                self.log(line,gui_display=True)        # Comparison of CR with Change database        dico_timestamp["begin_change_query"] = datetime.now()        if not skip_change_synergy_var:            query = 'query -u -sby problem_number "(cvtype=\'problem\') and (CR_implemented_for=\'{:s}\')" ' \                    '-f "%problem_number;%crstatus;%CR_domain"'.format(self.is_release) # ;%CR_functional_impact            stdout,stderr = self.ccm_query(query,"Get CRs")            self.log(query + " completed.")            #self.master_ihm.defill()            if stdout != "":                tbl_cr_change = []                output = stdout.splitlines()                for cr in output:                    m = re.match(r'^([0-9]*);(EXCR|SyCR|ECR|SACR|HCR|SCR|BCR|PLDCR)_(.*);(.*)',cr)                    if m:                        cr_id = m.group(1)                        cr_status = m.group(3)                        cr_domain = m.group(4)                        tbl_cr_change.append(cr_id)                        self.log("   Found {:s} {:s} with status {:s} for release {:s}".format(cr_domain,cr_id,cr_status,self.is_release),gui_display=True)                self.cmpCR(tbl_cr_change,self.tbl_is_cr_id)        # Comparison of docs with Synergy database        dico_timestamp["begin_synergy_query"] = datetime.now()        if not skip_change_synergy_var:            list_projects = self._getProjectsList_wo_ihm(self.is_release,self.is_baseline)            #print "list_projects",list_projects            sub_list_rel_bas_proj = []            sub_list_projects = []            for project in list_projects:                m = re.match(r'^CODE_(.*)',project)                if not m:                    prj_name, prj_version = self.getProjectInfo(project)                    sub_list_projects_part = self.findSubProjects(prj_name,prj_version,sub_list_rel_bas_proj,mute=True)                    #print "Synergy thread L1747:",sub_list_projects_part                    sub_list_projects.extend(sub_list_projects_part)                    #print "Synergy thread L1749:",sub_list_projects            sub_list_projects.extend(list_projects)            #print "sub_list_projects",sub_list_projects            list_synergy_docs = []            for project in sub_list_projects:                match_code = re.match(r'^CODE_(.*)',project)                match_plans = re.match(r'^SW_PLAN(.*)',project)                if not match_code:                    # Exclude code source project                    if not match_plans:                        exclude=["Data sheet","CCB_MINUTES"]                        folder_to_search = "Input_Data"                    else:                        exclude=["CCB_MINUTES","SQAP","SDP"]                        folder_to_search = "SW_PLAN"                    self.log("Make Synergy query to get documents in project {:s} in \"{:s}\" folder".format(project,folder_to_search),gui_display=True)                    #print "project treated:",project                    list_synergy_docs_part = self.getItemsInFolder(folder_keyword = folder_to_search,                                                              project=project,                                                              baseline=self.is_baseline,                                                              release=self.is_release,                                                              exclude=exclude,                                                              only_name=False,                                                              with_extension=True,                                                              mute=True)                    #print "list_synergy_docs",list_synergy_docs                    list_synergy_docs.extend(list_synergy_docs_part)            for docs in list_synergy_docs:                m = re.match(r'^(IS|IP|CRI)(.*)',docs)                if not m:                    # Exclude Inspection Sheets                    formatted_doc = re.sub(r'^(.*)_(ET|GS)([0-9]{4})(_[ES])?\.(.*) issue (.*)',r'\2\3/\6: \1 (\5)',docs)                    docs_ljust = formatted_doc.ljust(60)                    self.log("   Found input document {:s} for release {:s}".format(docs_ljust,self.is_release),gui_display=True)        dico_timestamp["end_synergy_query"] = datetime.now()        # REVIEW        self.current_folder = "REVIEW"        self.log(CheckIS.header("REVIEW"),gui_display=True)        list_general_rules = []        self.parseReview(wb,'A2:F50',1,list_general_rules)        nb_review_nok = self.checkStatus(list_general_rules,context_issue)        self.getRemarks(list_general_rules,"REVIEW")        # DOC REVIEW        self.current_folder = "DOC REVIEW"        self.log(CheckIS.header("DOC REVIEW"),gui_display=True)        list_doc_rules = []        self.parseReview(wb,'A2:F100',2,list_doc_rules)        nb_doc_review_nok = self.checkStatus(list_doc_rules,context_issue)        self.getRemarks(list_doc_rules,"DOC REVIEW")        self.log(CheckIS.header("REMARKS"),gui_display=True)        self.current_folder = "REMARKS"        # REMARKS        #        # - Check numbering of remarks is an unbroken sequence        # - Check remarks opened        #        tbl_remarks_other_folders = []        nb_remarks = self.getRemarkInOverfolders(tbl_remarks_other_folders)        list_remarks = []        self.parseReview(wb,'A2:K2000',6,list_remarks)        list_cr = []        nb_remarks_open = self.checkRemarks(list_remarks,list_cr,verif_issue_cr_process_start)        #for x in list_remarks:        #    print "LINE:",x        #print ws.columns        #sheet_ranges = wb['CONTEXT']        #print(sheet_ranges['E6'].value)        self.log("Found {:d} remarks in other folders than REMARK.".format(nb_remarks),gui_display=True)        self.log("Found {:d} remarks OPEN in folder REMARK.".format(nb_remarks_open),gui_display=True)        if nb_remarks != nb_remarks_open:            self.nb_error += 1        nb_errors = len(self.dico_errors)        nb_warnings = len(self.dico_warnings)        self.log("{:d} errors found.".nb_errors,gui_display=True)        self.log("{:d} warnings raised.".nb_warnings,gui_display=True)        self.log("{:d} cells read.".format(self.nb_cell_read),gui_display=True)        self.log("In REVIEW, {:d} errors found.".format(nb_review_nok),gui_display=True)        self.log("In DOC REVIEW, {:d} errors found.".format(nb_doc_review_nok),gui_display=True)        self.log("In REMARKS, {:d} remarks OPEN.".format(nb_remarks_open),gui_display=True)        dico_timestamp["end_script"] = datetime.now()        duree_execution_script = dico_timestamp["end_script"] - dico_timestamp["begin_script"]        duree_execution_change_query = dico_timestamp["begin_synergy_query"] - dico_timestamp["begin_change_query"]        duree_execution_synergy_query = dico_timestamp["end_synergy_query"] - dico_timestamp["begin_synergy_query"]        self.log("Temps d'exécution du script complet: {:d} seconds".format(duree_execution_script.seconds),gui_display=True)        self.log("Temps d'exécution de la requête Change: {:d} seconds".format(duree_execution_change_query.seconds),gui_display=True)        self.log("Temps d'exécution des requêtes Synergy: {:d} seconds".format(duree_execution_synergy_query.seconds),gui_display=True)        return True    def addRemark(self,remarks,item,localisation):        # Several remarks ?        tbl_remark = []        if remarks is not None:            #print "addRemark",remarks,localisation,item            if re.search(",",str(remarks)):                #print "REMARK SPLIT",remarks                tbl_remark = remarks.split(",")            else:                #print "REMARK",remarks                m = re.match(r'^([0-9]*)$',str(remarks))                if m:                    tbl_remark.append(int(remarks))            if item not in self.dico_remarks and tbl_remark != []:                # item is REQ REVIEW, REQ ANALYSIS or                # Localisation is requirement                self.dico_remarks[str(item),str(localisation)] = tbl_remark            else:                #print "ITEM:",remarks,item,localisation                self.dico_errors["remark","IS_5",localisation,remarks,item] = ["Remark identified here: rule {:s} does not exists in REMARK folder.".format(item)]                #print "la remarque existe ailleurs. On fait quoi ?"    def getRemarks(self,tbl_worksheet_cell,folder=False,dico_index={"item":0,"remark":5}):        """        Fill dictionary of remarks        :param tbl_worksheet_cell:        :param dico_index:        :param localisation:        :return:        """        #print "getRemark",tbl_worksheet_cell        if folder == "REVIEW" or folder == "DOC REVIEW":            for row in tbl_worksheet_cell:                item = row[dico_index["item"]]                localisation = ""                remarks = row[dico_index["remark"]]                self.addRemark(remarks,item,localisation)        else:            for row in tbl_worksheet_cell:                item = folder                localisation = row[dico_index["item"]]                remarks = row[dico_index["remark"]]                self.addRemark(remarks,item,localisation)    def checkISForSpec(self,                       filename_is="",                       dirname_req="",                       dirname_upper="",                       type=("SWRD",),                       skip_change_synergy_var=False,                       verif_issue_cr_process_start=2,                       component=""):        """        This function check Inspection Sheet document        First, the function "extract" is called to parse specification documents (ex: SwRD)        Second of all the same function is called again to parse upper specification documents (ex: SSCS)        Then allocation is analysed and only upper requirements allocated to the selected component are kept.        :param filename_is:        :param dirname_req:        :param dirname_upper:        :param type:        :param skip_change_synergy_var:        :param verif_issue_cr_process_start:        :return:        """        self.nb_error = 0        self.dico_remarks = {}        # Launch clock        dico_timestamp={}        dico_timestamp["begin_script"] = datetime.now()        self.log(CheckIS.header("SPECIFICATION PARSING PART 1"),gui_display=True)        self.current_folder = "REQ ANALYSIS"        # Extract requirements from specification        if dirname_req != "":            self.extract(dirname_req,                         type)            self.spec_exists = True        else:            self.spec_exists = False        # Extract requirements from upper specifications.        if dirname_upper != "":            self.upper_exists = True            if type[0] in ("SWRD","PLDRD"):                hlr_selected = True                upper_type = self.getListUpper()            else:                hlr_selected = False                upper_type = ("SWRD",)            upper_type_str = "_".join(upper_type)            upper = CheckLLR(dirname_upper,                             hlr_selected=hlr_selected)            #upper.openLog(upper_type_str)            upper.extract(dirname_upper,                          type=upper_type,                          component=component,                          log_handler=self.log_handler)            # Filter upper requirements to keep only those allocated to the component selected.            upper.getAllocation()            if component != "" and component in upper.dico_alloc_vs_req:                nb_upper_req_found = 0                for file,reqs in upper.tbl_file_llr.iteritems():                    print "FILE:",file                    for req in reqs:                        if req in upper.dico_alloc_vs_req[component]:                            nb_upper_req_found += 1                print "Found {:d} upper requirements allocated to {:s}.".format(nb_upper_req_found,component)                nb_error = self.cmpList(self.list_upper_req,upper.dico_alloc_vs_req[component],"Specifcation document","Upper specification document")            else:                pass            doc_upper = upper.tbl_list_llr        else:            upper = CheckLLR()            self.upper_exists = False            doc_upper = {}        self.log(CheckIS.header("LIST OF MODIFICATIONS"),gui_display=True)        # CONTEXT        self.current_folder = "CONTEXT"        self.log(CheckIS.header("CONTEXT"),gui_display=True)        # Le status de la cellule E6 et la somme des "Open Items Count"        # Pour chaque onglet on compte le nombre de cellules contenant un identifiant de remarque        dico_context = deepcopy(self.keywords)        print "checkISForSpec:filename_is",filename_is        extension = re.sub(r"(.*)\.(.*)",r"\2",filename_is)        if extension in ("xlsx","xlsm"):            # data_only controls whether cells with formulae have either the formula (default) or the value stored the last time Excel read the sheet.            wb = self.loadWorkbook(filename_is,data_only=True)            self.resetSheetsList()            self.parseContext(wb,dico_context)            #for row,value  in dico_context.iteritems():            #    print "DICO_CONTEXT:",row,value            doc_inspected = self.checkContext(dico_context)            context_reference = str(doc_inspected[0])            context_issue = str(doc_inspected[1])            self.log("Document inspected has the reference {:s} and the version {:s}".format(context_reference,context_issue),gui_display=True)            self.log(CheckIS.header("SPECIFICATION PARSING PART 2"),gui_display=True)            release = str(self.is_release)            self.log("Modifications implemented in the release {:s}".format(release),gui_display=True)            for modif in self.tbl_dico_modifs:                # Display only the last modifications in the release of specification                context_version = CheckIS.getVersion(context_issue)                if "issue" in modif:                    modif_version = CheckIS.getVersion(modif["issue"])                    if context_version == modif_version:                        line = "Issue {:s}: {:s}".format(modif["issue"],Tool.removeNonAscii(modif["modif"]))                        self.log(line)            # Comparison of CR with Change database            dico_timestamp["begin_change_query"] = datetime.now()            if not skip_change_synergy_var:                query = 'query -u -sby problem_number "(cvtype=\'problem\') and (CR_implemented_for=\'{:s}\')" ' \                        '-f "%problem_number;%crstatus;%CR_domain"'.format(self.is_release) # ;%CR_functional_impact                stdout,stderr = self.ccm_query(query,"Get CRs")                self.log(query + " completed.")                #self.master_ihm.defill()                if stdout != "":                    tbl_cr_change = []                    output = stdout.splitlines()                    for cr in output:                        m = re.match(r'^([0-9]*);(EXCR|SyCR|ECR|SACR|HCR|SCR|BCR|PLDCR)_(.*);(.*)',cr)                        if m:                            cr_id = m.group(1)                            cr_status = m.group(3)                            cr_domain = m.group(4)                            tbl_cr_change.append(cr_id)                            self.log("   Found {:s} {:s} with status {:s} for release {:s}".format(cr_domain,cr_id,cr_status,self.is_release),gui_display=True)                    self.cmpCR(tbl_cr_change,self.tbl_is_cr_id)            # Comparison of docs with Synergy database            dico_timestamp["begin_synergy_query"] = datetime.now()            if not skip_change_synergy_var:                list_projects = self._getProjectsList_wo_ihm(self.is_release,self.is_baseline)                #print "list_projects",list_projects                sub_list_rel_bas_proj = []                sub_list_projects = []                for project in list_projects:                    m = re.match(r'^CODE_(.*)',project)                    if not m:                        prj_name, prj_version = self.getProjectInfo(project)                        sub_list_projects_part = self.findSubProjects(prj_name,prj_version,sub_list_rel_bas_proj,mute=True)                        #print "Synergy thread L1747:",sub_list_projects_part                        sub_list_projects.extend(sub_list_projects_part)                        #print "Synergy thread L1749:",sub_list_projects                sub_list_projects.extend(list_projects)                #print "sub_list_projects",sub_list_projects                list_synergy_docs = []                for project in sub_list_projects:                    match_code = re.match(r'^CODE_(.*)',project)                    match_plans = re.match(r'^SW_PLAN(.*)',project)                    if not match_code:                        # Exclude code source project                        if not match_plans:                            exclude=["Data sheet","CCB_MINUTES"]                            folder_to_search = "Input_Data"                        else:                            exclude=["CCB_MINUTES","SQAP","SDP"]                            folder_to_search = "SW_PLAN"                        self.log("Make Synergy query to get documents in project {:s} in \"{:s}\" folder".format(project,folder_to_search),gui_display=True)                        #print "project treated:",project                        list_synergy_docs_part = self.getItemsInFolder(folder_keyword = folder_to_search,                                                                  project=project,                                                                  baseline=self.is_baseline,                                                                  release=self.is_release,                                                                  exclude=exclude,                                                                  only_name=False,                                                                  with_extension=True,                                                                  mute=True)                        #print "list_synergy_docs",list_synergy_docs                        list_synergy_docs.extend(list_synergy_docs_part)                for docs in list_synergy_docs:                    m = re.match(r'^(IS|IP|CRI)(.*)',docs)                    if not m:                        # Exclude Inspection Sheets                        formatted_doc = re.sub(r'^(.*)_(ET|GS)([0-9]{4})(_[ES])?\.(.*) issue (.*)',r'\2\3/\6: \1 (\5)',docs)                        docs_ljust = formatted_doc.ljust(60)                        self.log("   Found input document {:s} for release {:s}".format(docs_ljust,self.is_release),gui_display=True)            dico_timestamp["end_synergy_query"] = datetime.now()            # REVIEW            self.current_folder = "REVIEW"            self.log(CheckIS.header("REVIEW"),gui_display=True)            list_general_rules = []            self.parseReview(wb,'A2:F50',1,list_general_rules)            nb_review_nok = self.checkStatus(list_general_rules,context_issue)            self.getRemarks(list_general_rules,"REVIEW")            # DOC REVIEW            self.current_folder = "DOC REVIEW"            self.log(CheckIS.header("DOC REVIEW"),gui_display=True)            list_srs_rules = []            self.parseReview(wb,'A2:F100',2,list_srs_rules)            self.nb_error += self.checkRules(list_srs_rules)            nb_doc_review_nok = self.checkStatus(list_srs_rules,context_issue)            self.getRemarks(list_srs_rules,"DOC REVIEW")            #print "Remarks for DOC REVIEW",self.dico_remarks            # REQ REVIEW            self.current_folder = "REQ REVIEW"            self.log(CheckIS.header("REQ REVIEW"),gui_display=True)            is_list_reqs = []            self.parseReview(wb,'A3:BS1000',3,is_list_reqs)            # Check coherency between requirement list in IS an requirement in specification document            self.tbl_reqs_updated = self.checkReq(is_list_reqs)            self.log("Nb requirements updated for this release according to REQ REVIEW folder: {:d}.".format(len(self.tbl_reqs_updated)),gui_display=True)            for req in self.tbl_reqs_updated:                self.log("   " + req)            # Check specific for DOC REVIEW: Need to sweep all rules ...            # Get rules            is_list_srs_res_rules = []            self.parseReview(wb,'F1:BS1',3,is_list_srs_res_rules)            if is_list_srs_res_rules != []:                tbl_srs_req_rules = self.checkReqRules(is_list_srs_res_rules[0])                nb_req_review_nok = self.checkStatusReqReview(is_list_reqs,tbl_srs_req_rules)            else:                tbl_srs_req_rules = []                nb_req_review_nok = 0            # REQ ANALYSIS (§6.3.1a of DO-178B: Compliance with system requirements)            # SwRD Requirement.: SwRD requirement (except DELETED)            # Requirement Issue: SwRD requirement issue            # REQ ANALYSIS:            #  o NOK if SwRD. requirement does not comply with one or more linked Equip./Syst. Req or Derived SwRD is not correctly justified.            #  o NOT VERIFIED if SwRD requirement is not verified,            #  o OK if SwRD requirement complies with all linked Equip./Syst.req or Derived SwRD is correctly justified.            # Reviewers: list of reviewer’s names on the last reviewed document issue for the item’s objective.            # Reviewed Requirement Issue: the last reviewed requirement issue for the item.            # Remarks: list of remarks number logged in the “REMARKS” sheet if the remarks are still presents in the current context.            self.log(CheckIS.header("REQ ANALYSIS"),gui_display=True)            self.current_folder = "REQ ANALYSIS"            header = [u'SwRD Req.', u'Req. Issue', u'REQ_ANALYSIS', u'Reviewers', u'Req. Issue', u'Remarks']            del(is_list_reqs[:])            self.parseReview(wb,'A3:F1000',4,is_list_reqs)            # Check coherency between requirement list in IS and requirement in specification document            if self.spec_exists:                tbl_reqs_updated = self.checkReq(is_list_reqs,True)            # Check status            nb_req_analysis_nok = self.checkStatus(is_list_reqs)            self.getRemarks(is_list_reqs,"REQ ANALYSIS")            #self.log("Nb requirements updated for this release according to REQ ANALYSIS folder: {:d}".format(len(tbl_reqs_updated)))            self.log(CheckIS.header("UPPER REQ ANALYSIS"))            self.current_folder = "UPPER REQ ANALYSIS"            # UPPER REQ ANALYSIS: (§6.3.1f of DO-178B: Traceability -> the requirements of the system are developed into the high-level requirements.            del(is_list_reqs[:])            self.parseReview(wb,'A3:F1000',5,is_list_reqs)            # Check coherency with specification (Refers to)            list_upper_req = []            self.getUpperReqList(list_upper_req)            nb_upper_reqs = len(list_upper_req)            if self.upper_exists:                #print "checkUpperReq:is_list_reqs",is_list_reqs                #print "checkUpperReq:list_upper_req",list_upper_req                #print "checkUpperReq:doc_upper",doc_upper                self.checkUpperReq(is_list_reqs,        # is_list_reqs contains list of upper requirements extracted from IS                                   list_upper_req,      # list_upper_req contains list of upper requirements extracted from "Refers to" specification (ex: SWRD)                                   doc_upper)           # doc_upper contains list of upper requirements extracted from specification (ex: SSCS)            # Check status            nb_upper_req_analysis_nok = self.checkStatus(is_list_reqs)            self.getRemarks(is_list_reqs,"UPPER REQ ANALYSIS")            # Check reader            dico_readers,effort_total = self.checkReviewers(is_list_reqs)            if nb_upper_reqs != 0:                for reader,effort in dico_readers.iteritems():                    pourcentage = effort * 100 / nb_upper_reqs                    self.log("{:s} reading effort: {:d}%".format(reader,pourcentage))            self.log(CheckIS.header("REMARKS"),gui_display=True)            self.current_folder = "REMARKS"            # REMARKS            #            # - Check numbering of remarks is an unbroken sequence            # - Check remarks opened            #            #print "Remarks for REQ REVIEW"            tbl_remarks_other_folders = []            nb_remarks_infolder = self.getRemarkInOverfolders(tbl_remarks_other_folders)            #for value in  self.dico_remarks.values():            #    list_remarks_other_folders.append(value)                #"print "DICO_REMARK;",loc,item,value            list_remarks = []            self.parseReview(wb,'A2:K2000',6,list_remarks)            self.nb_remarks = len(list_remarks)            list_remarks_open = []            list_cr =[]            self.nb_remarks_open = self.checkRemarks(list_remarks,                                                list_cr,                                                verif_issue_cr_process_start,                                                list_remarks_open)            #print "Nb remaks open:",nb_remarks_open            #print "cmpList arg 1:",tbl_remarks_other_folders            #print "cmpList arg 2 list_remarks_open:",list_remarks_open            #print "tbl_list_llr",self.tbl_list_llr            self.nb_error += self.cmpList(tbl_remarks_other_folders,                                          list_remarks_open,                                          cmp_one="REMARK folder",                                          cmp_two="any other folder")            if not skip_change_synergy_var:                self.log(CheckIS.header("Check CR is software related"),gui_display=True)                # Test if CR are software related:                dico_cr = {}                for cr in list_cr:                    #print "CR:",cr                    self.getCRInfo(cr,dico_cr,parent=False)                for cr_id,value in dico_cr.iteritems():                    type = value[0]                    if value[0] != "SCR":                        self.log("CR {:s} is a {:s} and should be a SCR instead.".format(cr_id,type),gui_display=True)                        self.nb_error += 1            self.log("Found {:d} remarks in other folders than REMARK.".format(nb_remarks_infolder),gui_display=True)            self.log("Found {:d} remarks OPEN in folder REMARK.".format(self.nb_remarks_open),gui_display=True)            if nb_remarks_infolder != self.nb_remarks_open:                self.nb_error += 1            #print ws.columns            #sheet_ranges = wb['CONTEXT']            #print(sheet_ranges['E6'].value)            self.log("{:d} errors found.".format(len(self.dico_errors)),gui_display=True)            self.log("{:d} warnings found.".format(len(self.dico_warnings)),gui_display=True)            self.log("{:d} cells read.".format(self.nb_cell_read),gui_display=True)            self.log("In REVIEW sheet, {:d} errors found.".format(nb_review_nok),gui_display=True)            self.log("In DOC REVIEW sheet, {:d} errors found.".format(nb_doc_review_nok),gui_display=True)            self.log("In REQ REVIEW sheet, {:d} requirements not OK.".format(nb_req_review_nok),gui_display=True)            self.log("In REQ ANALYSIS sheet, {:d} requirements not OK.".format(nb_req_analysis_nok),gui_display=True)            self.log("In UPPER REQ ANALYSIS sheet, {:d} requirements not OK.".format(nb_upper_req_analysis_nok),gui_display=True)            self.log("In REMARKS sheet, {:d} remarks OPEN.".format(self.nb_remarks_open),gui_display=True)            dico_timestamp["end_script"] = datetime.now()            duree_execution_script = dico_timestamp["end_script"] - dico_timestamp["begin_script"]            duree_execution_change_query = dico_timestamp["begin_synergy_query"] - dico_timestamp["begin_change_query"]            duree_execution_synergy_query = dico_timestamp["end_synergy_query"] - dico_timestamp["begin_synergy_query"]            self.log("Temps d'exécution du script complet: {:d} seconds".format(duree_execution_script.seconds),gui_display=True)            self.log("Temps d'exécution de la requête Change: {:d} seconds".format(duree_execution_change_query.seconds),gui_display=True)            self.log("Temps d'exécution des requêtes Synergy: {:d} seconds".format(duree_execution_synergy_query.seconds),gui_display=True)            filename_is_short = self.extractName(filename_is)        else:            # Wrong Word format, only openxml            text = "Wrong Excel format for {:s}, only openxml format (xlsx/xlsm) accepted".format(filename_is)            self.log(text)            doc_inspected = ("None","None")            filename_is_short = ""        return upper.tbl_file_llr,doc_inspected,filename_is_short    def getValue(self,                 deepcopy_keywords,                 key,                 tag,                 value,                 label=None):        for sub_tag,offset in self.keywords[key].iteritems():            if isinstance(offset,int) and self.index_row == (tag["row"] + offset) and self.index_column == (tag["column"] + 1):                #print "tag:",tag                #print "getValue:",key,tag,label,sub_tag,offset                #print "offset",offset                if label is not None:                    deepcopy_keywords[key][label] = value                else:                    deepcopy_keywords[key][sub_tag] = value            self.nb_cell_read += 1    def fillDico(self,key,word="DOC"):        for x in range(1,30):            str = "{:s}_{:d}".format(word,x)            self.keywords[key][str] = x    def parseReview(self,wb,range='A1:F50',sheet_no=1,review_tbl = []):        """        Update_ReqStatus        REQ ANALYSIS (SVP §4.2.5.2.2 SwRD Analysis)            Si la version de l'exigence dans la colonne "Requirement Issue"            est inférieure à la version revue dans la colonne "Reviewed Req. Issue"            et que la colonne "Remark" est vide            alors la fonction renvoie "OK" sinon elle renvoie "NOK" dans le cas où des remarques existent.            Si la version revue dans la colonne "Reviewed Req. Issue"            est inférieure à la version de l'exigence dans la colonne "Requirement Issue" ou que la colonne "Reviewers" est vide            alors la fonction renvoie "NOT VERIFIED"        REQ REVIEW (SVP §4.2.4.8 SwRD Review)            Même principe que pour REQ ANALYSIS sauf que la fonction boucle sur toutes les règles.            Si une des règles est "NOT VERIFIED" alors la fonction renvoie:                - PARTIALLY VERIFIED (NOK): Une des règles n'est pas vérifiée et une remarque au moins existe                - PARTIALLY VERIFIED (OK): Une des règles n'est pas vérifiée et aucune remarque n'est enregistrée        GetReviewerNames            Cette fonction, utilisée dans l'onglet REQ REVIEW, permet de concaténer tous les noms des relecteurs par règle            à condition que l'auteur est vérifié la règle pour la version courante de l'exigence.        Concatener_ReqRemarks            Cette fonction, utilisée dans l'onglet REQ REVIEW, permet de concaténer toutes les remarques par règle            quelque soit la version de l'exigence revue        :param wb:        :param range:        :param sheet_no:        :return:        """        #        # Column "Status" in REVIEW, DOC_REVIEW and REQ REVIEW sheet is filled automatically with the formula:        # Update_ReqStatus(D2:F2,F2,Issue)        #        # Column "Remarks" in REQ REVIEW sheet is filled automatically with the formula:        # Concatener_ReqRemarks(F679:BS679)        #        # Column "Reviewers" in REQ REVIEW sheet is filled automatically with the formula:        # GetReviewerNames(F679:BS679,B679)        #        # Column "REQ_ANALYSIS" in REQ ANALYSIS sheet is filled automatically with the formula:        # Update_ReqStatus(D3:F3,F3,B3)        #        if wb:            ws = wb.get_sheet_by_name(name = self.sheets_list[sheet_no]) # ws is now an IterableWorksheet            if ws is not None:                for row in ws.iter_rows(range): # it brings a new method: iter_rows()                    self.index_row += 1                    # New line                    row_tbl = []                    self.index_column = 0                    for cell in row:                        self.index_column += 1                        row_tbl.append(cell.value)                        self.nb_cell_read += 1                        #if self.nb_cell_read > 65530:                        #    print self.nb_cell_read                    review_tbl.append(row_tbl)    def cmpDocs(self,expected,found):        union = list(set(expected) & set(found))        exclusion = list(set(expected) ^ set(found))        len_union = len(union)        len_found = len(found)        if len_union == len_found and exclusion == []:            match = True        elif len_union < len_found:            match = False            self.nb_error += 1            for req in exclusion:                self.log("Warning: Documents {:s} found in Inspection Sheet but not in Synergy for release {:s}".format(req,self.is_release),True)                self.nb_error += 1        else:            match = False            self.nb_error += 1            print "Unexpected items",exclusion        return match    def cmpCR(self,expected,found):        union = list(set(expected) & set(found))        exclusion = list(set(expected) ^ set(found))        len_union = len(union)        len_found = len(found)        if len_union == len_found and exclusion == []:            match = True        elif len_union < len_found:            match = False            self.nb_error += 1            for req in exclusion:                self.log("Warning: CR {:s} found in Inspection Sheet but not in Change for release {:s}".format(req,self.is_release),True)                self.nb_error += 1        else:            match = False            self.nb_error += 1            print "Unexpected items",exclusion        return match    def checkContext(self,dico_context):        self.tbl_cr = []        self.tbl_is_cr_id = []        doc_inspected = {}        project_info = {}        applicable_docs = {}        for part,y in dico_context.iteritems():            for tag,content in y.iteritems():                if not re.match(r'^EMPTY.*',tag):                    if part == "docs":                        self.applicable_docs[tag]= content                    elif part == "gen":                        project_info[tag]= content                        if tag == "Project Release":                            self.is_release = content                    elif part == "ids":                        doc_inspected[tag]= content                        if tag == "Verification baseline":                            self.is_baseline = content                    elif part == "crs":                        #print "TEST_TAG",tag                        cr_id = re.sub(r'.*CR([0-9]*)',r'\1',tag)                        if content is None:                            content = "None"                        self.tbl_cr.append((cr_id,content))                        self.tbl_is_cr_id.append(cr_id)                    #print "{:s} => {:s}->{:s}->{:s}".format(self.current_folder,part,tag,content)        nb_crs = len(self.tbl_cr)        self.log("Found {:d} change requests".format(nb_crs),gui_display=True)        if nb_crs > 0:            self.tbl_cr.sort()            for cr,synopsis in self.tbl_cr:                self.log("   {:s}: {:s}".format(cr,synopsis),gui_display=True)        nb_applicable_docs = len(self.applicable_docs)        self.log("Found {:d} applicable documents".format(nb_applicable_docs),gui_display=True)        if nb_applicable_docs > 0:            for title,reference in self.applicable_docs.iteritems():                self.log("   {:s}: {:s}".format(reference,title),gui_display=True)        self.log("Release: {}".format(self.is_release))        self.log("Baseline: {}".format(self.is_baseline))        self.context_issue = doc_inspected["Issue"]        return doc_inspected["Reference"],doc_inspected["Issue"]    def checkReqRules(self,list_srs_res_rules):        tbl_srs_req_rules = []        nb_expected_srs_req_rules = len(self.expected_srs_req_rules_dico)        for rule in list_srs_res_rules:            if rule is not None:                tbl_srs_req_rules.append(rule)        nb_found_srs_req_rules = len(tbl_srs_req_rules)        if nb_found_srs_req_rules != nb_expected_srs_req_rules:            self.log( "Warning: Found {:d} SRS_REQ rules instead of {:d} expected.".format(nb_found_srs_req_rules,nb_expected_srs_req_rules),True)        return tbl_srs_req_rules    def checkRules(self,list_srs_rules):        """        Function specific for requirements specification check        :param list_srs_rules:        :return:        """        # Liste des règles SRTS        nb_expected_srs_rules = len(self.expected_srs_rules)        nb_found_srs_rules = len(list_srs_rules)        if nb_found_srs_rules != nb_expected_srs_rules:            self.dico_errors["consistency","IS_6","REQ REVIEW","",""] = ["Found {:d} SRS_REQ rules instead of {:d} expected.".format(nb_found_srs_rules,nb_expected_srs_rules)]            #self.log( "Warning: Found {:d} SRS_REQ rules instead of {:d} expected.".format(nb_found_srs_rules,self.nb_expected_srs_rules),True)        found_srs_rules = []        for srs_rule in list_srs_rules:            found_srs_rules.append(srs_rule[0])        nb_errors = self.cmpList(self.expected_srs_rules,found_srs_rules)        #print "match:",match        return nb_errors    def checkUpperReq(self,                      is_list_reqs,                      upper_list_req,                      upper_list_req_from_upper={}):        """        Compare amount of upper requirements with IS        Compare reviewed issue with requirement issue        :param is_list_reqs: contains list of upper requirements extracted from IS        :param upper_list_req: contains list of upper requirements extracted from "Refers to" specification        :param upper_list_req_from_upper: contains upper requirements coming form specification document per document                                        ex: SSCS_ACLog_790 {'status': u'MATURE', etc.        :return:        """        nb_reqs = len(is_list_reqs)        found_reqs = []        is_list_reqs_w_issue = []        for req in is_list_reqs:            found_reqs.append(req[0])            is_list_reqs_w_issue.append((req[0],  # Req ID                                         req[1],  # Requirement issue                                         req[4])) # REviewed issue        # Check coherency between requirement list in IS an requirement in specification document        nb_reqs_in_doc = len(upper_list_req)        if nb_reqs != nb_reqs_in_doc:            self.log( "Warning: Found {:d} upper requirement in Inspection Sheet instead of {:d} expected from specification document.".format(nb_reqs,nb_reqs_in_doc),True)        self.nb_error += self.cmpList(upper_list_req,found_reqs)        tbl_reqs_updated = []        for req,is_issue,is_reviewed_issue in is_list_reqs_w_issue:            # Display requirements candidates for re-inspection and status of inspection            #version_context = getVersion(context_issue)            # In excel file sometimes numbers are integers and sometimes strings            is_issue_str = str(is_issue)            is_reviewed_issue_str = str(is_reviewed_issue)            version_is = CheckIS.getVersion(is_issue_str)            version_reviewed_is = CheckIS.getVersion(is_reviewed_issue)            #if version_context == version_is:            #    tbl_reqs_updated.append(req)            # Get differences            if is_issue_str != is_reviewed_issue_str:                self.nb_error += 1                self.dico_errors["consistency","IS_8",self.current_folder,req,""] = ["For {:s} issue is {:s} in 'Review issue' column whereas issue is {:s} in 'Req. Issue' column.".format(req,is_issue_str,is_reviewed_issue_str)]            # Compare with issue in upper specification            upper_issue = self.getIssue(req,                                        upper_list_req_from_upper)            if upper_issue != "Unknown":                upper_issue_str = str(upper_issue)                if upper_issue != is_issue:                    self.nb_error += 1                    self.dico_errors["consistency","IS_19",self.current_folder,req,""] = ["For {:s} issue is {:s} in 'Review issue' column whereas issue is {:s} in upper specification.".format(req,is_issue_str,upper_issue_str)]            else:                    #self.nb_error += 1                    self.dico_debug["consistency","IS_20",self.current_folder,req,""] = ["Requirement {:s} is not included in upper specification.".format(req)]    @staticmethod    def getVersion(issue):        version = re.sub(r"(.*)\.(.*)", r"\1", str(issue))        return version    def checkReq(self,                 is_list_reqs,                 check_issue_in_xls=False):        nb_reqs = len(is_list_reqs)        #print "{:d} requirements found in IS REQ REVIEW sheet:".format(nb_reqs)        found_reqs = []        is_list_reqs_w_issue = []        for req in is_list_reqs:            found_reqs.append(req[0])            is_list_reqs_w_issue.append((req[0],req[1],req[4]))        # Check coherency between requirement list in IS an requirement in specification document        for doc_name,reqs_in_doc in self.tbl_file_llr_wo_del.iteritems():            nb_reqs_in_doc = len(reqs_in_doc)            self.log("{:d} requirements found in specification document {:s}:".format(nb_reqs_in_doc,doc_name))            self.nb_error += self.cmpList(reqs_in_doc,found_reqs)        tbl_reqs_updated = []        for req,is_issue,is_reviewed_issue in is_list_reqs_w_issue:            # Display requirements candidates for re-inspection and status of inspection            version_context = CheckIS.getVersion(self.context_issue)            version_is = CheckIS.getVersion(is_issue)            version_reviewed_is = CheckIS.getVersion(is_reviewed_issue)            if version_context == version_is:                tbl_reqs_updated.append(req)            # Get differences            if req in self.tbl_list_llr:                value = self.tbl_list_llr[req]                spec_issue = CheckLLR.getAtribute(value,"issue")                spec_issue_regex = self.cleanIssue(spec_issue)                is_issue_regex = self.cleanIssue(is_issue)                if spec_issue_regex != is_issue_regex:                    self.nb_error += 1                    self.dico_errors["consistency","IS_9",self.current_folder,req,""] = ["For {:s} issue is {:s} in specification document and {:s} in Inspection Sheet.".format(req,spec_issue,is_issue)]                elif check_issue_in_xls and is_issue != is_reviewed_issue:                    self.nb_error += 1                    self.dico_errors["consistency","IS_10",self.current_folder,req,""] = ["For {:s} issue is {:s} in 'Review issue' column and {:s} in 'Req. Issue' column.".format(req,is_issue,is_reviewed_issue)]        return tbl_reqs_updated    @staticmethod    def cleanIssue(number):        number_regex = re.sub(r'([0-9]*)\.([0-9]*)',r'\1.\2',number)        return number_regex    def checkRemarks(self,                     list_remarks,                     list_cr=[],                     verif_issue_cr_process_start=2,                     list_remarks_folder=[]):        index = 1        nb_remarks_open = 0        for remarks in list_remarks:            if remarks[0] is not None:                try:                    id = int(remarks[0])                except ValueError,e:                    print e                remark_id = "Remark {:d}".format(id)                # Localisation in document                localisation = remarks[2]                # Item                item = remarks[4]                if id != index:                    self.dico_errors["miscelleanous","IS_11",self.current_folder,remark_id,""] = ["Remark ID should be {:d} instead of {:d}.".format(index,id)]                    #self.log("Warning: {:s} => Remark ID should be {:d} instead of {:d}".format(self.current_folder,index,id),True)                    #print "Warning: {:s} => Remark ID should be {:d} instead of {:d}".format(self.current_folder,index,id)                    self.nb_error += 1                    index = id                index += 1                status = remarks[7]                cr = remarks[8]                origin_issue = remarks[5]                verif_issue = remarks[9]                if cr is not None:                    # Test if CR match a number only                    test_cr = re.match(r'([^0-9]*)([0-9]{1,4})',str(cr))                    if test_cr:                        # Yes it is                        cr = test_cr.group(2)                        if cr not in list_cr:                            list_cr.append(cr)                else:                    # Check if CR process was entered                    try:                        origin_version = int(CheckIS.getVersion(origin_issue))                    except ValueError:                        self.dico_errors["status","IS_12",self.current_folder,remark_id,""] = ["Invalid verification issue for remark."]                        self.nb_error += 1                    if origin_version < verif_issue_cr_process_start:                        # CR process is not yet started for this document                        test_cr = True                    elif origin_version == verif_issue_cr_process_start:                        self.dico_errors["status","IS_13",self.current_folder,remark_id,""] = ["No CR has been submitted whereas the CR process has already started."]                        test_cr = True                    else:                        test_cr = False                # Check remark status                if (status == "CORRECTED" and verif_issue > origin_issue and test_cr) or \                        (status == "REJECTED" and verif_issue >= origin_issue):                    # Status is CORRECTED and issue verified is greater than issue including the defect.                    # Status is REJECTED and issue verified is greater than or equal to the issue when the remark was raised.                    # CR process is not yet started for this document or a CR is missing                    # No problem, remark is closed.                    pass                elif (status == "CORRECTED" and verif_issue <= origin_issue and test_cr):                    # Status is CORRECTED and issue verified is lower than or equal to the issue including the defect.                    # CR process is not yet started for this document or a CR is missing                    # Remark is still open.                    nb_remarks_open += 1                    list_remarks_folder.append(id)                    if verif_issue == "":                        # Remark corrected but not verified                        self.dico_errors["status","IS_14",self.current_folder,remark_id,""] = ["Verification issue is equal or lower than document issue including the defect."]                        self.nb_error += 1                elif status == "TO BE DISCUSSED":                        self.dico_errors["status","IS_23",self.current_folder,remark_id,""] = ["Status TO BE DISCUSSED not allowed at this stage of peer review process."]                elif not test_cr:                    # CR cell not valid (expecting a number)                    self.dico_errors["status","IS_15",self.current_folder,remark_id,""] = ["Remark {:d} is KO because CR cell is not valid (4.2.3 of SVP)."]                    self.nb_error += 1                    nb_remarks_open += 1                    list_remarks_folder.append(id)                else:                    self.dico_warnings["status","IS_16",self.current_folder,remark_id,""] = ["Remark OPEN."]                    self.nb_warning += 1                    nb_remarks_open += 1                    list_remarks_folder.append(id)                    # Check remark NOK which should appear in other worksheets                    try:                        if localisation is not None:                            localisation = str(Tool.replaceNonASCII(localisation))                            item = re.sub(r'_',r' ',str(item))                            if (item,localisation) in self.dico_remarks:                                dico_remark_line = self.dico_remarks[(item,localisation)]                                if id not in dico_remark_line:                                    self.log("Warning: {:s} => Remark {:d} is not seen in localisation {:s} with item {:s}".format(self.current_folder,id,localisation,item),True)                        else:                            localisation = ""                    except KeyError,e:                        print e                        self.log("Warning: {:s} => Remark {:d} is not seen in localisation {:s} with item {:s}".format(self.current_folder,id,localisation,item),True)                    except UnicodeEncodeError,e:                        print e                        print "Warning: {:s} => Remark {:d} used non ASCII character".format(self.current_folder,id)                    except TypeError,e:                        print e                        print "Warning: {:s} => Remark {:d} used weird character".format(self.current_folder,id)                        print "LOCALISATION",localisation        return nb_remarks_open    @staticmethod    def header(text):        if 0==1:            length = len(text)            line_tbl = []            for x in range(length + 4):                line_tbl.append("*")            line_str = "".join(line_tbl)            return line_str + "\n* " + text +" *\n" + line_str        header = "### {:s} ###".format(text)        return header    @staticmethod    def headerNice(text):        length = len(text)        line_tbl_top = []        line_tbl_bottom = []        line_tbl_top.append("É")        line_tbl_bottom.append("È")        for x in range(length + 4):            line_tbl_top.append("Í")            line_tbl_bottom.append("Í")        line_tbl_top.append("»")        line_tbl_bottom.append("¼")        line_top_str = "".join(line_tbl_top)        line_bottom_str = "".join(line_tbl_bottom)        return line_top_str + "\nº " + text +" º\n" + line_bottom_str    def detectError(self,rule_id,document_issue,req_issue,remarks,reviewer,type="Rule"):        if document_issue == req_issue and remarks is None and reviewer is not None:            #print "Rule {:s} is OK".format(rule_id)            return False        elif document_issue < req_issue:            self.dico_warnings["status","IS_1",self.current_folder,rule_id,""] = ["Status is NOT VERIFIED (verified issue < requirement/document issue)."]            #self.log("Warning: {:s} => {:s} {:s} status is NOT VERIFIED".format(self.current_folder,type,rule_id),True)        elif document_issue > req_issue:            self.dico_errors["status","IS_2",self.current_folder,rule_id,""] = ["Verified version does not exist (verified issue > requirement/document issue)."]            #self.log("Warning: {:s} => {:s} {:s} verified version does not exist".format(self.current_folder,type,rule_id),True)        else:            self.dico_warnings["status","IS_3",self.current_folder,rule_id,""] = ["Status is NOK (A remark exists)."]            #self.log("Warning: {:s} => {:s} {:s} status is NOK".format(self.current_folder,type,rule_id),True)            #print "Warning: {:s} => Requirement {:s} is not OK".format(self.current_folder,rule_id)            self.nb_error += 1        return True    def checkStatus(self,list_general_rules,context_issue=None,dico_index={"reviewer":3,"issue":4,"remark":5}):        nb_nok = 0        for rule in list_general_rules:            rule_id = rule[0]            if rule_id is not None:                # It is a true line check otherwise it is just information                reviewer = rule[dico_index["reviewer"]]                document_issue = rule[dico_index["issue"]]                remarks = rule[dico_index["remark"]]                if context_issue is not None:                    # REVIEW and DOC REVIEW                    result = self.detectError(rule_id,document_issue,context_issue,remarks,reviewer,type="Rule")                    if result:                        nb_nok += 1                    #if document_issue == context_issue and remarks is None and reviewer is not None:                    #    #print "Rule {:s} is OK".format(rule_id)                    #    pass                    #elif document_issue < context_issue:                    #    self.log("Warning: {:s} => Rule  {:s} status is NOT VERIFIED".format(self.current_folder,rule_id),True)                    #    self.nb_error += 1                    #elif document_issue > context_issue:                    #    self.log("Warning: {:s} => Rule  {:s} verified version does not exist".format(self.current_folder,rule_id),True)                    #    self.nb_error += 1                    #else:                    #    self.log("Warning: {:s} => Rule {:s} is not OK".format(self.current_folder,rule_id),True)                    #    #print "Warning: {:s} => Rule {:s} is not OK".format(self.current_folder,rule_id)                    #    self.nb_error += 1                else:                    # REQ ANALYSIS and UPPER REQ ANALYSIS                    req_issue = rule[1]                    if type(req_issue) != type(document_issue):                        # ValueError: invalid literal for int() with base 10: '3D6'                        try:                            req_issue = int(req_issue)                            if document_issue is not None:                                document_issue = int(document_issue)                            else:                                document_issue = ""                        except ValueError:                            print "type(req_issue)",type(req_issue)                            pass                        except TypeError:                            pass                    result = self.detectError(rule_id,document_issue,req_issue,remarks,reviewer,type="Requirement")                    if result:                        nb_nok += 1                    #if document_issue == req_issue and remarks is None and reviewer is not None:                    #    #print "Rule {:s} is OK".format(rule_id)                    #    pass                    #elif document_issue < req_issue:                    #    self.log("Warning: {:s} => Requirement {:s} status is NOT VERIFIED".format(self.current_folder,rule_id),True)                    #elif document_issue > req_issue:                    #    self.log("Warning: {:s} => Requirement {:s} verified version does not exist".format(self.current_folder,rule_id),True)                    #else:                    #    self.log("Warning: {:s} => Requirement {:s} status is NOK".format(self.current_folder,rule_id),True)                    #    #print "Warning: {:s} => Requirement {:s} is not OK".format(self.current_folder,rule_id)                    #    self.nb_error += 1        return nb_nok    def checkReviewers(self,list_req,dico_index={"reviewer":3}):        dico_save_reviewers = {}        for row in list_req:            req_id = row[0]            reviewers = row[dico_index["reviewer"]]            if reviewers is not None:                # Split reviewer                tbl_reviewer = reviewers.split(",")                for reader in tbl_reviewer:                    reader = re.sub(r' ',r'',reader)                    if reader not in dico_save_reviewers:                        dico_save_reviewers[reader] = 1                    else:                        dico_save_reviewers[reader] += 1        effort_total = 0        for reader,effort in dico_save_reviewers.iteritems():            effort_total += effort        return dico_save_reviewers,effort_total    def checkStatusReqReview(self,                             list_reqs,                             list_srs_req_rules,                             dico_index={"req_id":0,"req_issue":1,"reviewer":5,"issue":6,"remark":7}):        """        :param list_reqs:        :param list_srs_req_rules:        :param dico_index:        :return:        """        tbl_save_errors = []        nb_reqs_nok = 0        for req in list_reqs:            del(tbl_save_errors[:])            req_id = req[dico_index["req_id"]]            req_issue = req[dico_index["req_issue"]]            reviewer_index = dico_index["reviewer"]            issue_index = dico_index["issue"]            remark_index = dico_index["remark"]            for rule in list_srs_req_rules:                reviewer = req[reviewer_index]                req_reviewed_issue = req[issue_index]                remarks = req[remark_index]                reviewer_index += 3                issue_index += 3                remark_index += 3                self.addRemark(remarks,rule,req_id)                rule_id = re.sub(r'^SRS_REQ_([0-9]{2})',r'\1',rule)                if req_reviewed_issue == req_issue and remarks is None and reviewer is not None:                    # Rule is OK                    pass                    #print "Rule {:s} for {:s} is OK".format(rule,req_id)                elif req_reviewed_issue < req_issue or reviewer is None:                    self.dico_warnings["status","IS_21",self.current_folder,req_id,rule] = ["Rule status is NOT VERIFIED because verified issue is strictly lesser than requirement issue or or no reviewer is identified."]                elif req_reviewed_issue > req_issue:                    self.dico_errors["status","IS_22",self.current_folder,req_id,rule] = ["Rule status is NOT VERIFIED because verified issue is strictly greater than requirement issue."]                    tbl_save_errors.append(rule_id)                else:                    self.dico_warnings["status","IS_4",self.current_folder,req_id,rule] = ["Rule status is NOK because a remarks exists."]            if tbl_save_errors != []:                list_error_rules_str = ",".join(tbl_save_errors)                for error in tbl_save_errors:                    self.nb_error += 1                    nb_reqs_nok += 1        return nb_reqs_nok    def resetSheetsList(self):         self.sheets_list = self.dico_sheets["is"]             #["CONTEXT","REVIEW","DOC REVIEW","REQ REVIEW","REQ ANALYSIS","UPPER REQ ANALYSIS","REMARKS"]    def resetKeywords(self):        self.keywords = {"gen":                        {"Project Identification":1,                         "Project Release":2,                         "Reviewers":3,                         "Date":4},                    "ids":                        {"Title":1,                         "Reference":2,                         "Issue":3,                         "Author":4,                         "Verification baseline":5},                    "docs":{},                    "crs":{}}        self.found_tag = {"GENERALITIES":False,                    "IDENTIFICATION OF VERIFIED PRODUCT":False,                    "LIST OF APPLICABLE/REFERENCE DOCUMENTS":False,                    "LIST OF CR WITH IMPACT ON DOCUMENT":False}        self.fillDico("docs","EMPTY")        self.fillDico("crs","EMPTY")    def parseContext(self,wb,deepcopy_keywords=[]):        if wb:            left_cell_label = ""            self.resetKeywords()            #print "SHEET LIST",self.sheets_list            ws = wb.get_sheet_by_name(name = self.sheets_list[0]) # ws is now an IterableWorksheet            if ws is not None:                for row in ws.iter_rows('A5:C50'): # it brings a new method: iter_rows()                    self.index_row += 1                    # New line                    self.index_column = 0                    for cell in row:                        self.index_column += 1                        #print "DEBUG  ws.iter_rows:",self.index_row,self.index_column,cell.value                        #if 0==0: #cell.value is not None:                        if cell.value in self.found_tag:                            # Found Tag                            self.found_tag[cell.value] = {"row":self.index_row,"column":self.index_column}                        else:                            # Check data                            if self.found_tag["LIST OF CR WITH IMPACT ON DOCUMENT"]:                                #print "TEST",left_cell_label,cell.value,self.found_tag["LIST OF CR WITH IMPACT ON DOCUMENT"]                                self.getValue(deepcopy_keywords,                                                  key = "crs",                                                  tag = self.found_tag["LIST OF CR WITH IMPACT ON DOCUMENT"],                                                  value = cell.value,                                                  label = left_cell_label)                            elif self.found_tag["LIST OF APPLICABLE/REFERENCE DOCUMENTS"]:                                #print "DEBUG",cell.value                                self.getValue(deepcopy_keywords,                                                  key = "docs",                                                  tag = self.found_tag["LIST OF APPLICABLE/REFERENCE DOCUMENTS"],                                                  value = cell.value,                                                  label = left_cell_label)                            elif self.found_tag["IDENTIFICATION OF VERIFIED PRODUCT"]:                                self.getValue(deepcopy_keywords,                                                  key = "ids",                                                  tag = self.found_tag["IDENTIFICATION OF VERIFIED PRODUCT"],                                                  value = cell.value)                            elif self.found_tag["GENERALITIES"]:                                self.getValue(deepcopy_keywords,                                                  key = "gen",                                                  tag = self.found_tag["GENERALITIES"],                                                  value = cell.value)                        left_cell_label = cell.value