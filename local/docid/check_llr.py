#!/usr/bin/env python 2.7.3
# # -*- coding: latin-1 -*-
# -*- coding: utf-8 -*-
import os
from os.path import join
import re
from tool import Tool
import sys
sys.path.append("python-docx")
try:
    import docx
except ImportError:
    print "DoCID requires the python-docx library for Python. " \
          "See https://github.com/mikemaccana/python-docx/"
try:
    from Tkinter import *
    ##    import Tkinter              # Python 2
    import ttk
except ImportError:
    from tkinter import *
import time
#from datetime import datetime
import sqlite3 as lite
from math import floor
from os.path import join
from openpyxl import load_workbook,Workbook
from openpyxl.worksheet import range_boundaries
from openpyxl.compat import range
from openpyxl.cell import get_column_letter
from openpyxl.drawing import Image
from openpyxl.styles import Style,Font,PatternFill,Border,Side,Alignment
from openpyxl.styles.colors import RED,YELLOW
from openpyxl.styles.borders import BORDER_THIN,BORDER_MEDIUM
#from docid import __version__
from conf.check_conf import Conf
from openpyxl.charts import PieChart, BarChart, Reference, Series
import warnings
try:
    import matplotlib
    matplotlib.use('cairo')
    import matplotlib.pyplot as plt
except ImportError:
    warnings.warn("Module matplotlib.pyplot is missing")
except RuntimeError,e:
    warnings.warn("Module matplotlib.pyplot data are missing")

class checkMatrix(Tool):
    @staticmethod
    def cmpList(expected,found,cmp_two="List A",cmp_one="List B"):
        #print "EXPECTED",set(expected)
        #print "FOUND",set(found)
        #print "TEST REQ found in {:s} but not in {:s}.".format(cmp_one,cmp_two)
        nb_error = 0
        union = list(set(expected) & set(found))
        exclusion = list(set(expected) ^ set(found))
        len_union = len(union)
        len_found = len(found)
        len_exclusion = len(exclusion)
        print "Union:",len_union
        print "Exclusion:",len_exclusion
        if len_union == len_found and exclusion == []:
            match = True
        elif len_union < len_found:
            match = False
            nb_error += 1
            for req in exclusion:
                pass
                #print "Found in {:s} not in {:s}: {:s}".format(cmp_two,cmp_one,req)
        else:
            match = False
            nb_error += 1
            print "Unexpected items",exclusion
        return nb_error

    def matchBeginParagraph(self,keyword,data):
        """
        Redondant avec la meme fonction dans CheckLLR
        Detect begin of paragraph with keyword at the beginning of the line
        :param keyword: keyword to found
        :param data: line to parse
        :return: True if keyword found
        """
        m = re.search(r'^\s*{:s}\s*$'.format(keyword), data, re.IGNORECASE)
        if m:
            begin_parag = True
            print "Begin paragraph found:{:s}".format(Tool.removeNonAscii(data))
            #self.debug("Begin paragraph found:{:s}".format(Tool.removeNonAscii(data)))
        else:
            begin_parag = False
        return begin_parag

    def __init__(self,dico_specifications_swrd,log):
        self.log = log
        self.tag = {}
        self.found_tag = {}
        self.list_tag = ("bottom_up_matrix",
                    "top_bottom_matrix",
                    "derived_matrix",
                    "tbd_matrix",
                    "tbc_matrix",
                    "deletion_matrix")
        self.tbl_top_bottom_matrix = {}
        self.tbl_top_bottom_not_covered_matrix = {}
        self.tbl_bottom_up_matrix = {}
        self.tbl_bottom_up_derived_matrix = {}
        self.tbl_derived_matrix = []
        self.tbl_tbd_matrix = []
        self.tbl_tbc_matrix = []
        self.tbl_deletion_matrix = []
        for x in self.list_tag:
            #self.tag[x] = self.dico_specifications["SWRD"][x]
            if x in dico_specifications_swrd:
                self.tag[x] = dico_specifications_swrd[x]
                self.found_tag[x] = False
            else:
                self.tag[x] = ""
                self.found_tag[x] = True
        self.upper_req = False
        self.high_req = False
        self.header_matrix = True
        self.matrix_row_index = 0

    def discard(self):
        self.found_tag = {}
        self.tbl_top_bottom_matrix = {}
        self.tbl_top_bottom_not_covered_matrix = {}
        self.tbl_bottom_up_matrix = {}
        self.tbl_derived_matrix = []
        self.tbl_tbd_matrix = []
        self.tbl_tbc_matrix = []
        self.tbl_deletion_matrix = []
        for x in self.list_tag:
            self.found_tag[x] = True

    def check(self,line):
        """
        To check matrixes at the end of SwRD
        :return:
        """

        if not self.found_tag["top_bottom_matrix"]:
            self.found_tag["top_bottom_matrix"] = self.matchBeginParagraph(self.tag["top_bottom_matrix"],line)
        elif not self.found_tag["bottom_up_matrix"]:
            self.found_tag["bottom_up_matrix"] = self.matchBeginParagraph(self.tag["bottom_up_matrix"],line)
            if self.found_tag["bottom_up_matrix"]:
                # Found top-bottom matrix
                self.high_req = False
                self.header_matrix = True
                self.matrix_row_index = 0
            else:
                # Inside top-bottom matrix
                if self.header_matrix:
                    #print "HEADER",line
                    self.matrix_row_index += 1
                    if self.matrix_row_index == 1:
                        m = re.match(r'^\s*(System Level Requirements)', line, re.IGNORECASE)
                        if not m:
                            self.log("Error: Top-Bottom matrix does not match the expected one. Found \"{:s}\" instead of \"High Level Requirements\" in first header column".format(line),gui_display=True)

                    elif self.matrix_row_index == 3:
                        self.header_matrix = False
                else:
                    # SRS_31
                    #print "TOP BOTTOM MATRIX:",line
                    m = re.match(r'^\s*((ICD|SSCS|SDTS)_.*)', line)
                    if m:
                        self.upper_req = line

                    match_high_req = re.match(r'^\s*(SWRD_.*|NOT COVERED|Not Covered)', line, re.IGNORECASE)
                    if match_high_req:
                        if self.upper_req != False:
                            self.tbl_top_bottom_matrix[self.upper_req] = line
                        else:
                            print "Problem line:",line
                        reference = match_high_req.group(1)
                        if re.search(r'NOT COVERED|Not Covered',reference,re.IGNORECASE):
                            self.tbl_top_bottom_not_covered_matrix[self.upper_req] = line
                    else:
                        # Blank ?
                        # TOP BOTTOM MATRIX: ICD_CAN_0009
                        # TOP BOTTOM MATRIX: SWRD_SMS-WHCC_011
                        # TOP BOTTOM MATRIX:  
                        # TOP BOTTOM MATRIX:  
                        # TOP BOTTOM MATRIX: SWRD_SMS-WHCC_012
                        # TOP BOTTOM MATRIX:  
                        # TOP BOTTOM MATRIX:  
                        # TOP BOTTOM MATRIX: SWRD_SMS-WHCC_019
                        # TOP BOTTOM MATRIX:  
                        # TOP BOTTOM MATRIX:  
                        # TOP BOTTOM MATRIX: SWRD_SMS-WHCC_020
                        # TOP BOTTOM MATRIX:  
                        # TOP BOTTOM MATRIX:  
                        # TOP BOTTOM MATRIX: SWRD_SMS-WHCC_032
                        # TOP BOTTOM MATRIX:  
                        # TOP BOTTOM MATRIX: ICD_CAN_0010
                        # TOP BOTTOM MATRIX: SWRD_SMS-WHCC_036
                        pass

        elif not self.found_tag["derived_matrix"]:
            self.found_tag["derived_matrix"] = self.matchBeginParagraph(self.tag["derived_matrix"],line)
            if self.found_tag["derived_matrix"]:
                self.upper_req = False
            else:
                # Inside bottom-up matrix
                # SRS 32
                match_high_req = re.match(r'^\s*(SWRD_.*)', line)
                if match_high_req:
                    self.high_req  = line

                match_upper_req = re.match(r'^\s*((ICD_|SSCS_|SDTS_|DERIVED|DELETED).*)', line, re.IGNORECASE)
                if match_upper_req:
                    if self.high_req != False:
                        self.tbl_bottom_up_matrix[self.high_req] = line
                    else:
                        print "Problem line:",line
                    reference = match_upper_req.group(1)
                    if re.search(r'DERIVED|Derived',reference,re.IGNORECASE):
                        self.tbl_bottom_up_derived_matrix[self.high_req] = line

        elif not self.found_tag["tbd_matrix"]:
            # Inside derived matrix
            self.found_tag["tbd_matrix"] = self.matchBeginParagraph(self.tag["tbd_matrix"],line)
            if self.found_tag["tbd_matrix"]:
                pass
            else:
                # SRS 33
                m = re.match(r'^\s*(SWRD_.*)', line)
                if m:
                    self.tbl_derived_matrix.append(line)
                #print "DERIVED:",line
        elif not self.found_tag["tbc_matrix"]:
            # Inside TBD matrix
            self.found_tag["tbc_matrix"] = self.matchBeginParagraph(self.tag["tbc_matrix"],line)
            if self.found_tag["tbc_matrix"]:
                pass
            else:
                # SRS 34
                m = re.match(r'^\s*(SWRD_.*)', line)
                if m:
                    self.tbl_tbd_matrix.append(line)
                #print "TBD:",line
        elif not self.found_tag["deletion_matrix"]:
            # Inside TBC matrix
            self.found_tag["deletion_matrix"] = self.matchBeginParagraph(self.tag["deletion_matrix"],line)
            if self.found_tag["deletion_matrix"]:
                pass
            else:
                # SRS 35
                m = re.match(r'^\s*(SWRD_.*)', line)
                if m:
                    self.tbl_tbc_matrix.append(line)
                #print "TBC:",line
        else:
            # Inside derived matrix
            # SRS 36
            m = re.match(r'^\s*(SWRD_.*)', line)
            if m:
                high_req = line
                self.tbl_deletion_matrix.append(high_req)
            #print "DELETION:",line

    def result(self):
        try:
            for x in self.list_tag:
                assert self.found_tag[x]
        except AssertionError:
            print "Tag not found:",x
        nb_upper_req = len(self.tbl_top_bottom_matrix)
        self.log("Found {:d} upper requirements in {:s} matrix.".format(nb_upper_req,self.tag["top_bottom_matrix"]),gui_display=True)

        nb_upper_req_not_covered = len(self.tbl_top_bottom_not_covered_matrix)
        self.log("Found {:d} upper requirements not covered in {:s} matrix.".format(nb_upper_req_not_covered,self.tag["top_bottom_matrix"]),gui_display=True)

        nb_req = len(self.tbl_bottom_up_matrix)
        self.log("Found {:d} high requirements in {:s} matrix.".format(nb_req,self.tag["bottom_up_matrix"]),gui_display=True)

        nb_derived_req = len(self.tbl_derived_matrix)
        self.log("Found {:d} derived high requirements in {:s} matrix.".format(nb_derived_req,self.tag["derived_matrix"]),gui_display=True)

        nb_tbd = len(self.tbl_tbd_matrix)
        self.log("Found {:d} high requirements TBD in {:s} matrix.".format(nb_tbd,self.tag["tbd_matrix"]),gui_display=True)

        nb_tbc = len(self.tbl_tbc_matrix)
        self.log("Found {:d} high requirements TBC in {:s} matrix.".format(nb_tbc,self.tag["tbc_matrix"]),gui_display=True)

        nb_deleted = len(self.tbl_deletion_matrix)
        self.log("Found {:d} high requirements deleted in {:s} matrix.".format(nb_deleted,self.tag["deletion_matrix"]),gui_display=True)
        return (nb_upper_req,nb_upper_req_not_covered,nb_req,nb_derived_req,nb_tbd,nb_tbc,nb_deleted)

class CheckLLR(Tool,Conf):

    def openLog(self,type="specification"):
        self.log_filename = "check_{:s}_{:d}.txt".format(type,int(floor(time.time())))
        self.log_handler = open(join("result",self.log_filename), 'w')

    def log(self,text,error=False,gui_display=False):
        if self.log_handler is not None:
            self.log_handler.write(text + "\n")
        else:
            print text
        if "general_output_txt" in self.__dict__ and gui_display:
            if error:
                color = "yellow"
                self.general_output_txt.tag_configure("color", foreground=color)
                self.general_output_txt.insert(END, time.strftime("%H:%M:%S", time.localtime()) + " " + text + "\n", "color")
            else:
                self.general_output_txt.insert(END, time.strftime("%H:%M:%S", time.localtime()) + " " + text + "\n")
            self.general_output_txt.see(END)

    def closeLog(self):
        # Close opened file
        if self.log_handler is not None:
            self.log_handler.close()

    def _loadConfig(self):
        self.dico_spec = {}
        self.dico_sheets = {}

        dico_name = {"system_spec",
                     "board_spec",
                     "icd_spi_prot",
                     "icd_spi_data",
                     "icd_can_prot",
                     "icd_can_data",
                     "swrd",
                     "swdd",
                     "hsid"}
        try:
            # get filenames for upper requirements in Word format
            for name in dico_name:
                self.dico_spec[name] = self.getOptions("Check",name)
            # get filenames for upper requirements in Excel format
            for name in {"icd_spi","icd_can","is"}:
                value = self.getOptions("Sheets",name)
                tbl_sheets = value.split(",")
                self.dico_sheets[name] = tbl_sheets
            #  get template name for IS check report
            self.is_check_report_tpl_name = self.getOptions("Template","IS_CHECK")
            self.is_export_tpl_name = self.getOptions("Template","IS_EXPORT")

            print "Check LLR config reading succeeded"
        except IOError as exception:
            print "Check LLR config reading failed:", exception

    def __init__(self,
                 basename="",
                 hlr_selected=False,
                 hsid_selected=False,
                 **kwargs):
        for key in kwargs:
            self.__dict__[key] = kwargs[key]
        Tool.__init__(self)
        self._loadConfig()
        self.basename = basename
        self.depth = 0
        self.stack = []
        self.tbl_file_llr = {}
        self.tbl_file_dir = {}
        self.tbl_file_nb_llr = {}
        self.tbl_list_llr = {}
        self.tbl_file_llr_wo_del = {}
        self.list_llr_vs_file = {}
        self.nb_reqs = 0
        self.nb_derived_req = 0
        self.nb_deleted_req = 0
        self.hlr_selected = hlr_selected
        self.hsid_selected = hsid_selected
        self.con = False
        self.tbl_dico_modifs = []
        self.tbl_req_from_hsid = []
        self.current_folder = "CONTEXT"
        self.dico_errors = {}
        self.nb_error = 0
        self.dico_warnings = {}
        self.nb_warning = 0
        self.dico_debug = {}
        self.nb_debug = 0
        self.previous_attr = ""
        self.index_row = 0
        self.index_column = 0
        self.nb_cell_read = 0
        self.list_upper_req = []
        self.check_matrix = checkMatrix({},self.log)
        self.toc_parag = False
        self.begin_req_parag = False
        self.purpose_of_modif_parag = False
        self.toc_tag = ""
        self.modification_tag = ""
        self.requirement_tag = ""
        self.tbl_reqs_updated = []
        self.nb_remarks = 0
        self.nb_remarks_open = 0

    def invert(self):
        """
        Get requirement versus file
        ex:
        Input:
            {'SSCS_ESSNESS_ET2788_S-6D1': [u'SSCS_ESSNESS_0001', etc.
        Output:
            {'SSCS_ESSNESS_9020': ['SSCS_ESSNESS_ET2788_S-6D1'], 'SSCS_ESSNESS_9141': ['SSCS_ESSNESS_ET2788_S-6D1'],

        :return:
        """
        #print "BEFORE",self.tbl_file_llr
        self.list_llr_vs_file = Tool._invert_dol(self.tbl_file_llr)
        #print "AFTER",self.list_llr_vs_file

    def cmpList(self,expected,found,cmp_two="Specification document",cmp_one="Inspection Sheet"):
        #print "EXPECTED",set(expected)
        #print "FOUND",set(found)
        #print "TEST REQ found in {:s} but not in {:s}.".format(cmp_one,cmp_two)
        nb_error = 0
        union = list(set(expected) & set(found))
        exclusion = list(set(expected) ^ set(found))
        len_union = len(union)
        len_found = len(found)
        len_exclusion = len(exclusion)
        #print "Union:",len_union
        #print "Exclusion:",len_exclusion
        if len_union == len_found and exclusion == []:
            match = True
        elif len_union < len_found:
            match = False
            nb_error += 1

            for req in exclusion:
                try:
                    req_id = str(req)
                    if req in self.tbl_list_llr:
                        value = self.tbl_list_llr[str(req)]
                        status = CheckLLR.getAtribute(value,"status")
                        if status == "DELETED":
                            self.dico_errors["status","IS_18",self.current_folder,req_id,""] = ["Deleted {:s} requirement found in {:s} but not in {:s}. (SVP 4.2.5.2.2 \"SwRD requirement (except DELETED)\"".format(req_id,cmp_one,cmp_two)]
                        else:
                            self.dico_errors["status","IS_17",self.current_folder,req_id,""] = ["{:s} found in {:s} but not in {:s}.".format(req_id,cmp_one,cmp_two)]
                    else:
                        self.dico_errors["status","IS_17",self.current_folder,req_id,""] = ["{:s} found in {:s} but not in {:s}.".format(req_id,cmp_one,cmp_two)]
                    #self.log("Warning: {:s} => {:s} found in {:s} but not in {:s}.".format(self.current_folder,str(req),cmp_one,cmp_two),True)
                except UnicodeEncodeError:
                    print "DEBUG: check_is:L188",self.current_folder,req
                nb_error += 1
        else:
            match = False
            nb_error += 1
            print "Unexpected items",exclusion
        return nb_error

    def getHSID(self,dirname):
        del(self.tbl_req_from_hsid[:])
        hsid = CheckLLR(dirname,
                        hsid_selected = True)
        hsid.openLog("HSID")
        hsid.listDir(dirname,("HSID",))
        for req,value in hsid.tbl_list_llr.iteritems():
            self.debug("CONSTRAINT from HSID: {:s}".format(req))
            self.tbl_req_from_hsid.append(req)
        hsid.closeLog()

    def loadWorkbook(self,filename,**kwargs):
        """
        Load an excel workbook
        :param filename_is:
        :return:
        """
        #for key in kwargs:
        #    print "another keyword arg: %s: %s" % (key, kwargs[key])
        try:
            wb = load_workbook(filename = filename, use_iterators = True,**kwargs)
            if wb is not None:
                self.debug("Workbook {:s}.".format(filename))
        except: # InvalidFileException:
            self.log("File {:s} opening error.".format(filename),gui_display=True)
            return False
        return wb

    def extract(self,
                dirname="",
                type=("SWRD","PLDRD"),
                component="SW_ENM",
                log_handler=None):
        """
        This function call listDir to parse each files in folder and collect all requirements with their attributes.
        self.list_upper_req contains all upper requirements reference
        :param dirname: directory where to search files
        :param type: type of specification document
        :param component: came form IHM
        :return:
        """
        #print "dirname",dirname
        #print "type",type
        if log_handler is not None:
            self.log_handler = log_handler
        self.listDir(dirname,type,component)
        self.invert()
        # To get all upper requirements
        if self.hlr_selected:
            self.list_upper_req = []
            nb_upper_req = self.getUpperReqList(self.list_upper_req)
        else:
            # TODO: checkHLR and getUpperReqList do the same thinq !!!
            nb_upper_req = self.checkHLR()
            #list_hlr
            self.list_upper_req = []
            self.getUpperReqList(self.list_upper_req)
            # For LLR, get constraints
            list_constraints = []
            list_hsid = []
            self.getConstraintsList(list_constraints,list_hsid)
            nb_list_constraints = len(list_constraints)
            nb_list_hsid = len(list_hsid)

            nb_req_from_hsid = len(self.tbl_req_from_hsid)
            print "HSID link from LLR ",nb_list_hsid
            print "Requirement from HSID ",nb_req_from_hsid
            self.cmpList(list_hsid,self.tbl_req_from_hsid,cmp_one="HSID",cmp_two="LLR")

            self.log("Nb constraints found: {:d} with {:d} link toward HSID".format(nb_list_constraints,nb_list_hsid),gui_display=True)
        # Summary
        self.log("Found {:d} requirements in document body: ".format(self.nb_reqs),gui_display=True)
        self.log("Found {:d} derived requirements in document body: ".format(self.nb_derived_req),gui_display=True)
        self.log("Found {:d} deleted requirements in document body: ".format(self.nb_deleted_req),gui_display=True)
        self.log("Found {:d} upper requirements in document body".format(nb_upper_req),gui_display=True)
        nb_matrix_upper_req,nb_matrix_upper_req_not_covered,nb_matrix_req,nb_matrix_derived_req,nb_matrix_tbd,nb_matrix_tbc,nb_matrix_deleted = self.check_matrix.result()

        # Compare list of high requirements found in body versus matrix
        nb_matrix_req_not_deleted = nb_matrix_req - nb_matrix_deleted
        #print "NB REQ CMP",nb_matrix_req_not_deleted,self.nb_reqs
        if self.nb_reqs != nb_matrix_req_not_deleted:
            # Discard deleted requirements for comparison
            self.dico_debug["miscelleanous","S_10",self.current_folder,"","Bottom up matrix"] = ["Found {:d} requirements in matrix versus {:d} requirements in body.".format(nb_matrix_req_not_deleted,self.nb_reqs)]
            tbl_bottom_up_not_deleted_matrix = set(self.check_matrix.tbl_bottom_up_matrix) - set(self.check_matrix.tbl_deletion_matrix)
            checkMatrix.cmpList(self.check_matrix.tbl_bottom_up_matrix,self.tbl_list_llr,"Bottom up matrix","Document body")

        # Compare list of upper requirements found in body versus matrix
        nb_matrix_covered_upper_req = nb_matrix_upper_req - nb_matrix_upper_req_not_covered
        if nb_matrix_covered_upper_req != nb_upper_req:
            # Discard not covered upper requirements for comparison
            self.dico_debug["miscelleanous","S_11",self.current_folder,"","Top bottom matrix"] = ["Found {:d} upper requirements in matrix versus {:d} upper requirements reference in body.".format(nb_matrix_covered_upper_req,nb_upper_req)]
            tbl_top_bottom_covered_matrix = set(self.check_matrix.tbl_top_bottom_matrix) - set(self.check_matrix.tbl_top_bottom_not_covered_matrix)
            checkMatrix.cmpList(tbl_top_bottom_covered_matrix,self.list_upper_req,"Top bottom matrix","Document body")

        self.log("{:d} errors found in document.".format(len(self.dico_errors)),gui_display=True)
        len_bottom_up_derived_matrix = len(self.check_matrix.tbl_bottom_up_derived_matrix)
        print "Nb derived in bottom up matrix",len_bottom_up_derived_matrix
        for list,error in self.dico_errors.iteritems():
            rule_tag = list[1]
            self.log("ERROR: {:s}: {:s}".format(rule_tag,error[0]),gui_display=True)
        self.log("{:d} warnings found in document.".format(len(self.dico_warnings)),gui_display=True)
        for list,error in self.dico_warnings.iteritems():
            rule_tag = list[1]
            self.log("WARNING: {:s}: {:s}".format(rule_tag,error[0]),gui_display=True)

        llr_file_check_filename = "requirements_file_check_%d.csv" % floor(time.time())
        llr_attr_check_filename = "requirements_attr_check_%d.csv" % floor(time.time())
        with open(join("result",llr_file_check_filename), 'w') as of:
            of.write("{:s};{:s};{:s}\n".format("Dir","LLR file","nb reqs"))
            for file in self.tbl_file_llr:
                dir = self.tbl_file_dir[file]
                of.write("{:s};{:s};{:d}\n".format(dir,file,self.tbl_file_nb_llr[file]))
                #for reqs in llr.tbl_file_llr[file]:
                #    of.write("   " + reqs + "\n")

        with open(join("result",llr_attr_check_filename), 'w') as of:
            #of.write("List attributes per requirement\n")
            of.write("{:s};{:s};{:s};{:s};{:s};{:s};{:s};{:s};{:s};{:s};{:s};{:s}\n".format("File","Req tag","Refer","Constraint","Derived","Rationale","Additional","Issue","Status","Safety","Terminal","Allocation"))
            for req,value in self.tbl_list_llr.iteritems():
                #print "TEST with open llr_attr_check_filename:",req,value
                # File,Req,Refer_to,Constraint,Derived,Rationale,Additional
                file = self.list_llr_vs_file[str(req)][0]
                refer = self.getAtribute(value,"refer")
                constraint = self.getAtribute(value,"constraint")
                derived = self.getAtribute(value,"derived")
                rationale = self.getAtribute(value,"rationale")
                additional = self.getAtribute(value,"additional")
                issue = self.getAtribute(value,"issue")
                status = self.getAtribute(value,"status")
                safety = self.getAtribute(value,"safety")
                terminal = self.getAtribute(value,"terminal")
                allocation = self.getAtribute(value,"allocation")

                of.write("{:s};{:s};{:s};{:s};{:s};{:s};{:s};{:s};{:s};{:s};{:s};{:s}\n".format(file,
                                                        req,
                                                        refer,
                                                        constraint,
                                                        derived,
                                                        rationale,
                                                        additional,
                                                        issue,
                                                        status,
                                                        safety,
                                                        terminal,
                                                        allocation
                                                        ))
        return llr_attr_check_filename,llr_file_check_filename

    def checkHLR(self):
        """
        This function create a list with all referred to upper requirements
        self.list_hlr = ["SWRD_SMS-WHCC_218",...]
        self.list_hlr_vs_llr = [("SWRD_SMS-WHCC_218","SWDD_SMS_PDS_ENM_CSC029_CSU011_009"),...]
        :return:
        """
        self.list_hlr = []
        self.list_hlr_vs_llr = []
        nb = 0
        for low_req,value in self.tbl_list_llr.iteritems():
            #print "LLR:",low_req
            if "refer" in value:
                str_refer = value["refer"]
                refer = str_refer.split(",")
                for hlr in refer:
                    res = self.matchBegin(hlr,"SWRD")
                    if res:
                        self.list_hlr_vs_llr.append((res,low_req))
                        if res not in self.list_hlr:
                            self.list_hlr.append(res)
                            nb += 1
                    else:
                        pass
        return nb

    def getUpperReqList(self,list_hlr = [],type=".*"):
        """
        This function create a list with all referred to upper requirements
        :param list_hlr:
        :return: sorted list of all upper requirements found
        """
        nb = 0
        for low_req,value in self.tbl_list_llr.iteritems():
            #print "LLR:",low_req
            if "refer" in value:
                str_refer = value["refer"]
                refer = str_refer.split(",")
                for hlr in refer:
                    res = self.matchBegin(hlr,type)
                    if res:
                        #print "HLR:",res
                        if res not in list_hlr:
                            list_hlr.append(res)
                            nb += 1
                    else:
                        pass
                        #print "DERIVED"
                        #print value["derived"]
        list_hlr.sort()
        return nb

    @staticmethod
    def getAtribute(dico,attr):
        if attr in dico:
            value = Tool.removeNonAscii(dico[attr])
            # Remove tabulation
            value = re.sub(r"\t",r"",value)
        else:
            value = "None"
        return value

    def debug(self,text):
        if self.active_dbg:
            self.log(text)

    def matchAttributeListOfModif(self,data,attr):
        m = re.match("^" + attr + "$", data)
        if m:
            result = m.group(1)
        else:
            result = False
        return result

    def matchAttribute(self,
                       data,
                       attr,
                       error_attributes,
                       warning_attributes=[],
                       debug_attributes=[]):
        #print "Atribute selected:",attr,
        m = re.match("^\s*" + attr + "\s*(.*)", data)
        if m:
            attr_value_found = m.group(1)
            self.debug("Attributes found {:s} {:s}".format(attr,Tool.removeNonAscii(attr_value_found)))
            #print "Attributes found ",attr,attr_value_found
            # test semi colon presence
            m = re.search(';', attr_value_found)
            if m:
                value_filtered = re.sub(r";",r",",attr_value_found)
                debug_attributes.append("Unexpected semi-colon found in \"{:s}\" attribute.".format(attr))
                #print "ERROR",error
            else:
                value_filtered = attr_value_found
            # test missing missing comma in "Refer to" attribute
            if attr == "Refers to:" or attr == "Constraint by:":
                char = {r'\t':'',r' ':''}
                for before, after in char.iteritems():
                    value_filtered = re.sub(before,after,value_filtered)
                #print "TEST:",attr_value_found
                # Find double brackets
                m = re.search(r'\]\]', value_filtered)
                if m:
                    error_attributes.append("Double brackets in {:s} attribute.".format(attr))
                    value_filtered = re.sub(r"\]\]",r"]",value_filtered)
                m = re.search(r'\[\[', value_filtered)
                if m:
                    error_attributes.append("Double brackets in  {:s} attribute.".format(attr))
                    value_filtered = re.sub(r"\[\[",r"[",value_filtered)
                m = re.match(r'^\[(.*)\]', value_filtered)
                if m:
                    inside_brackets = m.group(1)
                    # Between brackets
                    # Find brackets without separator
                    m = re.match(r'(.*)\]\[(.*)', inside_brackets)
                    if m:
                        debug_attributes.append("Missing comma in \"{:s}\" attribute.".format(attr))
                        result = re.sub(r"\]\[",r"],[",value_filtered)
                    else:
                        result = value_filtered
                    #print "TEST2:",result
                else:
                    result = value_filtered
            else:
                result = value_filtered
            if result == "":
                result = "EMPTY"

        else:
            #print "UNKNOWN:",data
            result = False
        return result

    def matchBeginParagraph(self,keywords,data):
        """
        Detect begin of paragraph with keyword at the beginning of the line
        :param keyword: keyword to found
        :param data: line to parse
        :return: True if keyword found
        """
        def searchKeyword(keyword,data):
            m = re.search(r'^\s*{:s}\s*$'.format(keyword), data)
            if m:
                begin_parag = True
                self.debug("Begin paragraph found:{:s}".format(Tool.removeNonAscii(data)))
            else:
                begin_parag = False
            return begin_parag

        if Tool._is_array(keywords):
            for keyword in keywords:
                begin_parag = searchKeyword(keyword,data)
                if begin_parag:
                    break
        else:
            begin_parag = searchKeyword(keywords,data)
        return begin_parag

    def matchBeginLLR(self,data):
        #print "DATA",data
        # Regex
        # \s : Matches any whitespace character like a blank space, tab, and the like.
        m = re.match(r'^\s*\[(SWDD_.*)\]', data)
        if m:
            start_delimiter = m.group(1)
            self.debug("Start delimiter found:{:s}".format(Tool.removeNonAscii(start_delimiter)))
            result = start_delimiter
        else:
            result = False
        return result

    def matchBegin(self,data,type):
        #print "DATA",data
        # Regex
        # \s : Matches any whitespace character like a blank space, tab, and the like.
        m = re.match(r'^\s*\[({:s}.*)\]'.format(type), data)
        if m:
            start_delimiter = m.group(1)
            self.debug("Start delimiter found:{:s} beginning with {:s}".format(Tool.removeNonAscii(start_delimiter),type))
            result = start_delimiter
        else:
            result = False
        return result

    def matchBeginSSCS(self,data):
        #print "DATA",data
        # Regex
        # \s : Matches any whitespace character like a blank space, tab, and the like.
        m = re.match(r'^\s*\[(SSCS_.*)\]', data)
        if m:
            start_delimiter = m.group(1)
            self.debug("Start delimiter found:{:s}".format(Tool.removeNonAscii(start_delimiter)))
            result = start_delimiter
        else:
            result = False
        return result

    def matchBeginHLR(self,data):
        #print "DATA",data
        # Regex
        # \s : Matches any whitespace character like a blank space, tab, and the like.
        m = re.match(r'^\s*\[(SWRD_.*)\]', data)
        if m:
            start_delimiter = m.group(1)
            self.debug("Start delimiter found:{:s}".format(Tool.removeNonAscii(start_delimiter)))
            result = start_delimiter
        else:
            result = False
        return result

    def matchBeginHSID(self,data):
        #print "DATA",data
        # Regex
        # \s : Matches any whitespace character like a blank space, tab, and the like.
        m = re.match(r'^\s*\[(HSID_.*)\]', data)
        if m:
            start_delimiter = m.group(1)
            self.debug("Start delimiter found:{:s}".format(Tool.removeNonAscii(start_delimiter)))
            result = start_delimiter
        else:
            result = False
        return result

    def matchReq(self,data):
        #print "DATA",data
        # Regex
        # \s : Matches any whitespace character like a blank space, tab, and the like.
        m = re.match(r'^\s*\[(.*)\]', data)
        if m:
            start_delimiter = m.group(1)
            self.debug("Start delimiter found:{:s}".format(Tool.removeNonAscii(start_delimiter)))
            result = start_delimiter
        else:
            result = False
        return result

    def matchLLRBody(self,data):
        #m = re.match(r'^\s*(.*)', data)
        m = False
        if not m:
            self.debug("Body found:{:s}".format(Tool.removeNonAscii(data)))
            result = data
        else:
            result = False
        return result

    def matchEndLLR(self,data):
        m = re.match(r'^\s*\[(End Requirement)\]', data)
        if m:
            end_delimiter = m.group(1)
            self.debug("End delimiter found:{:s}".format(Tool.removeNonAscii(end_delimiter)))
            result = True
        else:
            result = False
        return result

    def getBody(self,tbl_body,req_id=""):
        # Check "shall" rule
        nb_shall = 0
        for line in tbl_body:
            result = re.search(r'shall',line)
            if result:
                nb_shall += 1
        if nb_shall > 1:
            self.dico_errors["miscelleanous","S_8",self.current_folder,req_id,""] = ["Found {:d} shall in requirement {:s}".format(nb_shall,req_id)]
        body_txt = "\n".join(tbl_body)
        return body_txt


    def sqlite_connect(self):
        try:
            self.con = lite.connect('swrd_enm.db3', isolation_level=None)
            #cur = self.con.cursor()
            #cur.execute("DROP TABLE IF EXISTS hlr_vs_chapter")
            return True
        except lite.Error, e:
            print "Error %s:" % e.args[0]
            return False

    def sqlite_delete(self):
        try:
            #self.con = lite.connect('swrd_enm.db3', isolation_level=None)
            cur = self.con.cursor()
            cur.execute("DROP TABLE IF EXISTS hlr_vs_chapter")
        except lite.Error, e:
            print "Error %s:" % e.args[0]
            sys.exit(1)

    def sqlite_close(self):
        if self.con:
            self.con.close()

    def sqlite_create(self):
        try:
            #con = lite.connect('swrd_enm.db3')
            cur = self.con.cursor()
            cur.executescript("""
                                BEGIN TRANSACTION;
                                DROP TABLE IF EXISTS hlr_vs_chapter;
                                CREATE TABLE hlr_vs_chapter (id INTEGER PRIMARY KEY, req_id TEXT, chapter TEXT);
                                COMMIT;
                """)
            self.con.commit()
            print 'New SQLite database created.'
            return True
        except lite.Error, e:
            print "Error %s:" % e.args[0]
            return False
        #finally:
        #    if con:
        #        con.close()

    def progress_handler(self):
        print self.counter
        self.counter += 1
        time.sleep(0.1)

    def sqlite_insert_many(self,tbl_req_vs_chapter):
        with self.con:
            counter = 1
            cur = self.con.cursor()
            #self.con.set_progress_handler(self.progress_handler, 1)
            #print "tbl_req_vs_chapter",tbl_req_vs_chapter
            #cur.execute("INSERT INTO last_query(database,reference,revision,project,item,release,baseline,input_date) VALUES(?,?,?,?,?,?,?,?)",(self.database,self.reference,self.revision,project,item,release,baseline,now))
            for chapter,req_id in tbl_req_vs_chapter:
                print "INSERT:",counter,req_id
                counter += 1
                cur.execute("INSERT INTO hlr_vs_chapter(chapter,req_id) VALUES(?,?)",(chapter,req_id))
            #cur.executemany("INSERT INTO hlr_vs_chapter(chapter,req_id) VALUES(?,?)", tbl_req_vs_chapter)
            #print cur.rowcount
            self.con.commit()

    def sqlite_insert(self,req_id,chapter):
        with self.con:
        #con = lite.connect('swrd_enm.db3', isolation_level=None)
            cur = self.con.cursor()

        #cur.execute("SELECT hlr_vs_chapter.id FROM hlr_vs_chapter WHERE req_id LIKE '" + req_id + "' LIMIT 1")
        #data = cur.fetchone()
        #if data != None:
        #    id = data[0]
        #    cur.execute("UPDATE hlr_vs_chapter SET req_id=?,chapter=? WHERE id= ?",(req_id,chapter,id))
        #else:
            cur.execute("INSERT INTO hlr_vs_chapter(req_id,chapter) VALUES(?,?)",(req_id,chapter))

    def sqlite_get_all(self):
        with self.con:
            cur = self.con.cursor()
            cur.execute("SELECT id,req_id,chapter FROM hlr_vs_chapter")
            data = cur.fetchall()
        return data

    def sqlite_get(self,req_id):
        with self.con:
            cur = self.con.cursor()
            try:
                cur.execute("SELECT id,req_id,chapter FROM hlr_vs_chapter WHERE req_id LIKE '" + req_id + "' LIMIT 1")
                data = cur.fetchone()
                if data is not None:
                    #print "DATA:",data
                    id = data[0]
                    req_id = data[1]
                    chapter = data[2]
                else:
                    chapter = ""
            except OperationalError,e:
                print e
                chapter = ""
        return chapter

    @staticmethod
    def getChapterReq(filename):
        """
        Get list of requirement per chapter
        Input comes from Word document index with Title 3 and Req Id styles only
        :param filename:
        :return:
        """
        tbl = []
        tbl_list_req_id = []
        chapter = "None"
        with open(filename, 'r') as of:
            for line in of:
                m = re.match(r'^[0-9].[0-9].[0-9]\t(.*)\t[0-9]*', line)
                if m:
                    chapter = m.group(1)
                    if chapter != None:
                        tbl.append(chapter)
                else:
                    req_id = CheckLLR.matchBeginHLR(line)
                    tbl_list_req_id.append((chapter,req_id))

        #for req_id,chapter in tbl_list_req_id.items():
        #for chapter,req_id in tbl_list_req_id:
        #    print "HLR:",req_id,chapter
        nb_req = len(tbl_list_req_id)
        print "Found {:d} requirements".format(nb_req)
        db_hlr = CheckLLR()
        res = db_hlr.sqlite_connect()
        if res:
            print "TEST_Z"
            res = db_hlr.sqlite_create()
            if res:
                #db_hlr.sqlite_insert(req_id,chapter)
                print "TEST_A"
                db_hlr.sqlite_insert_many(tbl_list_req_id)
            print "TEST_B"
            db_hlr.sqlite_close()
            #txt = f.read()
            #llr_xmltree = docx.opendocx(filename)
            #txt = docx.getdocumenttext(llr_xmltree)
            #return txt

    def getCatItemAllocation(self,alloc):
        m = re.search(r'SW|Software',alloc)
        if m:
            type_item = "SW"
        else:
            m = re.search(r'PLD',alloc)
            if m:
                type_item = "PLD"
            else:
                m = re.search(r'HW|Hardware',alloc)
                if m:
                    type_item = "HW"
                else:
                    type_item = "None"
        return type_item

    def getAllocation(self):
        """
        This function sort requirements by allocation type
        Input
            tbl_list_llr
        Output
            dico_alloc_vs_req
        ex:
        {"Hardware" : [u'SSCS_ESSNESS_5501', u'SSCS_ESSNESS_5408', ...
        "Software FUNC" : [u'SSCS_ESSNESS_9020', u'SSCS_ESSNESS_7874', ...
        etc.
        :return:
        """
        dico_type_allocation = {}
        dico_alloc = {}

        for req,value in self.tbl_list_llr.iteritems():
            # Discard deleted requirements
            status = self.getAtribute(value,"status")
            if "DEL" not in status:
                tbl_alloc = []
                result = self.getAtribute(value,"allocation")
                if result:
                    #print "getAllocation:",result
                    allocations = result.split(",")
                    for allocation in allocations:
                        sub_allocations = allocation.split("/")
                        for sub_allocation in sub_allocations:
                            component = self.getComponentAllocation(sub_allocation)
                            tbl_alloc.append(component)
                            #print "COMPONENT:",component
                            if component not in dico_type_allocation:
                                dico_type_allocation[component] = 1
                            else:
                                dico_type_allocation[component] += 1
                    dico_alloc[str(req)] = tbl_alloc
                    #print "req,tbl_alloc",req,tbl_alloc
        self.dico_alloc_vs_req = Tool._invert_dol(dico_alloc)
        for allocation_type,nb in dico_type_allocation.iteritems():
            if allocation_type not in ("","None"):
                category = self.getCatItemAllocation(allocation_type)
                self.log("{:d} requirements are allocated to the item {:s} (category {:s}).".format(nb,allocation_type,category))
            else:
                self.log("{:d} requirements are not allocated to any items.".format(nb,allocation_type))
        #Computes combinatoire

    def getConstraintsList(self,list_hlr,list_hsid):
        for low_req,value in self.tbl_list_llr.iteritems():
            if "constraint" in value:
                str_refer = value["constraint"]
                refer = str_refer.split(",")
                for hlr in refer:
                    res = self.matchReq(hlr)
                    if res:
                        m = re.match(r'^HSID_\w',res)
                        if m:
                            # Found HSID
                            if res not in list_hsid:
                                list_hsid.append(res)
                        if res not in list_hlr:
                            list_hlr.append(res)
                    else:
                        pass
                        #print "DERIVED"
                        #print value["derived"]
        list_hlr.sort()
        list_hsid.sort()

    @staticmethod
    def getVersion(issue):
        version = re.sub(r"(.*)\.(.*)", r"\1", str(issue))
        return version

    def FilterReq(self,attrib={},tbl=[]):
        if attrib != {}:
            keys = attrib.keys()
            print "keys",keys
            if len(keys) == 1:
                attribute = keys[0]
                expected_version = CheckLLR.getVersion(attrib[attribute])
                for req in self.tbl_list_llr:
                    value = self.tbl_list_llr[req]
                    req_issue = CheckLLR.getAtribute(value,attribute)
                    req_version = CheckLLR.getVersion(req_issue)
                    if req_version == expected_version:
                        tbl.append(req)
            else:
                # Only one key please
                return
        else:
            return
        return len(tbl)

    def parseListOfModif(self,
                         line):
        # We are into the list of modifications
        #print "LINE:",line
        for key,attr in self.tbl_list_of_modif:
            result = self.matchAttributeListOfModif(line,attr)
            #print "Conditions:",issue_found,key,result,test_result
            if not self.issue_found and key == "issue" and result:
                #print "Found issue",result
                if self.dico_modifs != {}:
                    modifs_str = "\n".join(self.tbl_modifs)
                    self.dico_modifs["modif"] = modifs_str
                    self.tbl_dico_modifs.append(self.dico_modifs)
                    #print "Info_Modifs:",dico_modifs
                    #print "Modifs:",tbl_modifs
                self.issue_found = True
                #print "issue_found",result
                self.author_found = False
                #print "Attribute:",key,result
                self.dico_modifs = {key:result}
                #print "Delete tbl_modifs"
                del(self.tbl_modifs[:])
                break
            elif self.issue_found and key == "date" and result:
                #print "Found date",result
                self.date_found = True
                #print "Attribute:",key,result
                self.dico_modifs[key] = result
                break
            elif self.date_found and key == "author" and result:
                #print "Found author",result
                self.author_found = True
                self.issue_found = False
                self.date_found = False
                #print "Attribute:",key,result
                self.dico_modifs[key] = result
                break
            elif self.date_found and not self.author_found and key == "modif":
                #print "Modif:",line
                #print "Found modif",result
                self.tbl_modifs.append(result)
                break
            else:
                pass
    @staticmethod
    def putLogo(ws,image="small_logo_zodiac.jpeg"):
        try:
            img = Image("img/{:s}".format(image))
            img.drawing.top = 1
            img.drawing.left = 20
            ws.add_image(img)
        except ImportError:
            pass

    @staticmethod
    def set_border(ws,
                   cell_range,
                   font = Font(name='Arial',size=12,bold=True),
                   border_style=BORDER_MEDIUM,
                   alignment_horizontal="center"):
        #font = Font(name='Arial',size=12,bold=True)
        style_border_left = Style(border=Border(left=Side(border_style=border_style),
                                                top=Side(border_style=border_style),
                                                bottom=Side(border_style=border_style)),
                                  alignment=Alignment(horizontal=alignment_horizontal,vertical='center',wrap_text=True),
                                  font=font)
        style_border_right = Style(border=Border(right=Side(border_style=border_style),
                                                top=Side(border_style=border_style),
                                                bottom=Side(border_style=border_style)),
                                  alignment=Alignment(horizontal=alignment_horizontal,vertical='center',wrap_text=True),
                                  font=font)
        style_border_middle = Style(border=Border(top=Side(border_style=border_style),
                                                bottom=Side(border_style=border_style)),
                                  alignment=Alignment(horizontal=alignment_horizontal,vertical='center',wrap_text=True),
                                font=font)
        #row = ws.iter_rows(cell_range)
        min_col, min_row, max_col, max_row = range_boundaries(cell_range.upper())
        #print "TEST:",min_col, min_row, max_col, max_row
        for index_row, rows in enumerate(ws.iter_rows(cell_range)):
        #for row in rows:
            index_column = 0
            for row in rows:
                #print "ROW:",index_row,index_column,row
                if index_column == 0:
                    row.style = style_border_left
                elif index_column == max_col - min_col:
                    row.style = style_border_right
                else:
                    row.style = style_border_middle
                index_column +=1
    @staticmethod
    def setCell(ws,line,row,col_idx,style_border):
        column = get_column_letter(col_idx)
        current_cell = ws.cell('%s%s'%(column, row))
        current_cell.value = '%s' % (line[col_idx - 1])
        current_cell.style = style_border

    @staticmethod
    def setHyperlink(ws,row,col_idx,hyperlink):
        column = get_column_letter(col_idx)
        current_cell = ws.cell('%s%s'%(column, row))
        #current_cell.value = '%s' % (line[col_idx - 1])
        current_cell.hyperlink = hyperlink

    def export(self,
               doc_upper="",
               doc_inspected="",
               filename_is=""):
        """
        Create report for IS check.
        Use openpyxl package
        NOTE: Should be in CheckIS instead CheckLLR
        :param doc_inspected:
        :param filename_is:
        :return:
        """
        wb = load_workbook(filename = join('template',self.is_check_report_tpl_name))
        ws = wb.get_sheet_by_name(name = 'IS Check Report')
        self.putLogo(ws)
        style_border = Style(border=Border(
            left=Side(border_style=BORDER_THIN),
            right=Side(border_style=BORDER_THIN),
            top=Side(border_style=BORDER_THIN),
            bottom=Side(border_style=BORDER_THIN)),
                             alignment=Alignment(wrap_text=True,shrink_to_fit=True))
        # Inspection sheet
        ws.cell('F2').value = filename_is
        # Upper document
        doc_upper_str = "\n".join(doc_upper)
        ws.cell('F3').value = doc_upper_str
        #ws.cell('F3').style = style_border
        # Document inspected
        ws.cell('F4').value = "{:s} issue {:s}".format(str(doc_inspected[0]),str(doc_inspected[1]))
        # Errors
        ws.cell('F5').value = len(self.dico_errors)
        # Generation date and doCID version
        #print "DATETIME",datetime.now()
        generation_time = time.strftime("%A %d %B %Y %H:%M:%S")
        version_docid = "3.3.0"
        ws.cell('B6').value = "Generated on {:s} with doCID v{:s}".format(generation_time,version_docid)
        # Warnings
        ws.cell('F6').value = len(self.dico_warnings)
        row = 9
        list_req_review = []
        list_req_analysis = []
        list_upper_req_analysis = []

        # IS Check report with errors
        for list,error in self.dico_errors.iteritems():
            type = "ERROR"
            rule_tag = list[1]
            localisation = list[2]
            requirement = list[3]
            rule = list[4]
            localisation = list[2]
            requirement = list[3]
            if localisation == "REQ REVIEW":
                list_req_review.append(requirement)
            if localisation == "REQ ANALYSIS":
                list_req_analysis.append(requirement)
            if localisation == "UPPER REQ ANALYSIS":
                list_upper_req_analysis.append(requirement)
            line = []
            # Create list from dictionary
            line.append(type)
            line.append(rule_tag)
            line.append(localisation)
            line.append(requirement)
            line.append(rule)
            line.append(error[0])

            for col_idx in range(1,7):
                self.setCell(ws,line,row,col_idx,style_border)
            row += 1
        # IS Check report with warnings
        for list,error in self.dico_warnings.iteritems():
            type = "WARNING"
            rule_tag = list[1]
            localisation = list[2]
            requirement = list[3]
            rule = list[4]
            line = []
            # Create list from dictionary
            line.append(type)
            line.append(rule_tag)
            line.append(localisation)
            line.append(requirement)
            line.append(rule)
            line.append(error[0])

            for col_idx in range(1,7):
                self.setCell(ws,line,row,col_idx,style_border)
            row += 1
        # IS Check report with debug items
        for list,error in self.dico_debug.iteritems():
            type = "DEBUG"
            rule_tag = list[1]
            localisation = list[2]
            requirement = list[3]
            rule = list[4]
            line = []
            # Create list from dictionary
            line.append(type)
            line.append(rule_tag)
            line.append(localisation)
            line.append(requirement)
            line.append(rule)
            line.append(error[0])

            for col_idx in range(1,7):
                self.setCell(ws,line,row,col_idx,style_border)
            row += 1
        # Autofilter
        ws.auto_filter.ref = "A8:F8"
        # Summary with list of requirements updated, added or deleted
        ws = wb.get_sheet_by_name(name = 'Summary')
        # Compute Change rate
        total_nb_req_in_spec = 0
        for name,nb_reqs_in_spec in self.tbl_file_llr_wo_del.iteritems():
            #print "nb_reqs_in_spec",nb_reqs_in_spec
            total_nb_req_in_spec += len(nb_reqs_in_spec)
        nb_req_updated = len(self.tbl_reqs_updated)
        if total_nb_req_in_spec > 0:
            change_rate = (nb_req_updated * 100)/total_nb_req_in_spec
        else:
            change_rate = 100
        ws.cell('F3').value = "{:d}%".format(change_rate)
        ws.cell('F4').value = self.is_release
        ws.cell('F6').value = "{:d}".format(self.nb_remarks)
        ws.cell('F7').value = "{:d}".format(self.nb_remarks_open)
        print "nb_remarks",self.nb_remarks
        print "nb_remarks_open",self.nb_remarks_open
        self.putLogo(ws)
        row = 10
        del(line[:])
        style_nok = Style(font=Font(color=RED),
                          fill=PatternFill(patternType='solid',start_color=YELLOW),
                          border=Border(
            left=Side(border_style=BORDER_THIN),
            right=Side(border_style=BORDER_THIN),
            top=Side(border_style=BORDER_THIN),
            bottom=Side(border_style=BORDER_THIN)))
        nb_req_ko = 0
        for req in self.tbl_reqs_updated:
            #print "REQ",req
            if req in self.tbl_list_llr:
                line = []
                value = self.tbl_list_llr[str(req)]
                file = self.list_llr_vs_file[str(req)][0]
                line.append(file)
                line.append(req)
                issue = CheckLLR.getAtribute(value,"issue")
                derived = CheckLLR.getAtribute(value,"derived")
                status = CheckLLR.getAtribute(value,"status")
                line.append(issue)
                line.append(derived)
                line.append(status)
                if req in list_req_review:
                    req_review_status = "NOK"
                else:
                    req_review_status = "OK"
                line.append(req_review_status)
                if req in list_req_analysis:
                    req_analysis_status = "NOK"
                else:
                    req_analysis_status = "OK"
                line.append(req_analysis_status)
                # Marche pas upper req !!
                refer = CheckLLR.getAtribute(value,"refer")
                upper_req_analysis_status = "OK"
                if status == "TBC":
                    upper_req_analysis_status = "NOK"
                #print "list_upper_req_analysis",list_upper_req_analysis
                for upper_req in list_upper_req_analysis:
                    #print "refer:",refer
                    #print "upper_req:",upper_req
                    if upper_req != "" and upper_req in refer:
                        upper_req_analysis_status = "NOK"
                        break
                line.append(upper_req_analysis_status)
                for col_idx in range(1,9):
                    self.setCell(ws,line,row,col_idx,style_border)
                    #column = get_column_letter(col_idx)
                    #ws.cell('%s%s'%(column, row)).value = '%s' % (line[col_idx - 1])
                if req_review_status == "NOK":
                    ws.cell('F%s'%(row)).style = style_nok
                if req_analysis_status == "NOK":
                    ws.cell('G%s'%(row)).style = style_nok
                if upper_req_analysis_status == "NOK":
                    ws.cell('H%s'%(row)).style = style_nok
                if req_review_status == "NOK" or req_analysis_status == "NOK" or upper_req_analysis_status == "NOK":
                    nb_req_ko += 1
                row += 1
        ws.cell('F5').value = nb_req_ko
        # Autofilter
        ws.auto_filter.ref = "A9:F9"
        # Charts worksheet
        ws_charts = wb.create_sheet(title = 'Charts')
        self.putLogo(ws_charts)
        #values = Reference(ws, (6, 6))
        #remarks_total = Series(values, title="Total remarks")
        nb_remark_closed = self.nb_remarks - self.nb_remarks_open
        pie_values = [nb_remark_closed,self.nb_remarks_open]
        if self.nb_remarks > 0:
            percent_open = (self.nb_remarks_open * 100) / self.nb_remarks
            percent_closed = (nb_remark_closed * 100) / self.nb_remarks
        else:
            percent_open = 0
            percent_closed = 0
        labels = ['{:d}% remarks closed'.format(percent_closed), '{:d}% remarks open'.format(percent_open)]
        try:
            #plt.style.use(['dark_background', 'presentation'])
            plt.pie(pie_values,
                    explode = [0.2,0.05],
                    labels = labels,
                    shadow=True,
                    labeldistance=0.5,
                    pctdistance=0.3,
                    colors=["green","red"])
            plt.savefig('remarks_pie.png')
            #values = Reference(ws, (6, 6),(6, 7))
            #remarks_open = Series(values, title="Remarks open")
            #chart = PieChart()
            #chart.append(remarks_total)
            img = Image('remarks_pie.png')
            img.drawing.top = 150
            img.drawing.left = 150
            ws_charts.add_image(img)
            #chart.append(remarks_open)
            #ws_charts.add_chart(chart)
        except:
            warnings.warn("No charts because Matplotlib module is missing")
            #print "No charts because Matplotlib module is missing"
        # save the file
        filename = "IS_Check_Report_%d.xlsx" % floor(time.time())
        wb.save(join("result",filename))
        return filename

    def logErrors(self):
        for list,error in self.dico_errors.iteritems():
            type = list[0]
            rule_tag = list[1]
            localisation = list[2]
            requirement = list[3]
            rule = list[4]
            try:
                text = "ERROR: {:s};{:s};{:s};{:s};{:s};{:s}".format(type,rule_tag,error,localisation,requirement,rule)
            except ValueError,e:
                print "{:s}",e
                print "DEBUG:",type,error,localisation,requirement
                text = "ERROR:"
            self.log(text)

    def logWarnings(self):
        for list,error in self.dico_warnings.iteritems():
            type = list[0]
            rule_tag = list[1]
            localisation = list[2]
            requirement = list[3]
            rule = list[4]
            try:
                text = "WARNING: {:s};{:s};{:s};{:s};{:s};{:s}".format(type,rule_tag,error,localisation,requirement,rule)
            except ValueError,e:
                print "{:s}",e
                print "DEBUG:",type,error,localisation,requirement
                text = "ERROR:"
            self.log(text)

    def matchBeginReq(self,line,type="SWRD"):
        #print "LINE:",line,type
        if type == "SSCS":
            unexpected_start_delimiter = self.matchBeginSSCS(line)
        elif type == "ICD_SPI":
            unexpected_start_delimiter = self.matchBegin(line,type)
        elif type =="HISD" or self.hsid_selected:
            #print "LINE:",self.hsid_selected
            unexpected_start_delimiter = self.matchBeginHSID(line)
        elif  type =="SWRD" or self.hlr_selected:
            unexpected_start_delimiter = self.matchBeginHLR(line)
        elif  type =="SWDD" or not self.hlr_selected:
            unexpected_start_delimiter = self.matchBeginLLR(line)
        else:
            unexpected_start_delimiter = False
        return unexpected_start_delimiter

    def getDerived(self,
                   type,
                   refer,
                   derived,
                   found_dir,
                   start_delimiter):
        """

        :param type:
        :param refer:
        :param derived:
        :param found_dir:
        :param start_delimiter:
        :return:
        """
        def isDerived(found,expected):
            found = found.upper()
            expected = expected.upper()
            #print "DERIVED",found,expected
            if found == expected:
                result = True
            else:
                result = False
            return result

        def testPartiallyDerived(refer):
            if refer in ("N/A","EMPTY"):
                result = False
            else:
                result = True
            return result

        # Test derived requirements
        result = False
        #print "DERIVED TYPE",type
        if type in self.dico_specifications:
            expected_derived_list = self.dico_specifications[type]["derived"]
            if Tool._is_array(expected_derived_list):
                for expected_derived in expected_derived_list:
                    result = isDerived(derived,expected_derived)
                    if result:
                        break
            else:
                result = isDerived(derived,expected_derived_list)
            if result:
                partially_derived = testPartiallyDerived(refer)
                if partially_derived:
                    self.dico_errors["derived","S_2",found_dir,start_delimiter,""] = ["Derived requirement with traceability."]
                    self.nb_error += 1
        return result

    def getType(self,filename,tbl_type):
        """
        Define type of the document according to keyword in filename
        :return:
        """
        filename = filename.upper()
        if "S[W|w]DD" in tbl_type and len(tbl_type) == 1:
            # SWDD
            type_found = tbl_type[0]
        else:
            type_found = "\w*"

            for type in tbl_type:
                if type in filename:
                    return type.upper()
                else:
                    keywords = type.split("_")
                    nb_keywords = len(keywords)
                    #print "nb_keywords",nb_keywords
                    #print "KEYWORDS",keywords
                    counter_keywords = 0
                    for keyword in keywords:
                        #print "KEYWORD",keyword
                        if keyword in filename:
                            counter_keywords += 1
                            #print "counter_keywords",counter_keywords
                    if counter_keywords == nb_keywords:
                        type_found = type.upper()
        return type_found

    def parseExcel(self,wb,range='A1:F50',sheet_name="Feuil1",review_tbl = []):
        """
        Update_ReqStatus
        REQ ANALYSIS (SVP §4.2.5.2.2 SwRD Analysis)
            Si la version de l'exigence dans la colonne "Requirement Issue"
            est inférieure à la version revue dans la colonne "Reviewed Req. Issue"
            et que la colonne "Remark" est vide
            alors la fonction renvoie "OK" sinon elle renvoie "NOK" dans le cas où des remarques existent.

            Si la version revue dans la colonne "Reviewed Req. Issue"
            est inférieure à la version de l'exigence dans la colonne "Requirement Issue" ou que la colonne "Reviewers" est vide
            alors la fonction renvoie "NOT VERIFIED"
        REQ REVIEW (SVP §4.2.4.8 SwRD Review)
            Même principe que pour REQ ANALYSIS sauf que la fonction boucle sur toutes les règles.
            Si une des règles est "NOT VERIFIED" alors la fonction renvoie:
                - PARTIALLY VERIFIED (NOK): Une des règles n'est pas vérifiée et une remarque au moins existe
                - PARTIALLY VERIFIED (OK): Une des règles n'est pas vérifiée et aucune remarque n'est enregistrée

        GetReviewerNames
            Cette fonction, utilisée dans l'onglet REQ REVIEW, permet de concaténer tous les noms des relecteurs par règle
            à condition que l'auteur est vérifié la règle pour la version courante de l'exigence.

        Concatener_ReqRemarks
            Cette fonction, utilisée dans l'onglet REQ REVIEW, permet de concaténer toutes les remarques par règle
            quelque soit la version de l'exigence revue

        :param wb:
        :param range:
        :param sheet_no:
        :return:
        """
        #
        # Column "Status" in REVIEW, DOC_REVIEW and REQ REVIEW sheet is filled automatically with the formula:
        # Update_ReqStatus(D2:F2,F2,Issue)
        #
        # Column "Remarks" in REQ REVIEW sheet is filled automatically with the formula:
        # Concatener_ReqRemarks(F679:BS679)
        #
        # Column "Reviewers" in REQ REVIEW sheet is filled automatically with the formula:
        # GetReviewerNames(F679:BS679,B679)
        #
        # Column "REQ_ANALYSIS" in REQ ANALYSIS sheet is filled automatically with the formula:
        # Update_ReqStatus(D3:F3,F3,B3)
        #
        #length_sheets_list = len(self.sheets_list)
        #if sheet_no < length_sheets_list:
        ws = wb.get_sheet_by_name(name = sheet_name) # ws is now an IterableWorksheet
        if ws is not None:
            for row in ws.iter_rows(range): # it brings a new method: iter_rows()
                self.index_row += 1
                # New line
                row_tbl = []
                self.index_column = 0
                for cell in row:
                    self.index_column += 1
                    row_tbl.append(cell.value)
                    self.nb_cell_read += 1
                    #if self.nb_cell_read > 65530:
                    #    print self.nb_cell_read
                review_tbl.append(row_tbl)
        else:
            print "Sheet {:s} not found in workbook.".format(sheet_name)

    def getListUpper(self,exclude_list=("SWDD","SWRD","PLDRD")):
        # TODO: Rendre parametrable
        upper_type = []
        for spec in self.dico_specifications:
            if spec not in exclude_list:
                upper_type.append(spec)
        return upper_type

    def result(self,nb_reqs_in_file,filename,name):
        text = "Found {:d} requirements in {:s}:{:s}".format(nb_reqs_in_file,self.tbl_file_dir[name],filename)
        self.log(text,gui_display=True)
        if not self.purpose_of_modif_parag:
            self.log("Warning, beginning of purpose of modifications section \"{:s}\" has not been found. ".format(self.modification_tag),gui_display=True)
        if not self.toc_parag:
            self.log("Warning, beginning of table of content section \"{:s}\" has not been found. ".format(self.toc_tag),gui_display=True)
        if not self.begin_req_parag:
            self.log("Warning, beginning of requirements section \"{:s}\" has not been found. ".format(self.requirement_tag),gui_display=True)

    def parseAttr(self,
                  line,
                  list_attr_to_be_found,
                  tbl_llr,
                  begin_attr,
                  found_dir,
                  start_delimiter,
                  end_req=False):
        error_attributes = []
        warning_attributes = []
        debug_attributes = []
        for key in list_attr_to_be_found:
            attrs = self.dico_attributes[key]
            if Tool._is_array(attrs):
                for attr in attrs:
                    attr_value_found = self.matchAttribute(line,
                                                           attr,
                                                           error_attributes,
                                                           warning_attributes)
                    if attr_value_found:
                        break
            else:
                attr_value_found = self.matchAttribute(line,
                                                       attrs,
                                                       error_attributes,
                                                       warning_attributes,
                                                       debug_attributes)
            #print "error_attributes",error_attributes
            if attr_value_found:
                # Found attributes, remove it to prevent search it again
                list_attr_to_be_found.remove(key)
                self.previous_attr = key
                begin_attr = True
                tbl_llr[key]=attr_value_found
                if error_attributes:
                    self.dico_errors["attributes","S_1",found_dir,start_delimiter,""] = error_attributes
                elif warning_attributes:
                    self.dico_warnings["attributes","S_6",found_dir,start_delimiter,""] = warning_attributes
                elif debug_attributes:
                    self.dico_debug["attributes","S_6",found_dir,start_delimiter,""] = debug_attributes
                break
            else:
                # May be multi line for attributes ?
                pass

        if begin_attr:
            if not end_req and not attr_value_found:
                # Still in attributes part but no attributes found in the list
                if self.previous_attr in self.dico_attributes:
                    # multi-lines for attributes
                    key = self.previous_attr
                    info = tbl_llr[key]
                    info += "," + line
                    tbl_llr[key] = info
                    #print "SUITE ATTR:",key,line
        return begin_attr

    def listDir(self,
                dirname="",
                tbl_type=("SWRD","PLDRD"),
                component="SW_ENM"):
        """
        Recursive function to find files in directories.
        Treatment for Excel and Word file is different
        :param dirname:
        :param type:
        :return:
        """
        self.depth += 1
        color = "white"
        if "general_output_txt" in self.__dict__:
            self.general_output_txt.tag_configure("color", foreground=color)
        #print "depth",self.depth
        new_concat_dirname = self.basename
        for dir in self.stack:
            new_concat_dirname = join(new_concat_dirname,dir)
            if sys.platform.startswith('win32'):
                new_concat_dirname = "{:s}\\".format(new_concat_dirname)
            else:
                new_concat_dirname = "{:s}/".format(new_concat_dirname)
        #print "new_concat_dirname",new_concat_dirname
        concat_dirname = join(self.basename,dirname)
        if sys.platform.startswith('win32'):
            concat_dirname = "{:s}\\".format(concat_dirname)
        else:
            concat_dirname = "{:s}/".format(concat_dirname)
        #print "concat_dirname",concat_dirname
        #try:
        #    WindowsError
        #except NameError,e:
        #    print e
        #    WindowsError = None
        try:
            print "new_concat_dirname",new_concat_dirname
            if new_concat_dirname != "":
                list_dir = os.listdir(new_concat_dirname)
            else:
                list_dir = []
        except WindowsError,e:
            # NameError: global name 'WindowsError' is not defined, for Mac
            self.log("{:s}".format(e))
            list_dir = []
        except OSError,e:
            self.log("{:s}".format(e))
            list_dir = []
        del(self.tbl_dico_modifs[:])
        for found_dir in list_dir:
            path_dir = os.path.join(new_concat_dirname, found_dir)
            isdir = os.path.isdir(path_dir)
            if isdir:
                self.stack.append(found_dir)
                self.listDir(found_dir,tbl_type)
                self.stack.pop()
            else:
                void = re.sub(r"(~\$)(.*)\.(.*)",r"\1",found_dir)
                name = re.sub(r"(.*)\.(.*)",r"\1",found_dir)
                extension = re.sub(r"(.*)\.(.*)",r"\2",found_dir)
                type = self.getType(name,tbl_type)
                start_delimiter = False
                tbl_req_tag = []
                tbl_req_tag_wo_del = []
                tbl_llr = {}
                nb_reqs_in_file = 0
                if extension in ("docx","docm") and void != "~$":
                    self.log("Parse {:s} type {:s}".format(found_dir,type),gui_display=True)
                    filename = join(new_concat_dirname,found_dir)
                    llr_xmltree = docx.opendocx(filename)
                    txt = docx.getdocumenttext(llr_xmltree)
                    if 1==0:
                        #print "TXT:",txt
                        for line in txt:
                           print "LINE:",line
                    #exit()
                    tbl_body = []

                    unexpected_start_delimiter = False
                    begin_attr = False

                    self.author_found = False
                    self.issue_found = False
                    self.date_found = False
                    self.tbl_modifs = []
                    self.dico_modifs = {}

                    self.purpose_of_modif_parag = False
                    self.toc_parag = False
                    self.begin_req_parag = False
                    if type in self.dico_specifications:
                        self.check_matrix = checkMatrix(self.dico_specifications[type],self.log)
                        modification_tag  = self.dico_specifications[type]["modifications"]
                        toc_tag  = self.dico_specifications[type]["toc"]
                        requirement_tag = self.dico_specifications[type]["requirement"]
                        if "tag_req" in self.dico_specifications[type]:
                            tag_req = self.dico_specifications[type]["tag_req"]
                        else:
                            tag_req = type + "_"
                    else:
                        requirement_tag = ""
                        modification_tag = ""
                        toc_tag = ""
                        self.check_matrix = checkMatrix({},self.log)
                        self.purpose_of_modif_parag = True
                        self.toc_parag = True
                        self.begin_req_parag = True
                        self.check_matrix.discard()
                        tag_req = type + "_"
                    self.toc_tag = toc_tag
                    self.modification_tag = modification_tag
                    self.requirement_tag = requirement_tag

                    # List of attributes in Conf class which be emptied
                    list_attr_to_be_found = []
                    for key,attr in self.dico_attributes.items():
                        list_attr_to_be_found.append(key)

                    # Begin loop text line by line
                    for line in txt:
                        if not self.purpose_of_modif_parag:
                            self.purpose_of_modif_parag = self.matchBeginParagraph(modification_tag,line)
                        else:
                            if not self.toc_parag:
                                #self.debug("LINE: {:s}".format(Tool.removeNonAscii(line)))
                                # We are into the list of modifications
                                self.parseListOfModif(line)
                                self.toc_parag = self.matchBeginParagraph(toc_tag,line)
                                if self.toc_parag:
                                    # Compile list of modifications
                                    modifs_str = "\n".join(self.tbl_modifs)
                                    self.dico_modifs["modif"] = modifs_str
                                    self.tbl_dico_modifs.append(self.dico_modifs)
                                    #print "Info_Modifs:",self.dico_modifs
                                    #print "Modifs:",tbl_modifs
                            else:
                                if not self.begin_req_parag:
                                    self.begin_req_parag = self.matchBeginParagraph(requirement_tag,line)
                                else:
                                    # We are into the requirement paragraph
                                    self.debug("LINE: {:s}".format(Tool.removeNonAscii(line)))
                                    if unexpected_start_delimiter:
                                        #print "UNEXPECTED START DELIMITER"
                                        start_delimiter = unexpected_start_delimiter
                                        unexpected_start_delimiter = False
                                    if start_delimiter:
                                        #print "START_DELIMITER"
                                        end_req = False
                                        end_delimiter = self.matchEndLLR(line)
                                        if not end_delimiter:
                                            unexpected_start_delimiter = self.matchBegin(line,tag_req)
                                            if unexpected_start_delimiter:
                                                # Missing end delimiter
                                                end_req = True
                                                self.dico_errors["attributes","S_5",found_dir,start_delimiter,""] = ["Warning, missing end delimiter in requirement"]

                                            begin_attr = self.parseAttr(line,
                                                           list_attr_to_be_found,
                                                           tbl_llr,
                                                           begin_attr,
                                                           found_dir,
                                                           start_delimiter,
                                                           end_req)
                                            if not begin_attr:
                                                # Still in body
                                                body = self.matchLLRBody(line)
                                                if body:
                                                    tbl_body.append(body)
                                        else:
                                            end_req = True
                                        if end_req:
                                            begin_attr = False
                                            # End delimiter has been found
                                            tbl_llr["body"]= self.getBody(tbl_body,start_delimiter)
                                            tbl_req_tag.append(start_delimiter)
                                            tbl_req_tag_wo_del.append(start_delimiter)
                                            # Correct allocation
                                            if "allocation" in tbl_llr:
                                                #list_allocation_name = Tool.getAllocationComponent(component)
                                                list_allocation_name = Tool.getAllocationComponent()
                                                dico_alloc_name = []
                                                for tbl_allocation_name in list_allocation_name:
                                                    for alloc_name in tbl_allocation_name:
                                                        if alloc_name is not None:
                                                            allocations = alloc_name.split(",")
                                                            for allocation in allocations:
                                                                dico_alloc_name.append(allocation)
                                                tbl_alloc = []

                                                allocation_txt = tbl_llr["allocation"]
                                                for x in dico_alloc_name:
                                                    #print "TEST Alloc:",x
                                                    if x in allocation_txt:
                                                        tbl_alloc.append(x)
                                                        #print "{:s} found in string".format(x)
                                                #print tbl_alloc
                                                allocation_str = ",".join(tbl_alloc)
                                                if tbl_alloc != []:
                                                    tbl_llr["allocation"] = allocation_str
                                            self.tbl_list_llr[start_delimiter] = tbl_llr
                                            #del(list_attr_found[:])
                                            del(list_attr_to_be_found[:])
                                            for key,attr in self.dico_attributes.items():
                                                list_attr_to_be_found.append(key)
                                            try:
                                                # Test derived requirements
                                                result = self.getDerived(type,
                                                                         tbl_llr["refer"],
                                                                         tbl_llr["derived"],
                                                                         found_dir,
                                                                         start_delimiter)
                                                if result:
                                                    # Derived found
                                                    self.nb_derived_req += 1
                                            except KeyError,e:
                                                self.dico_errors["miscelleanous","S_4",found_dir,start_delimiter,""] = ["Attribute {:s} is missing for this requirement.".format(e)]
                                                self.debug("Attribute {:s} is missing for this requirement.".format(e))
                                            try:
                                                # Test status attribute
                                                if re.search("DELETED", tbl_llr["status"]):
                                                    self.dico_debug["status","S_3",self.current_folder,start_delimiter,""] = ["The requirement {:s} is tagged DELETED in order to prevent ID reuse.".format(start_delimiter)]
                                                    self.nb_debug +=1
                                                    tbl_req_tag_wo_del.remove(start_delimiter)
                                                    # Deleted found
                                                    self.nb_deleted_req += 1
                                                else:
                                                    self.nb_reqs +=1
                                                    nb_reqs_in_file +=1
                                            except KeyError,e:
                                                self.dico_errors["miscelleanous","S_4",found_dir,start_delimiter,""] = ["Attribute {:s} is missing for this requirement.".format(e)]
                                                self.debug("Attribute {:s} is missing for this requirement.".format(e))
                                                self.nb_reqs +=1
                                                nb_reqs_in_file +=1
                                            tbl_body = []
                                            tbl_llr = {}
                                            start_delimiter = False
                                    else:
                                        # No start delimiter found yet
                                        #print "FIRST TIME START DELIMITER",line,type
                                        start_delimiter = self.matchBegin(line,tag_req)
                                    self.check_matrix.check(line)
                        # Enf line parsing
                    # Enf of file parsing
                    # Ex:
                    # tbl_file_llr["Actuation_in_LESS_configuration"] = ["SWDD_SMS_PDS_ENM_CSC027_CSU072_005",etc.]
                    self.tbl_file_llr[name] = tbl_req_tag
                    self.tbl_file_llr_wo_del[name] = tbl_req_tag_wo_del
                    self.tbl_file_nb_llr[name] = nb_reqs_in_file
                    self.tbl_file_dir[name] = "/".join(self.stack)
                    self.result(nb_reqs_in_file,found_dir,name)

                elif extension in ("xlsx","xlsm") and void != "~$":
                    self.log("Parse {:s} type {:s}".format(found_dir,type),gui_display=True)
                    filename = join(new_concat_dirname,found_dir)
                    wb = self.loadWorkbook(filename)
                    tbl_excel_cells = []
                    self.check_matrix = checkMatrix({},self.log)
                    if name == self.dico_spec["icd_spi_data"] or type == "ICD_SPI":
                        #print "self.dico_sheets",self.dico_sheets
                        sheet_name = self.dico_sheets["icd_spi"][1]
                        self.parseExcel(wb,'A2:B2000',sheet_name,tbl_excel_cells)
                        for line in tbl_excel_cells:
                            req = line[0]
                            # Issue per requirement
                            issue = str(line[1])
                            #print "REQ",start_delimiter,req
                            start_delimiter = self.matchBegin(req,type)
                            if start_delimiter:
                                tbl_llr["allocation"]=component
                                tbl_llr["issue"] = issue
                                tbl_req_tag.append(start_delimiter)
                                tbl_req_tag_wo_del.append(start_delimiter)
                                self.tbl_list_llr[start_delimiter] = tbl_llr
                                self.nb_reqs +=1
                                nb_reqs_in_file +=1
                                tbl_llr = {}
                    elif name == self.dico_spec["icd_can_data"] or type == "ICD_CAN":
                        #self.sheets_list = ["ListOfModifications","Applicable documents","DataUnitsExchanges","DataCoding","Message Identifiers","Synchro (50ms)"]
                        # Get issue of document in first sheet
                        sheet_name = self.dico_sheets["icd_can"][0]
                        self.parseExcel(wb,'AX4:AX4',sheet_name,tbl_excel_cells)
                        #print "tbl_excel_cells",tbl_excel_cells
                        issue_read_in_doc = tbl_excel_cells[0][0]
                        print "issue_read_in_doc",issue_read_in_doc
                        m = re.match(r'^Issue ([0-9]*)$',issue_read_in_doc)
                        if m:
                            issue_doc = m.group(1)
                        else:
                            issue_doc = 0
                        print "issue_doc",issue_doc
                        sheet_name = self.dico_sheets["icd_can"][3]
                        self.parseExcel(wb,'A2:B5000',sheet_name,tbl_excel_cells)
                        #print "tbl_excel_cells",tbl_excel_cells
                        for line in tbl_excel_cells:
                            req = line[0]
                            #print "REQ",start_delimiter,req
                            if req is not None:
                                start_delimiter = self.matchBegin(req,type)
                                if start_delimiter:
                                    tbl_llr["allocation"]=component
                                    tbl_llr["issue"] = issue_doc
                                    tbl_req_tag.append(start_delimiter)
                                    tbl_req_tag_wo_del.append(start_delimiter)
                                    self.tbl_list_llr[start_delimiter] = tbl_llr
                                    self.nb_reqs +=1
                                    nb_reqs_in_file +=1
                                    tbl_llr = {}
                    else:
                        self.parseExcel(wb,'A2:B2000',"Feuil1",tbl_excel_cells)
                        for line in tbl_excel_cells:
                            req = line[0]
                            issue = str(line[1])
                            #print "REQ",start_delimiter,req
                            start_delimiter = self.matchBegin(req,type)
                            if start_delimiter:
                                tbl_llr["allocation"]=component
                                tbl_llr["issue"] = issue
                                tbl_req_tag.append(start_delimiter)
                                tbl_req_tag_wo_del.append(start_delimiter)
                                self.tbl_list_llr[start_delimiter] = tbl_llr
                                self.nb_reqs +=1
                                nb_reqs_in_file +=1
                                tbl_llr = {}

                    self.tbl_file_llr[name] = tbl_req_tag
                    self.tbl_file_llr_wo_del[name] = tbl_req_tag_wo_del
                    self.tbl_file_nb_llr[name] = nb_reqs_in_file
                    self.tbl_file_dir[name] = "/".join(self.stack)
                    self.result(nb_reqs_in_file,found_dir,name)
                    #text = "Found {:d} requirements in {:s}:{:s}".format(nb_reqs_in_file,self.tbl_file_dir[name],found_dir)
                    #self.log(text,gui_display=True)
                else:
                    self.log("Discard {:s}".format(found_dir),gui_display=True)
                    self.check_matrix = checkMatrix({},self.log)
                    # Wrong Word format, only openxml
                    text = "Wrong Word format for {:s}, only openxml format (docx/docm/xlsx/xlsm) accepted".format(found_dir)
                    self.log(text)
        self.depth -= 1

if __name__ == '__main__':
    #tool = Tool()
    component = Tool.getComponentAllocation("SDSIO_BITE_SW")
    #component = Tool.getComponentAllocation("Software BITE,TIE_BITE_SW,SDSIO_BITE_SW,ESSNESS_BITE_SW")
    print "COMPONENT",component
    test_module = CheckLLR()
    test_module.openLog()
    test_module.tbl_list_llr = {u'SSCS_ESSNESS_9020': {'status': u'\tMATURE', 'body': u'In case of RNESS board configuration, the contactor CONTACT_C (GPULC contactor) shall be managed according to following diagram:', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7213]'}, u'SSCS_ESSNESS_9141': {'status': u'\tMATURE', 'body': u'When duty cycle of DSI_ALT_STATUS is:\nout of the range 8% +/-3% AND out of the range 92% +/-3% AND \nout of the range 16% +/-3% AND out of the range 84% +/-3% AND\nout of the range 24% +/-3% AND out of the range 76% +/-3% AND\nout of the range 32% +/-3% AND out of the range 68% +/-3% AND\nout of the range 40% +/-3% AND out of the range 60% +/-3% AND\nout of the range 48% +/-3% AND out of the range 52% +/-3%\nCBIT_ALT_STATUS_FAIL shall be activated', 'additional': u'\tModified according SACR291', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_7115]'}, u'SSCS_ESSNESS_9140': {'status': u'\tMATURE', 'body': u'When DSI_ALT_STATUS was active once, if its frequency is out of the range [950,1050Hz], failure CBIT_ALT_STATUS_FAIL shall be activated', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7115]'}, u'SSCS_ESSNESS_9143': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9142': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5501': {'status': u'\tMATURE', 'body': u'According to board configuration, the correspondence between signal names in ESSNESS board interface and signal names in the PDS shall be as following:\nSignal name\nLESS config.\nRESS config.\nLNESS config.\nRNESS config.\n28V_BAT_TRU_MON\n28V_BAT1_MON\n28V_BAT2_MON\n28V_TRU1_MON\n28V_TRU2_MON\n28V_ESS_MON\n28V_LH_ESS_MON\n28V_RH_ESS_MON\n28V_LH_ESS_MON\n28V_RH_ESS_MON\n28V_MAIN_MON\nLH_28V_MAIN_MON\nRH_28V_MAIN_MON\nLH_28V_MAIN_MON\nRH_28V_MAIN_MON\n28V_FUSE\nLH_SPDB_ESS\nRH_SPDB_ESS\nLH_SPDB_MAIN\nRH_SPDB_MAIN\nTable 21: Correspondence for 28V between ESSNESS names and system names', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_533],\t[SDTS_PDS_375],\t[SDTS_PDS_529],\t[SDTS_PDS_374]'}, u'SSCS_ESSNESS_6061': {'status': u'\tMATURE', 'body': u'After uploading, the PCB shall be reset as a new Power-Up.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_4043]'}, u'SSCS_ESSNESS_7876': {'status': u'\tMATURE', 'body': u'In case of NESS configuration,the FUNC microcontroller shall deactivate CABC_CURRENT_CH1_VALID when DSI_SHP_CABC_STATUS is open, and the ASI_HES2_CH1 is outside the following range [-30A; +30A] during 5s +/-50ms', 'additional': u'\tWhen contactor is open the current flowing through it is null, this test verifies the correct behaviour of HES', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7238],\t[SDTS_PDS_7239],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_4609': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, when the parity of label [LabelNumber] is not odd, LabelReceived_[LabelNumber] shall be set inactive\nWhere [LabelNumber] is 54, 55, 56, 73 or 74', 'additional': u'\tAdded according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_8071]'}, u'SSCS_ESSNESS_7874': {'status': u'\tMATURE', 'body': u'In case of LNESS configuration,the FUNC microcontroller shall activate CABC_CURRENT_CH1_VALID when one of the following condition is true:\nAt board power up\nRisind edge on DSI_CABIN_MASTER_CMD', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7238]'}, u'SSCS_ESSNESS_0160': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t ', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5401': {'status': u'\tMATURE', 'body': u'The interface between one current transformer and the ESSNESS board shall be as following:\nFigure 17: Interface between current transformer and ESSNESS board', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_2603]'}, u'SSCS_ESSNESS_5402': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall acquire and scale differential voltage at current transformer output:\nASI_CT1_PHA corresponds to the differential input ANA_CT1_PHA / ANA_CT1_NEUTRAL.\nASI_CT1_PHB corresponds to the differential input ANA_CT1_PHB / ANA_CT1_NEUTRAL.\nASI_CT1_PHC corresponds to the differential input ANA_CT1_PHC / ANA_CT1_NEUTRAL.\nVoltage range at board input is +/-10V', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tDifferential inputs coming from CT has to be formatted in order to be readable by the microcontroller.', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5403': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall acquire and scale differential voltage at current transformer output:\nASI_CT2_PHA corresponds to the differential input ANA_CT2_PHA / ANA_CT2_NEUTRAL.\nASI_CT2_PHB corresponds to the differential input ANA_CT2_PHB / ANA_CT2_NEUTRAL.\nASI_CT2_PHC corresponds to the differential input ANA_CT2_PHC / ANA_CT2_NEUTRAL.\nVoltage range at board input is +/-10V', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tDifferential inputs coming from CT has to be formatted in order to be readable by the microcontroller.', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5404': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall acquire and scale differential voltage at current transformer output:\nASI_CT3_PHA corresponds to the differential input ANA_CT3_PHA / ANA_CT3_NEUTRAL.\nASI_CT3_PHB corresponds to the differential input ANA_CT3_PHB / ANA_CT3_NEUTRAL.\nASI_CT3_PHC corresponds to the differential input ANA_CT3_PHC / ANA_CT3_NEUTRAL.\nVoltage range at board input is +/-10V', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tDifferential inputs coming from CT has to be formatted in order to be readable by the microcontroller.', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2122': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, DSO_FWD_WATER_HEATER_AUTHORISED shall be active when all following conditions are true:\nGALLEY_SW is in AUTO state, see \xa72.4.5\nMAIN_115VAC_PRESENCE is active.\nDSI_START_IN_PROGRESS is inactive\nDSO_SHED_ENG_FAIL is inactive\nElse it is inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_4021]'}, u'SSCS_ESSNESS_0308': {'status': u'\tTBC', 'body': u'NESS board shall activate TRU_OR when ASI_28V_BAT_TRU_MON voltage ripple is above 5V +/-0,5V TBC', 'additional': u'\tHardware module have no rising time (but have a falling time)', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_2150],\t[SDTS_PDS_2151]'}, u'SSCS_ESSNESS_0309': {'status': u'\tTBC', 'body': u'In case of NESS configuration, TRU undervoltage protection shall be activated when ASI_28V_BAT_TRU_MON is lower than 22V +/-0.5V TBC for more than 5s +/- 50ms', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_349],\t[SDTS_PDS_352],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_0305': {'status': u'\tTBC', 'body': u'In case of NESS configuration, TRU reverse protection shall be activated when all the following conditions are true:\ncalibrated current flowing through corresponding TRU (ASI_HES1_CH2) is below -30A +/-1,5A TBC for more than 50ms +/-5ms TBC.\nTRU_CURRENT_CH2_VALID is active\ncalibrated current flowing through corresponding TRU (ASI_HES1_CH1) is negative OR TRU_CURRENT_CH1_VALID is inactive', 'additional': u'\tTRU current is monitoring by Hall Effect Sensor see \xa72.6.6,\tTolerance in current is defined as the tolerance of the HES and 1% of the full scale for the board,\tTolerance delay of 1% is not respected due to 5ms minimum software response time', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_132],\t[SDTS_PDS_135],\t[SDTS_PDS_7014],\t[SDTS_PDS_7009]'}, u'SSCS_ESSNESS_0307': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0300': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, the following TRU protections shall be latched to avoid cycling.\nTRU overload protection\nTRU reverse protection\nTRU undervoltage protection\nTRU over ripple protection\nTRU driver fail protection', 'additional': u'\tThe latch of protections means that if a protection is not reset it will be memorised until the next power down ', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_137],\t[SDTS_PDS_140]'}, u'SSCS_ESSNESS_2120': {'status': u'\tMATURE', 'body': u'In case of NESS board, at power up, the signal DSO_FWD_WATER_HEATER_AUTHORISED shall be inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_0302': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, the TRU protections shall be set to inactive when the following condition is true:\nTRU_SW enters AUTO state\nConcerned TRU protections are:\nTRU overload protection\nTRU reverse protection\nTRU undervoltage protection\nTRU over ripple protection\nTRU driver fail protection', 'additional': u'\tTRU_SW states are defined in \xa72.4.2 / Modified according SACR439', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_348],\t[SDTS_PDS_350]'}, u'SSCS_ESSNESS_0303': {'status': u'\tTBC', 'body': u'In case of NESS configuration, TRU overload protection shall be activated when the accumulated current  flowing through corresponding TRU (TRU_CURRENT) is above curve defined with following parameters (with 10% tolerance in time and current TBC)\nWhen I > Isat overload delay is 70ms\nWhen I < Isat, delay is computed according curve described with following parameters\n\tIsat = 2449A\n\tTsat = 0,1s\n\tIth = 330A\n\tTth = 292s\nThe delay computed is 40ms shorter than this curve in order to take into account the system response time', 'additional': u'\tTRU current is monitored by Hall Effect Sensor see \xa72.6.6,\tmodified according SyCR55,\tThe accumulation current process is described in GS3682', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_131],\t[SDTS_PDS_141]'}, u'SSCS_ESSNESS_2121': {'status': u'\tMATURE', 'body': u'In case of LNESS configuration, DSO_FWD_WATER_HEATER_AUTHORISED shall be active when all following conditions are true:\nDSI_ISOLATION_SMOKE_GALLEY_CABIN_MASTER is active\nMAIN_115VAC_PRESENCE is active.\nDSI_START_IN_PROGRESS is inactive\nDSO_SHED_ENG_FAIL is inactive\nElse it is inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_4022]'}, u'ICD_SPI_ESSNESS_DATA_0093': {'issue': '1'}, u'SSCS_ESSNESS_7842': {'status': u'\tTBC', 'body': u'If the ASI_BAT_TRU_TEMP_B is outside the functional range [-55\xb0C; 180\xb0C] TBC, the BITE microcontroller shall deactivate CBIT_BAT_TRU_TEMP_B, else it is active.', 'additional': u'\tSee \xa73.4.1.2 for CAN ICD', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tDefinition of CBIT of temperature sensor', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4046': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4045': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4044': {'status': u'\tMATURE', 'body': u'The 28V_E supply shall be protected with a fuse', 'additional': u'\tThis fuse is not tested', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tThis fuse is added in order to prevent damage on 28V supplies when a short circuit occurs on contactor driver.', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4043': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall generate 28V_E which is composed of 3 different supply sources:\n28V_2\n28V_5\n28V_9', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tTRUE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_2622],\t[SDTS_PDS_2633],\t[SDTS_PDS_2647],\t[SDTS_PDS_2662]'}, u'SSCS_ESSNESS_4042': {'status': u'\tMATURE', 'body': u'The 28V_D supply shall be protected with a fuse', 'additional': u'\tThis fuse is not tested', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tThis fuse is added in order to prevent damage on 28V supplies when a short circuit occurs on contactor driver.', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4041': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall generate 28V_D which is composed of 2 different supply sources:\n28V_2\n28V_7', 'additional': u'\t ', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tTRUE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_276],\t[SDTS_PDS_291],\t[SDTS_PDS_734],\t[SDTS_PDS_740]'}, u'SSCS_ESSNESS_4040': {'status': u'\tMATURE', 'body': u'The 28V_C supply shall be protected with a fuse', 'additional': u'\tThis fuse is not tested', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tThis fuse is added in order to prevent damage on 28V supplies when a short circuit occurs on contactor driver.', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3402': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, when the difference voltage between ASI_28V_ESS_MON and ASI_28V_FUSE is above 5V (+/-0,5V), the state of FUSE shall be BROKEN, else it is OK.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_529]'}, u'SSCS_ESSNESS_3403': {'status': u'\tTBC', 'body': u'In case of NESS configuration, when the difference voltage between ASI_28V_MAIN_MON and ASI_28V_FUSE is above 5V (+/-0,5V)TBC, the state of FUSE shall be BROKEN, else it is OK.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_374]'}, u'SSCS_ESSNESS_3400': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3401': {'status': u'\tMATURE', 'body': u'The BITE microcontroller shall acquire ASI_28V_FUSE', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t28V_FUSE is acquired in order to compute the state of the fuse', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3981': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, CAS_DC_MAIN_FAULT shall be activated when the following conditions is true during 100ms +/-1ms:\n[TC overload protection is active OR TC undervoltage protection is active]\nAND\n[(DSI_TRC_STATUS is open OR DSI_ATRC_STATUS is open) \n\tAND DSI_TC_STATUS is open\n\tAND ESS_OK is active] \nElse it is inactive', 'additional': u'\tThose information are transmitted on ARINC bus / TC overload protection and TC undervoltage protection are computed by FUNC microcontroller and transmitted to BITE through SPI link', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_5000],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_3980': {'status': u'\tTBC', 'body': u'In case of ESS configuration, DC_MAIN_FAULT shall be activated when one at least of the following conditions is true during 100ms +/-5ms\nASI_28V_MAIN is under 21V+/-0,5V TBC AND TRU_HIGH_CURRENT is active\nASI_28V_MAIN is under 21V+/-0,5V TBC AND DSI_TC_STATUS is closed AND BAT_HIGH_CURRENT is active\nASI_28V_MAIN is under 21V+/-0,5V TBC AND DSI_TC_STATUS is closed AND TSBC_HIGH_CURRENT is active\nElse it is inactive', 'additional': u'\tThose information are transmitted on ARINC bus', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7136],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_5101': {'status': u'\tMATURE', 'body': u'According to board configuration, the correspondence between signal name in ESSNESS board interface and signal name in the PDS shall be according following table:\nName\nLESS\nRESS\nLNESS\nRNESS\nANA_DC_AREA_TEMP_P\nLEFT_MAIN_DC_BUS_BAR_TEMP_B_P\nRIGHT_MAIN_DC_BUS_BAR_TEMP_B_P\nLEFT_MAIN_DC_BUS_BAR_TEMP_A_P\nRIGHT_MAIN_DC_BUS_BAR_TEMP_A_P\nANA_DC_AREA_TEMP_N\nLEFT_MAIN_DC_BUS_BAR_TEMP_B_N\nRIGHT_MAIN_DC_BUS_BAR_TEMP_B_N\nLEFT_MAIN_DC_BUS_BAR_TEMP_A_N\nRIGHT_MAIN_DC_BUS_BAR_TEMP_A_N\nANA_BAT_TRU_TEMP_A_P\nBAT1_TEMP_A_P\nBAT2_TEMP_A_P\nTRU1_TEMP_A_P\nTRU2_TEMP_A_P\nANA_BAT_TRU_TEMP_A_N\nBAT1_TEMP_A_N\nBAT2_TEMP_A_N\nTRU1_TEMP_A_N\nTRU2_TEMP_A_N\nANA_BAT_TRU_TEMP_B_P\nBAT1_TEMP_B_P\nBAT2_TEMP_B_P\nTRU1_TEMP_B_P\nTRU2_TEMP_B_P\nANA_BAT_TRU_TEMP_B_N\nBAT1_TEMP_B_N\nBAT2_TEMP_B_N\nTRU1_TEMP_B_N\nTRU2_TEMP_B_N\nTable 18: Correspondence for temperatures measurement between ESSNESS names and system names', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tTRUE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_524],\t[SDTS_PDS_525],\t[SDTS_PDS_373],\t[SDTS_PDS_510]'}, u'SSCS_ESSNESS_5100': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall acquire and scale the following analog inputs, corresponding to temperature measurements through sensors type PT100:\nASI_DC_AREA_TEMP corresponds to the differential input ANA_DC_TEMP_AREA_P / ANA_DC_TEMP_AREA_N\nASI_BAT_TRU_TEMP_A corresponds to the differential input ANA_BAT_TRU_TEMP_A_P / ANA_BAT_TRU_TEMP_A_N\nASI_BAT_TRU_TEMP_B corresponds to the differential input ANA_BAT_TRU_TEMP_B_P / ANA_BAT_TRU_TEMP_B_N', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_524],\t[SDTS_PDS_525],\t[SDTS_PDS_373],\t[SDTS_PDS_510]'}, u'SSCS_ESSNESS_5103': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall be able to acquire temperature included in the range [-55\xb0C; 180\xb0C] for the following input:\nASI_BAT_TRU_TEMP_A\nASI_BAT_TRU_TEMP_B', 'additional': u'\tSDTS_PDS_510 is corrected by / SSCS_ESSNESS_5103 is compliant with this correction', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_510]'}, u'ICD_SPI_ESSNESS_DATA_0083': {'issue': '1'}, u'SSCS_ESSNESS_9123': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'ICD_SPI_ESSNESS_DATA_0091': {'issue': '1'}, u'SSCS_ESSNESS_0904': {'status': u'\tMATURE', 'body': u'In case of LESS configuration, BOOC_PROTECTION shall be activated when one at least of the following conditions is TRUE:\nBOOC overload protection is active\nBOOC undervoltage protection is active\nBOOC driver fail protection is active\nElse it is inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_EQUAT_307]'}, u'SSCS_ESSNESS_0905': {'status': u'\tMATURE', 'body': u'In case of LESS configuration, BOOC driver fail protection shall be activated when CONTACT_D_TRIP is active and 28V_D is over 18,5V +/-0,5V', 'additional': u'\tmodified according SyCR17 / SACR258', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7120],\t[SDTS_PDS_8007],\t[SDTS_PDS_8008]'}, u'SSCS_ESSNESS_0902': {'status': u'\tTBC', 'body': u'In case of LESS configuration, BOOC overload protection shall be activated when all the following conditions are met:\ncalibrated current flowing through battery (ASI_HES1_CH1) is above 520A +/-26A TBC during 30ms +/-5msTBC.\nDSI_START_ACCEPTED_APUSLC_STATUS is active', 'additional': u'\tbattery current is monitoring through Hall Effect Sensor, see \xa72.6.6,\t1% delay tolerance cannot be achieve due to 5ms minimum microcontroller response time,\tCurrent tolerance corresponds to HES tolerance and 1% of the full scale for the board', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_277],\t[SDTS_PDS_7014],\t[SDTS_PDS_7009]'}, u'SSCS_ESSNESS_0903': {'status': u'\tTBC', 'body': u'In case of LESS configuration, BOOC undervoltage protection shall be activated when all the following conditions are met:\nASI_28V_BAT_TRU_MON is below 14V +/-0,5V TBC during 460ms +/-5ms.\nDSI_START_ACCEPTED_APUSLC_STATUS is active', 'additional': u'\tThe SDTS doesn\u2019t take into account the response time of the system (delay reduced by 40ms)', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_0448],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_0900': {'status': u'\tMATURE', 'body': u'In case of LESS configuration, BOOC protections shall be latched to avoid cycling .\nConcerned protections are:\nBOOC overload protection\nBOOC undervoltage protection\nBOOC driver fail protection', 'additional': u'\tThe latch of protections means that if a protection is not reset it will be memorised until the next power down', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_278]'}, u'SSCS_ESSNESS_0901': {'status': u'\tMATURE', 'body': u'In case of LESS configuration BOOC protections shall be set to inactive when one at least of the following conditions is true:\nAt power up of the board\nDSI_START_ACCEPTED_APUSLC_STATUS goes from inactive to active .\nConcerned BOOC protections are:\nBOOC overload protection\nBOOC undervoltage protection\nBOOC driver fail protection', 'additional': u'\tModified according SACR439', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_0449]'}, u'SSCS_ESSNESS_2250': {'status': u'\tMATURE', 'body': u'At power up, the signals DSO_M_28OPEN_1 and DSO_M_28OPEN_2 shall be inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_2251': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7308': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t3', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7701': {'status': u'\tMATURE', 'body': u'The PBIT shall be launched at Power-Up when all following conditions are met :\nA/C on Ground \nNo Engine Running (DSI_GLC_STATUS AND DSI_GLC_OPP_STATUS are open)\n\tDSI_POWER_ON is in active state.', 'additional': u'\tA/C on ground is described in \xa72.6.1', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_2320]'}, u'SSCS_ESSNESS_2097': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2098': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'ICD_SPI_ESSNESS_DATA_0082': {'issue': '1'}, u'SSCS_ESSNESS_2092': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2093': {'status': u'\tMATURE', 'body': u'In case of LNESS configuration, the FUNC microcontroller shall activate DSO_CAB_GAL_LT when CABIN_SW is OFF state,\nElse it is inactive', 'additional': u'\tCABIN_SW states are described in \xa72.4.4', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_696]'}, u'SSCS_ESSNESS_2090': {'status': u'\tMATURE', 'body': u'In case of NESS board, at power up, the signal DSO_CAB_GAL_LT shall be inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_2091': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2096': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, the FUNC microcontroller shall activate DSO_CAB_GAL_LT when GALLEY_SW is OFF state,\nElse it is inactive.', 'additional': u'\tGALLEY_SW states are defined in \xa72.4.5', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_698]'}, u'ICD_SPI_ESSNESS_DATA_0092': {'issue': '1'}, u'SSCS_ESSNESS_2094': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2095': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7702': {'status': u'\tMATURE', 'body': u'After CPU power-up, the PBIT shall last less than 250ms', 'additional': u'\tThere is no PBIT on board except CPU self test and watchdog', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE,\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_538]'}, u'SSCS_ESSNESS_5610': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall acquire and scale the following AC voltage:\nANA_ALT_115_PHA\nANA_ALT_115_PHB\nANA_ALT_115_PHC', 'additional': u'\tThe AC voltage at board input is proportionnel to voltage on the bus bar and is in the range [+10V, -10V].', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to be able to detect voltage presence on alternate bus (only for RNESS configuration)', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5613': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, the FUNC and the BITE microcontrollers shall read ALT_115VAC_PRESENCE ', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tVoltage presence on ALTERNATE bus is used for GPULC contactor', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5612': {'status': u'\tTBC', 'body': u'The ESSNESS board shall activate ALT_115VAC_PRESENCE when the voltage on at least one of the three phases ANA_ALT_115_PhA, ANA_ALT_115_PhB, ANA_ALT_115_PhC is over 20Vrms +/-4V TBC', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_5048]'}, u'SSCS_ESSNESS_5615': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, the FUNC and the BITE microcontrollers shall read ALT_115VAC_NOMINAL ', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tnominal voltage on ALTERNATE bus is used for contactor', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5614': {'status': u'\tTBC', 'body': u'The ESSNESS board shall activate ALT_115VAC_NOMINAL when the voltage on each one of the three phases ANA_ALT_115_PhA, ANA_ALT_115_PhB, ANA_ALT_115_PhC is over 100Vrms [0,+10Vrms] TBC', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7234]'}, u'SSCS_ESSNESS_5617': {'status': u'\tTBC', 'body': u'The AC RMS voltage measurement accuracy shall be +/- 4 Vrms (TBC) up to 130 Vrms with 10% harmonic distorsion', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7006]'}, u'SSCS_ESSNESS_5616': {'status': u'\tMATURE', 'body': u'The amplitude of AC voltage on ESSNESS board input shall be considered as the voltage on power bus divided by 30 +/-0,2%', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_4200]'}, u'SSCS_ESSNESS_2131': {'status': u'\tMATURE', 'body': u'In case of LNESS configuration, DSO_AFT_WATER_HEATER_AUTHORISED shall be active when all following conditions are true:\nCABIN_MASTER_SW is AUTO state or SHED state, see \xa72.4.3\nMAIN_115VAC_NOMINAL is active\nDSI_START_IN_PROGRESS is inactive\nDSO_SHED_ENG_FAIL is inactive \nElse it is inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_4023]'}, u'ICD_SPI_ESSNESS_DATA_0090': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0009': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0008': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0007': {'issue': '2'}, u'ICD_SPI_ESSNESS_DATA_0006': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0005': {'issue': '2'}, u'ICD_SPI_ESSNESS_DATA_0004': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0003': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0002': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0001': {'issue': '1'}, u'SSCS_ESSNESS_3904': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'ICD_SPI_ESSNESS_DATA_0139': {'issue': '2'}, u'ICD_SPI_ESSNESS_DATA_0138': {'issue': '2'}, u'SSCS_ESSNESS_2023': {'status': u'\tTBC', 'body': u'In case of NESS board configuration, the ESSNESS board shall control DSO_BAT_HEATER_TRU_FAN_POWER according following logic:\nIf ASI_28V_MAIN_MON rises over 18V +/-0,5V TBCThen DSO_BAT_HEATER_TRU_FAN_POWER is activated during 5s +/-50ms\nElseWhen BAT_TRU_TEMP is higher than 90\xb0C (+/-5\xb0C),or temperature is not available, DSO_BAT_HEATER_TRU_FAN_POWER is activatedWhen BAT_TRU_TEMP is lower than 70\xb0C (+/-5\xb0C), DSO_BAT_HEATER_TRU_FAN is de-activated', 'additional': u'\tBAT_TRU_TEMP is defined in \xa72.6.2,\t2,5\xb0C tolerance cannot be achieve,\tmodified according SyCR17', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_662],\t[SDTS_PDS_663],\t[SDTS_PDS_7167],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_2022': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2021': {'status': u'\tMATURE', 'body': u'In case of ESS board configuration, the ESSNESS board shall control DSO_BAT_HEATER_TRU_FAN_POWER according following logic:\nIf BAT_SW switches from OFF to AUTO state AND MAIN_115VAC_NOMINAL is activeOR MAIN_115VAC_NOMINAL is active for the fisrt time after power upThen DSO_BAT_HEATER_TRU_FAN_POWER is activated during 2s +/-0,2s\nElseWhen BAT_TRU_TEMP is lower than 5 +/-5\xb0C AND DSI_POWER_ON is active, DSO_BAT_HEATER_TRU_FAN_POWER is activatedWhen BAT_TRU_TEMP is higher than 15 +/-5\xb0C or when temperature is invalid, DSO_BAT_HEATER_TRU_FAN_POWER is de-activated', 'additional': u'\tBAT_TRU_TEMP is defined in \xa72.6.2 / Modified according SACR439', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_2170],\t[SDTS_PDS_4069],\t[SDTS_PDS_7079]'}, u'SSCS_ESSNESS_2020': {'status': u'\tMATURE', 'body': u'At power up, the signal DSO_BAT_HEATER_TRU_FAN_POWER and DSO_BAT_HEATER_RELAY2 shall be inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_163]'}, u'ICD_SPI_ESSNESS_DATA_0133': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0132': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0131': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0130': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0137': {'issue': '3'}, u'ICD_SPI_ESSNESS_DATA_0136': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0135': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0134': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0096': {'issue': '2'}, u'SSCS_ESSNESS_7910': {'status': u'\tMATURE', 'body': u'The BITE microcontroller shall read BAT_TRU_SW_ERROR.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_2026]'}, u'SSCS_ESSNESS_9999': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall carry a label containing the equipment name, the manaufacturer\u2019s identification, the NATO code, the P/N, the S/N.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tIn order to be able to trace the board during his life cycle', 'issue': u'\t2', 'refer': 'EMPTY'}, u'ICD_SPI_ESSNESS_DATA_0094': {'issue': '1'}, u'SSCS_ESSNESS_7302': {'status': u'\tMATURE', 'body': u'Voltage spike:\nThe ESSNESS board shall withstand voltage spikeof 600V with following waveform.', 'additional': u'\tQualification test at system level \u2013 Verification test at product level for risk mitigation purpose,\tMIL-STD 461-C is not covered by this requirement', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': 'EMPTY', 'issue': u'\t3', 'refer': u'[SDTS_PDS_1028]'}, u'ICD_SPI_ESSNESS_DATA_0097': {'issue': '2'}, u'SSCS_ESSNESS_4621': {'status': u'\tMATURE', 'body': u'In case of NESS configurations, at power-up, FLIGHT shall be active.', 'additional': u'\tAdded according SACR809', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define FLIGHT at power-up', 'issue': u'\t7', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0120': {'status': u'\tMATURE', 'body': u'Driver of CONTACT_B shall be powered by 28V_B.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_282],\t[SDTS_PDS_284],\t[SDTS_PDS_727],\t[SDTS_PDS_723]'}, u'SSCS_ESSNESS_0121': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0122': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6053': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5701': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall generate the following DSO:\nName\nType\nComments\nDSO_BAT_TRU_LT\nGND / Open\nDSO_GND_OPEN_50mA_OCP_WITH_LIGHTNING\nDSO_CABC_SHED\nGND / Open\nDSO_GND_OPEN_20mA_WITH_LIGHTNING\nDSO_TRC_CMD\nGND / Open\nDSO_GND_OPEN_20mA_WITHOUT_LIGHTNING\nDSO_TC_RESET\nGND / Open\nDSO_GND_OPEN_20mA_WITHOUT_LIGHTNING\nDSO_xALTC1_HES_TRU_CURRENT\nGND / Open\nDSO_GND_OPEN_20mA_WITH_LIGHTNING\nDSO_SHED_ENG_FAIL\nGND / Open\nDSO_GND_OPEN_500mA_WITH_LIGHTNING\nDSO_SHED_START\nGND / Open\nDSO_GND_OPEN_500mA_WITHOUT_LIGHTNING\nDSO_BAT_HEATER_TRU_FAN_POWER\nGND / Open\nDSO_GND_OPEN_500mA_WITH_LIGHTNING\nDSO_ESS_TRU_STATUS\nGND / Open\nDSO_PWM_20mA_WITH_LIGHTNING\nDSO_BAT_HEATER_RELAY2\n28V / Open\nDSO_28V_OPEN_150mA_WITH_LIGHTNING\nDSO_APU_ECU_HPP_RELAY_CMD\n28V / Open\nDSO_28V_OPEN_150mA_WITH_LIGHTNING\nDSO_FAN_POWER_PPDB\n28V / Open\nDSO_28V_OPEN_400mA_WITHOUT_LIGHTNING\nDSO_L_28OPEN_1\n28V / Open\nDSO_28V_OPEN_20mA_WITHOUT_LIGHTNING\nDSO_M_28OPEN_1\n28V / Open\nDSO_28V_OPEN_400mA_WITH_LIGHTNING\nDSO_M_28OPEN_2\n28V / Open\nDSO_28V_OPEN_400mA_WITHOUT_LIGHTNING\nTable 23: DSO interface of ESSNESS board', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_535],\t[SDTS_PDS_386]'}, u'SSCS_ESSNESS_8002': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4524': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4525': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, no data shall be sent on ARINC429 bus from power-up until 1,5s +/-20ms after PBIT completion.', 'additional': u'\tthe delay is 10s in SDTS, delay is 500ms shorter in this requirement in order to take count of power-up duration,\tModification according SACR382', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_6216],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_5700': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall have 25% of spares for DSO with a minimum of 10.', 'additional': u'\t', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_4013],\t[SDTS_PDS_4014]'}, u'SSCS_ESSNESS_4520': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4521': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4522': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'ICD_SPI_ESSNESS_DATA_0095': {'issue': '1'}, u'SSCS_ESSNESS_8000': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9164': {'status': u'\tMATURE', 'body': u'At power up until DSI_ALT_STATUS becomes active once, the associated signals shall have the following values:\nSTBY_TRU_FAIL is inactive\nTIE_ALT_115VAC_OVL is inactive\nTIE_ALT_115VAC_FAULT is inactive', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define those data at power-up', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6306': {'status': u'\tMATURE', 'body': u'The BITE microcontroller shall be the master of the SPI bus and the FUNC microcontroller the slave.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tThe SPI bus is also managed by the FUNC microcontroller.', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5408': {'status': u'\tMATURE', 'body': u'According to board configuration, the correspondence between signal names in ESSNESS board interface and signal names in the PDS shall be as following:\nSignal name\nLESS config.\nRESS config.\nLNESS config.\nRNESS config.\nANA_CT1_PHA\nNot used\nNot used\nCT_GALC1_PHA\nCT_GALC2_PHA\nANA_CT1_PHB\nNot used\nNot used\nCT_GALC1_PHB\nCT_GALC2_PHB\nANA_CT1_PHC\nNot used\nNot used\nCT_GALC1_PHC\nCT_GALC2_PHC\nANA_CT1_NEUTRAL\nNot used\nNot used\nCT_GALC1_NEUTRAL\nCT_GALC2_NEUTRAL\nANA_CT2_PHA\nBAT_HEATER_CTC1_PhA\nBAT_HEATER_CTC2_PhA\nNot used\nCT_GPU_PHA\nANA_CT2_PHB\nBAT_HEATER_CTC1_PhB\nBAT_HEATER_CTC2_PhB\nNot used\nCT_GPU_PHB\nANA_CT2_PHC\nBAT_HEATER_CTC1_PhC\nBAT_HEATER_CTC2_PhC\nNot used\nCT_GPU_PHC\nANA_CT2_NEUTRAL\nBAT_HEATER_CTC1_N\nBAT_HEATER_CTC2_N\nNot used\nCT_GPU_NEUTRAL\nANA_CT3_PHA\nCT_LALTC1_PhA\nCT_RALTC1_PhA\nCT_ATRC1_PhA\nCT_ATRC2_PhA\nANA_CT3_PHB\nCT_LALTC1_PhB\nCT_RALTC1_PhB\nCT_ATRC1_PhB\nCT_ATRC2_PhB\nANA_CT3_PHC\nCT_LALTC1_PhC\nCT_RALTC1_PhC\nCT_ATRC1_PhC\nCT_ATRC2_PhC\nANA_CT3_NEUTRAL\nCT_LALTC1_N\nCT_RALTC1_N\nCT_ATRC1_N\nCT_ATRC2_N\nTable 20: Correspondence for CT outputs between ESSNESS names and system names', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_507],\t[SDTS_PDS_2602]'}, u'SSCS_ESSNESS_4113': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5804': {'status': u'\tMATURE', 'body': u'Any fault on one contactor driver shall not impair the functioning of the others', 'additional': u'\tWhere X corresponds to A, B,C,D,E', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tTRUE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_5037]'}, u'SSCS_ESSNESS_6302': {'status': u'\tMATURE', 'body': u'The softwares embedded in ESSNESS board shall be developed according Level B of .DO178-B [41]', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tTRUE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_540],\t[SDTS_PDS_511]'}, u'SSCS_ESSNESS_6303': {'status': u'\tMATURE', 'body': u'The FUNC microcontroller shall have read three dedicated signals in order to verify which type of microcontroller it is.\nUC_TYPE_1_FUNC is inactive\nUC_TYPE_2_FUNC is active\nUC_PARITY_FUNC is inactive', 'additional': u'\tActive corresponds to 1,\tInactive corresponds to 0', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThose pins allow verifying whether the microcontroller is a FUNC, BITE one, so that if one microcontroller was badly programmed (with the wrong software) it can be detected Three signals are used in order to be able to have a spare configuration is for a third microcontroller if the THD measurement is done with a microcontroller.', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6300': {'status': u'\tMATURE', 'body': u'The ESSNESS microcontrollers (FUNC and BITE) shall utilize less than 50% of the processing capability', 'additional': u'\tdefines the margin goal for microcontroller processing capability, 50% for the first standard and then 75% for certification standard (this requirement cannot be compliant with SDTS requirement because there is two values for the margin goal which depend of the project phasis, a requirement cannot be link to the planning => I propose to update this requirement to 75% at the beginning of the certification activities,\tModified according SyCR22', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7274]'}, u'SSCS_ESSNESS_6301': {'status': u'\tMATURE', 'body': u'The ESSNESS microcontroller\u2019s memories shall be a 50% growth capability for functional expansion.\nThe 50% requirement applies to each memory type independently.', 'additional': u'\tdefines the margin goal for microcontroller memories, 50% for the first standard and then 75% for certification standard (this requirement cannot be compliant with SDTS requirement because there is two values for the margin goal which depend of the project phasis, a requirement cannot be link to the planning => I propose to update this requirement to 75% at the beginning of the certification activities,\tModified according SyCR22', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7274]'}, u'SSCS_ESSNESS_6308': {'status': u'\tMATURE', 'body': u'The FUNC microcontroller shall drive one LED when software is running (blinking: frequency 1Hz and duty cycle 0.5)', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tallow to see if \xb5C FUNC is running or not', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6309': {'status': u'\tMATURE', 'body': u'The BITE microcontroller shall drive one LED when software is running (blinking: frequency 1Hz and duty cycle 0.5)', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tallow to see if \xb5C BITE is running or not', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5729': {'status': u'\tMATURE', 'body': u'The DSO_28V_OPEN_400mA_WITH/WITHOUT_LIGHTNING shall be protected against polarity inversion with a diode', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6118]'}, u'SSCS_ESSNESS_5728': {'status': u'\tMATURE', 'body': u'The DSO_28V_OPEN_150mA_WITH_LIGHTNING shall be protected against polarity inversion with a diode', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6118]'}, u'SSCS_ESSNESS_3002': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3003': {'status': u'\tMATURE', 'body': u'At power-up, when COLD_START signal is active,  A/C shall be considered on ground for 1.2s +/-10%.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_2322],\t[SDTS_PDS_7015]'}, u'SSCS_ESSNESS_3000': {'status': u'\tMATURE', 'body': u'The A/C shall be considered \u201con ground\u201d when both signals DSI_WOW_LHPPDB and DSI_WOW_RHPPDB indicate \u201con ground\u201d.\nElse A/C is in flight', 'additional': u'\t ', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_0760]'}, u'SSCS_ESSNESS_3001': {'status': u'\tMATURE', 'body': u'DSI_WOW_LHPPDB and DSI_WOW_RHPPDB, shall be confirmed for 7s +/-0,7s when A/C goes from ground to flight or when A/C goes from flight to ground.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_713]'}, u'SSCS_ESSNESS_5721': {'status': u'\tMATURE', 'body': u'The DSO_GND_OPEN_500mA_WITH/WITHOUT_LIGHTNING shall withstand a voltage of 80V for up to 100ms without functional impact', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThere\u2019s voltage transients on DC network', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5720': {'status': u'\tMATURE', 'body': u'The DSO_GND_OPEN_500mA_WITH/WITHOUT_LIGHTNING shall withstand a current surge up to 3 times the nominal current for 100ms without impact on the functionality', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tWhen The DC network suffers from voltage transients, the current sinked by DSO could be trippled', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3004': {'status': u'\tMATURE', 'body': u'WOW_MISMATCH shall be active when one at least of the following conditions is true:\nDSI_WOW_LHPPDB is flight AND DSI_WOW_RHPPDB is ground during 30s +/-300ms\nDSI_WOW_LHPPDB is ground AND DSI_WOW_RHPPDB is flight during 30s +/-300ms\nElse it is inactive.', 'additional': u'\tModified according SACR530', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7254],\t[SDTS_PDS_7255],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_5722': {'status': u'\tTBC', 'body': u'The DSO_28V_OPEN_150mA_WITH_LIGHTNING shall implement a current limitation to 150mA (-0 / +20mA TBC)', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_5038],\t[SDTS_PDS_5039]'}, u'SSCS_ESSNESS_9112': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9113': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9110': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9111': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9116': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9114': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9115': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2282': {'status': u'\tTBC', 'body': u'In case of NESS configuration, DSO_SHED_ENG_FAIL shall be deactivated when one at least of the following conditions is true:\n[DSI_BOOC_GPULC_STATUS is closed OR (ENG1_OFF is inactive AND ENG2_OFF is inactive)] during 10s +/-100ms TBC\nARINC_RX_FAIL is active', 'additional': u'\tModified according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_6520]'}, u'SSCS_ESSNESS_2281': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, DSO_SHED_ENG_FAIL shall be activated when all the following conditions are met\nENG1_OFF is active OR ENG2_OFF is active\nFLIGHT is active OR TAKE_OFF is active\nDSI_BOOC_GPULC_STATUS is open\nARINC_RX_FAIL is inactive', 'additional': u'\tModified according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_6520]'}, u'SSCS_ESSNESS_2280': {'status': u'\tMATURE', 'body': u'At power up, the signal DSO_SHED_ENG_FAIL shall be inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_163],\t[SDTS_PDS_6520]'}, u'SSCS_ESSNESS_7879': {'status': u'\tMATURE', 'body': u'In case of RESS configuration,the BITE microcontroller shall deactivate CBIT_SHP_CURRENT_CH1 when DSI_SHP_CABC_STATUS is open, and the ASI_HES2_CH1 is outside the following range [-30A; +30A] during 5s +/-50ms', 'additional': u'\tWhen contactor is open the current flowing through it is null, this test verifies the correct behaviour of HES', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7055],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_6313': {'status': u'\tMATURE', 'body': u'If the microcontroller type check is false, the microcontroller shall enter its default state.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE,\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define what to do if the microcontroller type check is false', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0151': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0150': {'status': u'\tMATURE', 'body': u'Driver of CONTACT_E shall be powered by 28V_E', 'additional': u'\t ', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_2622],\t[SDTS_PDS_2633],\t[SDTS_PDS_2647],\t[SDTS_PDS_2662]'}, u'SSCS_ESSNESS_0153': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0152': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0010': {'status': u'\tMATURE', 'body': u'In case of LESS configuration the FUNC microcontroller shall use the following logic levels in equations for contactors management:\nsignal name\nTRUE when\ncomments\nDSI_APUGLC_STATUS\nclosed\nDSI_BC_STATUS\nclosed\nDSI_BOOC_GPULC_STATUS\nclosed\nDSI_ESSTIED_RELAY_ATRC_OPP_STATUS\nclosed\nDSI_GLC_OPP_STATUS\nclosed\nDSI_GLC_STATUS\nclosed\nDSI_RATLC_SLC_OPP_STATUS\nclosed\nDSI_TAC_STATUS\nclosed\nDSI_TRC_STATUS\nclosed\nDSI_TSBC_STATUS\nclosed\nDSI_TRC_OPP_STATUS_CABC_SHED\nclosed\nDSI_HES_TRU_CURRENT_SLC_STATUS\nactive\nDSI_ISOLATION_SMOKE_GALLEY_CABIN_MASTER\nactive\nDSI_POWER_ON\nactive\nDSI_START_ACCEPTED_APUSLC_STATUS\nactive\nDSI_START_IN_PROGRESS\nactive\nDSI_TRC_CMD_SMC_RATLC_STATUS\nactive\nDSI_APU_START_REQUEST\nactive\nDSI_WOW_LHPPDB\nground\nDSI_WOW_RHPPDB\nground\nBAT_SW\nAUTO state\nBOOC_PROTECTION\nactive\nTC_PROTECTION\nactive\nxALTC1_PROTECTION\nactive\nxALTC1_HIGH_CURRENT\nactive\nMAIN_115VAC_NOMINAL\nactive\nALT_115VAC_NOMINAL\nactive\nSTBY_TRU_FAIL\nactive\nTIE_ALT_115VAC_FAULT\nactive\n28V_BAT_MIN\nactive\nBAT_MAINTENANCE\nactive\nCONTACT_A\nactive\nCONTACT_B\nactive\nCONTACT_D\nactive\nCONTACT_E\nactive', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tdefines active levels for contactor equations', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0011': {'status': u'\tMATURE', 'body': u'In case of RESS configuration the FUNC microcontroller shall use the following logic levels in equations for contactors management\nsignal name\nTRUE when\ncomments\nDSI_APUGLC_STATUS\nclosed\nDSI_SHP_CABC_STATUS\nclosed\nDSI_ESSTIED_RELAY_ATRC_OPP_STATUS\nclosed\nDSI_GLC_OPP_STATUS\nclosed\nDSI_GLC_STATUS\nclosed\nDSI_RATLC_SLC_OPP_STATUS\nclosed\nDSI_TAC_STATUS\nclosed\nDSI_TRC_STATUS\nclosed\nDSI_TSBC_STATUS\nclosed\nDSI_TRC_OPP_STATUS_CABC_SHED\nclosed\nDSI_START_IN_PROGRESS\nactive\nDSI_HES_TRU_CURRENT_SLC_STATUS\nactive\nDSI_ISOLATION_SMOKE_GALLEY_CABIN_MASTER\nactive\nDSI_POWER_ON\nactive\nDSI_EMP_B_CMD_HSCM_1_GALC\nactive\nDSI_EMP_B_CMD_HSCM_2_GALC_OPP\nactive\nDSI_TRC_CMD_SMC_RATLC_STATUS\nactive\nDSI_BACK_UP_PUMP_CABIN_CONV_GALLEY_CMD\nactive\nDSI_WOW_LHPPDB\nground\nDSI_WOW_RHPPDB\nground\nBAT_SW\nAUTO state\nSHP_PROTECTION\nactive\nTC_PROTECTION\nactive\nxALTC1_PROTECTION\nactive\nxALTC1_HIGH_CURRENT\nactive\nMAIN_115VAC_NOMINAL\nactive\nALT_115VAC_NOMINAL\nactive\nSTBY_TRU_FAIL\nactive\nTIE_ALT_115VAC_FAULT\nactive\n28V_BAT_MIN\nactive\nBAT_MAINTENANCE\nactive\nCONTACT_A\nactive\nCONTACT_B\nactive\nCONTACT_D\nactive\nCONTACT_E\nactive', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tdefines active levels for contactors equations', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0012': {'status': u'\tMATURE', 'body': u'In case of LNESS configuration the FUNC microcontroller shall use the following logic levels in equations for contactors management\nsignal name\nTRUE when\ncomments\nDSI_TAC_STATUS\nclosed\nDSI_TC_OPP_STATUS\nclosed\nDSI_TC_STATUS\nclosed\nDSI_TRC_STATUS\nclosed\nDSI_TSBC_STATUS\nclosed\nDSI_START_IN_PROGRESS\nactive\nDSI_TC_RESET_ATRC_STATUS\nclosed\nTRU_SW\nAUTO state\nCABIN_MASTER_SW\nOFF state\nCABIN_SW\nAUTO state\nCABC1_SHED\nactive\nMAIN_115VAC_NOMINAL\nactive\nMAIN_115VAC_PRESENCE\nactive\nNESS_MAIN_115VAC_FAULT\nactive\nALT_115VAC_NOMINAL\nactive\nHES_TRU_CH2_CURRENT\nactive\nSTBY_TRU_FAIL\nactive\nTIE_ALT_115VAC_FAULT\nactive\n28V_TRU_MIN\nactive\nCONTACT_A\nactive\nCONTACT_B\nactive\nCONTACT_D\nactive\nCONTACT_E\nactive\nGEN_SC\nactive\nGEN_OVL\nactive\nNESS_MAIN_115V_OVL\nactive', 'additional': u'\tModified according SACR439', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tdefines active levels for contactors equations', 'issue': u'\t5', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0013': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration the FUNC microcontroller shall use the following logic levels in equations for contactors management\nsignal name\nTRUE when\ncomments\nDSI_TAC_STATUS\nclosed\nDSI_TC_OPP_STATUS\nclosed\nDSI_TC_STATUS\nclosed\nDSI_TRC_STATUS\nclosed\nDSI_TSBC_STATUS\nclosed\nDSI_TC_RESET_ATRC_STATUS\nclosed\nDSI_APUGLC_STATUS\nclosed\nDSI_TRC_CMD_SMC_RATLC_STATUS\nclosed\nDSI_CAB_INV1_FAIL_AGCU_POWER_READY\nactive\nCABIN_MASTER_STATUS\nactive\nDSI_START_IN_PROGRESS\nactive\nTRU_SW\nAUTO state\nGALLEY_SW\nAUTO state\nGPU_AUTO\nON state\nCABC2_SHED\nactive\n28V_TRU_MIN\nactive\nHES_TRU_CH2_CURRENT\nactive\nMAIN_115VAC_NOMINAL\nactive\nMAIN_115VAC_PRESENCE\nactive\nNESS_MAIN_115VAC_FAULT\nactive\nALT_115VAC_NOMINAL\nactive\nALT_115VAC_PRESENCE\nactive\nSTBY_TRU_FAIL\nactive\nTIE_ALT_115VAC_FAULT\nactive\nCONTACT_A\nactive\nCONTACT_B\nactive\nCONTACT_C\nactive\nCONTACT_D\nactive\nCONTACT_E\nactive\nGEN_SC\nactive\nGEN_OVL\nactive\nNESS_MAIN_115V_OVL\nactive', 'additional': u'\tModified according SACR439 / SACR299', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tdefines active levels for contactors equations', 'issue': u'\t6', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7800': {'status': u'\tMATURE', 'body': u'When PBIT is done, the ESSNESS shall perform following CBIT:\nCBIT of DC area temperature sensors\nCBIT of BAT/TRU temperature sensors\nCBIT of BAT/TRU/SHP/CABC current sensors\nCBIT of FAN speed monitoring\nCBIT of PWM monitoring\nCBIT of battery type monitoring\nCBIT of CB matrix', 'additional': u'\tCBIT of voltage or current ac inputs cannot be defined because there is no maxi value for this inputs', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_539],\t[SDTS_PDS_514]'}, u'SSCS_ESSNESS_6052': {'status': u'\tMATURE', 'body': u'If any feedback control loops exists in PDS, their stabilities shall be demonstrated in the whole operating environment with at least a gain margin of 6 dB and a phase margin of 60\xb0.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_170]'}, u'SSCS_ESSNESS_3810': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6050': {'status': u'\tMATURE', 'body': u'If multiple source power supplies using OR diode are used, they shall be monitored to avoid dormant failure that will lead to loss of bus bar insulation.', 'additional': u'\t', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_172]'}, u'SSCS_ESSNESS_6051': {'status': u'\tMATURE', 'body': u'DSI are polarised with a 12V +/-1V voltage, and minimum polarisation current for DSI shall be 5 mA +/-0,5mA.', 'additional': u'\tSome signals have to be polarized with 50mA', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_169]'}, u'SSCS_ESSNESS_6056': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall be developed according Level B of .DO254 [39]', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tTRUE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_540],\t[SDTS_PDS_511]'}, u'SSCS_ESSNESS_6057': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall implement two microcontrollers\nFor functional purpose (called FUNC in the document)\nFor monitoring purpose (called BITE in the document)', 'additional': u'\tThe SDTS requirement has to be corrected', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_2075]'}, u'SSCS_ESSNESS_6054': {'status': u'\tMATURE', 'body': u'The DC voltage measurement accuracy shall be 1% up to 40 Vdc.', 'additional': u'\tBoard is designed with previous value of this requirement which was 5%', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_241]'}, u'SSCS_ESSNESS_6055': {'status': u'\tMATURE', 'body': u'The AC RMS voltage measurement accuracy including voltage divider shall be +/- 1,5 V up to 130 Vac in the whole frequency range', 'additional': u'\tBoard is designed with previous value of this requirement which was 5%', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_242]'}, u'SSCS_ESSNESS_6058': {'status': u'\tMATURE', 'body': u'Each microcontroller shall be programmable in situ or on shop through a dedicated ICSP bus. (The re-programming has to be possible when the ESSNESS board is mounted in the system).', 'additional': u'\tThe microcontrollers can be flashed through the programmation connector / in SDTS5d4 requirement is not compliant, so that this requirement is not compliant too', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_4040]'}, u'SSCS_ESSNESS_6059': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_1011': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, TRU_SW shall be in AUTO state if BAT_TRU_VALIDITY is inactive.', 'additional': u'\tBAT_TRU_VALIDITY is defined in \xa72.6.12', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tdefines the behaviour of TRU_SW in case of invalidity', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_1010': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, BAT_SW shall be in AUTO state if BAT_TRU_VALIDITY is inactive.', 'additional': u'\tBAT_TRU_VALIDITY is defined in \xa72.6.12', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tdefines the behaviour of BAT_SW in case of invalidity', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7885': {'status': u'\tMATURE', 'body': u'In case of LNESS configuration,the BITE microcontroller shall activate CBIT_CABC_CURRENT_CH1 when one of the following condition is true:\nAt board power up\nRisind edge on DSI_CABIN_MASTER_CMD', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7238]'}, u'SSCS_ESSNESS_6049': {'status': u'\tMATURE', 'body': u'Multiple source power supplies using OR diode shall be avoided.\nThe design of multiple source power supply has to be submitted to Dassault Aviation for "No technical objection"', 'additional': u'\t', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6153]'}, u'SSCS_ESSNESS_3222': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, the FUNC microcontroller shall read GPU_PhA and GPU_PhB.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tin order to be able to compute GPU frequency protection and /or GPU phase order protection', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3220': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall acquire and compute ASI_ALT_GPU_PHA in order to generate GPU_PhA, square signal with the same frequency.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tdefinition of square signal with same frequency as GPU phase A, in order to be able to compute GPU frequency protection and / or GPU phase order protection', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3221': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall acquire and compute ASI_ALT_GPU_PHB in order to generate GPU_PhB, square signal with the same frequency.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tdefinition of square signal with same frequency as GPU phase B, in order to be able to compute GPU frequency protection and /or GPU phase order protection', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2210': {'status': u'\tMATURE', 'body': u'In case of NESS board, at power up, the signal DSO_CABIN_AC_MASTER_GALLEY_MASTER shall be inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t ', 'issue': u'\t4', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_2211': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, the FUNC microcontroller shall activate DSO_CABIN_AC_MASTER_GALLEY_MASTER according following logic:\nDSO_CABIN_AC_MASTER_GALLEY_MASTER  is active when DSI_EMP_B_CMD_HSCM_1_GALC is closed\nDSO_CABIN_AC_MASTER_GALLEY_MASTER  is inactive when DSI_EMP_B_CMD_HSCM_1_GALC is open', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6002],\t[SDTS_PDS_6003]'}, u'SSCS_ESSNESS_3503': {'status': u'\tMATURE', 'body': u'In case of RESS or NESS configurations, the BITE and FUNC microcontrollers shall acquire ASI_HES2_CH1.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE,\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tHES2_CH1 corresponds to SHP(RESS) and CABC(NESS) current and is used for functional purpose', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2191': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, DSO_TRC_CMD shall be active when the following conditions is met:\nCONTACT_A is active\nelse it is inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_5076],\t[SDTS_PDS_5077]'}, u'SSCS_ESSNESS_2190': {'status': u'\tMATURE', 'body': u'At power up, the signal DSO_TRC_CMD shall be inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_3619': {'status': u'\tMATURE', 'body': u'In case of ESS or RNESS configuration, the BITE microcontroller shall acquire \nASI_CT2_PHA\nASI_CT2_PHB\nASI_CT2_PHC', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tCurrent measured by CT are used for functional purpose', 'issue': u'\t4', 'refer': 'EMPTY'}, u'ICD_SPI_ESSNESS_DATA_0089': {'issue': '1'}, u'SSCS_ESSNESS_3613': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3612': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3611': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3610': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3617': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, the BITE microcontroller shall compute GPU_CURRENT_MEAN as the mean of ASI_CT2_PHA and ASI_CT2_PHB and ASI_CT2_PHC averaged during 250ms +/-2,5ms.', 'additional': u'\tThose currents are sent on ARINC bus / modified according SACR530', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7013],\t[SDTS_PDS_8040],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_3616': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\tModified according SACR530', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t6', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3615': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3614': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7883': {'status': u'\tMATURE', 'body': u'At power-up CBIT_TRU_FAN shall be active.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define default value', 'issue': u'\t3', 'refer': 'EMPTY'}, u'ICD_SPI_203': {'status': u' \tMATURE', 'body': u'SPI master shall discard the received SPI frame in the following conditions:\nThe computed frame checksum does not match the embedded checksum value based on the frame CHECKSUM byte information.\nThe SPI protocol version received is not compliant with embedded master protocol version based on the first frame PROTOCOL ID bits information.\nThe SPI format version received is not compliant with embedded master format version based on the first frame FORMAT ID byte information.\nThe COUNTER number is equal to the previous received value.', 'additional': u' \tSee \xa7 3.3.1 for CHECKSUM explanation.', 'issue': u' \t2', 'derived': u' \tYES', 'allocation': u' \tESSNESS_BITE_SW, SDSIO_BITE_SW, TIE_BITE_SW', 'verification': u' \tTest', 'rationale': u' \tMaster has the protocol version embedded in its header and compares it with the one included in the received frame', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'ICD_SPI_202': {'status': u' \tMATURE', 'body': u'SPI master shall compute checksum on the received frame.', 'additional': u' \tSee \xa7 3.3.2 for checksum computation algorithm', 'issue': u' \t1', 'derived': u' \tYES', 'allocation': u' \tESSNESS_BITE_SW, SDSIO_BITE_SW, TIE_BITE_SW', 'verification': u' \tTest', 'rationale': u' \tData integrity justification', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'ICD_SPI_201': {'status': u' \tMATURE', 'body': u'Checksum shall be two\u2019s complement sum of all SPI words except the last frame byte (corresponding to embedded checksum value)', 'additional': u' \tSee \xa7 3.3.1for frame format explanation', 'issue': u' \t1', 'derived': u' \tYES', 'allocation': u' \tESSNESS_BITE_SW, ESSNESS_ENM_SW, SDSIO_BITE_SW, SDSIO_PLD, TIE_BITE_SW, TIE_PLD', 'verification': u' \tTest', 'rationale': u' \tData integrity justification', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5807': {'status': u'\tMATURE', 'body': u'The CONTACT_X_HO and the CONTACT_X_PU shall be protected against voltage transients due to inductance of the contactor\nWhere X corresponds to A,B,C,D and E', 'additional': u'\tImplementation of SACR127', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tTRUE', 'verification': u'\tInspection', 'rationale': u'\tAs there is no freewheeling diode on the inductances of the contactors, the board has to be protected against voltage transients', 'issue': u'\t4', 'refer': 'EMPTY'}, u'ICD_SPI_207': {'status': u' \tMATURE', 'body': u'SPI slave shall transmit the complete frame defined in SPI annex document [1], [2] and [3] respecting the given order.', 'additional': u' \t', 'issue': u' \t2', 'derived': u' \tYES', 'allocation': u' \tESSNESS_ENM_SW, SDSIO_PLD, TIE_PLD', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'ICD_SPI_206': {'status': u' \tMATURE', 'body': u'Checksum additions shall be done SPI word-wide overflow ignored.', 'additional': u' \tSee \xa7 3.3.1for frame format explanation', 'issue': u' \t1', 'derived': u' \tYES', 'allocation': u' \tESSNESS_BITE_SW, ESSNESS_ENM_SW, SDSIO_BITE_SW, SDSIO_PLD, TIE_BITE_SW, TIE_PLD', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'ICD_SPI_205': {'status': u' \tMATURE', 'body': u'Frame format shall be as follows:\n15\nMSB\n14\n13\n12\n11\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n0\nLSB\nSPI WORD 1\nCTRL\nSPARE\nFORMAT ID\nPROTOCOL ID\n...\nCTRL\nSPARE\nSPI DATA\nSPI WORD n\nCTRL\nSPARE\nCOUNTER \nCHECKSUM \nTable 6 : Frame format\nCONTROL bits: \n10 if first SPI frame word\n00 if neither first nor last SPI frame word \n01 if last SPI frame word\nFORMAT ID bits:\nCorresponds to the issue of the SPI data document [1], [2] and [3] according to the board and coded in hexadecimal on a major modification (the columns concerned are : modification of SPI word number, position (MSB/LSB), Info type, Info Attribute#1, Info Attribute#2, coding type, SSCS name, Periodicity and board configuration)\nPROTOCOL ID bits:\nCorresponds to the issue of this document (SPI) and coded in hexadecimal (ex: document: issue 1 / PROTOCOL ID: 0x1) on a major modification (when the modification of a requirement impacts implementation)\nSPI DATA bits:\ndefined in the SPI annex document [1], [2] and [3] \nthe unused SPI data are forced to 0\nCOUNTER bits:\nSet to 0 at first transmission\nIncrease by one at every other frame transmission\nRestart from 0 when max value reached\nCHECKSUM byte:\nfor checksum computation refer to \xa7 3.3.2\nSPARE bit:\nSee SPI data document [1], [2] and [3] for value', 'additional': u' \tSee \xa7 3.3.2 for checksum computation algorithm', 'issue': u' \t2', 'derived': u' \tYES', 'allocation': u' \tESSNESS_BITE_SW, ESSNESS_ENM_SW, SDSIO_BITE_SW, SDSIO_PLD, TIE_BITE_SW, TIE_PLD', 'verification': u' \tTest', 'rationale': u' \tCOUNTER information enables to check that the SPI data has been updated, therefore the COUNTER value should be different from one transmission to another. ', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'ICD_SPI_204': {'status': u' \tMATURE', 'body': u'SPI slave shall update the SPI data respecting the defined format and frequencies (SPI annex document [1], [2] and [3]).', 'additional': u' \tStart up for corresponds to power on sequence for PLD and real time launch for software.', 'issue': u' \t1', 'derived': u' \tYES', 'allocation': u' \tESSNESS_ENM_SW, SDSIO_PLD, TIE_PLD', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2100': {'status': u'\tMATURE', 'body': u'In case of NESS board, at power up, the signal DSO_MASTER_SHED_OFF_LT shall be inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_163]'}, u'ICD_SPI_209': {'status': u' \tMATURE', 'body': u'The INT and REAL data type shall be encoded in two consecutive SPI words of 8 bits each, least significant byte first, if the data overflows the SPI word max number of bits.', 'additional': u' \t', 'issue': u' \t2', 'derived': u' \tYES', 'allocation': u' \tSDSIO_PLD, TIE_BITE_SW, TIE_PLD', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'ICD_SPI_208': {'status': u' \tMATURE', 'body': u'SPI master shall decode the SPI data respecting the defined format and frequencies (SPI annex document [1], [2] and [3]).', 'additional': u' \t', 'issue': u' \t2', 'derived': u' \tYES', 'allocation': u' \tESSNESS_BITE_SW, SDSIO_BITE_SW, TIE_BITE_SW', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4607': {'status': u'\tTBC', 'body': u'In case of LNESS configuration, when the label [LabelNumber] which b9b10 is 00, SDI of the corresponding label, is not received since more than 200ms +/-20ms TBC, LabelReceived_[LabelNumber] shall be set inactive\nWhere [LabelNumber] is 54, 55, 56 or 74', 'additional': u'\tAdded according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_8067]'}, u'SSCS_ESSNESS_2062': {'status': u'\tMATURE', 'body': u'In case of NESS board, the DSO_BAT_TRU_LT shall be active when TRU_SW is OFF state\nElse it is inactive.', 'additional': u'\tTRU_SW states are defined in \xa72.4.2', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_689],\t[SDTS_PDS_690]'}, u'SSCS_ESSNESS_2061': {'status': u'\tMATURE', 'body': u'In case of ESS board, the DSO_BAT_TRU_LT shall be active when BAT_SW is OFF state,\nElse it is inactive.', 'additional': u'\tBAT_SW states are defined in \xa72.4.1,\tIn case of LESS board, during APU_START, the CONTACT_A (BC1) is open in order to power the SBU by BAT1. However the BC_STATUS (BC1_STATUS) is open, the indicator doesn\u2019t display OFF.', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_683],\t[SDTS_PDS_684]'}, u'SSCS_ESSNESS_2060': {'status': u'\tMATURE', 'body': u'At power up, the signal DSO_BAT_TRU_LT shall be inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_4601': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, FUNC microcontroller shall read [Label number] as the eight first bits of the ARINC word, coded in octal (MSB is the first bit)', 'additional': u'\tAdded according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_8064]'}, u'SSCS_ESSNESS_2161': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, DSO_SHED_START shall be active when one of the following conditions is true:\nDSI_START_IN_PROGRESS is active\nDuring 30s +/-30ms after DSI_START_IN_PROGRESS becomes inactive\nElse it is inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_5050],\t[SDTS_PDS_5051],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_4600': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\tDeleted according SACR809', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t7', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4603': {'status': u'\tMATURE', 'body': u'In case of LNESS configuration, LabelReceived_[LabelNumber] is set to active when all the following conditions are true:\nthe label [LabelNumber].is received\nb9b10 of the label [LabelNumber] is 00\nThe parity of label [LabelNumber] is odd (i.e. the number of bit with the value (1) in the whole word is odd)\nWhere [LabelNumber] is 54, 55, 56, 73 or 74', 'additional': u'\tAdded according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_8064],\t[SDTS_PDS_8071],\t[SDTS_PDS_8070]'}, u'SSCS_ESSNESS_4602': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, at power-up LabelReceived_[LabelNumber] is set to inactive.\nWhere [LabelNumber] is 54, 55, 56, 73 or 74', 'additional': u'\tAdded according SACR809', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define the value of LabelReceived_[LabelNumber] at power -up', 'issue': u'\t7', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4049': {'status': u'\tMATURE', 'body': u'The ESSNESS power consumption shall be lower than 500mA in the here above defined voltage range.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tPower estimate', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3950': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall perform a continuity test (open wire or shorted wire) for the DSI_BAT_TRU_SW, if  the wire is open or shorted, the BAT_TRU_SW_ERROR is active.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_2026]'}, u'SSCS_ESSNESS_3951': {'status': u'\tMATURE', 'body': u'If BAT_TRU_SW_ERROR is inactive AND BF_ALIM_28V is active, BAT_TRU_VALIDITY shall be active, else it is inactive.', 'additional': u'\tmodified according SyCR19', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7134]'}, u'SSCS_ESSNESS_3952': {'status': u'\tMATURE', 'body': u'FUNC microcontroller shall read BF_ALIM_28V.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define source of BF_ALIM_28V signal', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7207': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t3', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7200': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t3', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7201': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall be designed to be fully compliant in the temperature range [-40\xb0C; 85\xb0C]', 'additional': u'\tQualification test at system level \u2013 Verification test at product level for risk mitigation purpose.,\t70\xb0C is specified for system + 15\xb0C for increasing temperature in the equipement', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_2171]'}, u'SSCS_ESSNESS_4504': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall implement one ARINC 429 receiver channel .', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_4011]'}, u'SSCS_ESSNESS_7203': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall be able to start and operate at -55\xb0C during 30 min.', 'additional': u'\tQualification test at system level \u2013 Verification test at product level for risk mitigation purpose', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_1003]'}, u'SSCS_ESSNESS_4623': {'status': u'\tMATURE', 'body': u'In case of NESS configurations, at power-up, TAKE_OFF shall be inactive.', 'additional': u'\tAdded according SACR809', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define TAKE_OFF at power-up', 'issue': u'\t7', 'refer': 'EMPTY'}, u'ICD_SPI_ESSNESS_DATA_0049': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0048': {'issue': '2'}, u'ICD_SPI_ESSNESS_DATA_0043': {'issue': '2'}, u'ICD_SPI_ESSNESS_DATA_0042': {'issue': '2'}, u'ICD_SPI_ESSNESS_DATA_0041': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0040': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0047': {'issue': '3'}, u'ICD_SPI_ESSNESS_DATA_0046': {'issue': '3'}, u'ICD_SPI_ESSNESS_DATA_0045': {'issue': '3'}, u'ICD_SPI_ESSNESS_DATA_0044': {'issue': '3'}, u'SSCS_ESSNESS_4505': {'status': u'\tMATURE', 'body': u'ARINC 429 signals shall be full compliant with [42] (receiver and transmitter)', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to assure that ARINC busses respect the norm', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_8012': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7306': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t3', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9013': {'status': u'\tMATURE', 'body': u'In case of RNESS board configuration, the contactor CONTACT_B (GALC2 contactor) shall be managed according to the following diagram:', 'additional': u'\tModified according SyCR17 / SyCR28 / SACR533', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7205]'}, u'SSCS_ESSNESS_9012': {'status': u'\tMATURE', 'body': u'In case of LNESS board configuration, the contactor CONTACT_B (GALC1 contactor) shall be managed according to the following diagram:', 'additional': u'\tModified according SyCR17 / SyCR28 / SACR533', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7206]'}, u'SSCS_ESSNESS_9011': {'status': u'\tMATURE', 'body': u'In case of RESS board configuration, the contactor CONTACT_B (TC2 contactor) shall be managed according following diagram:', 'additional': u'\tSSCS_ESSNESS_9011 is compliant with the correction,\tmodified according SyCR17,\tmodified according SyCR31', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7196]'}, u'SSCS_ESSNESS_9010': {'status': u'\tMATURE', 'body': u'In case of LESS board configuration, the contactor CONTACT_B (TC1 contactor) shall be managed according following diagram:', 'additional': u'\tSSCS_ESSNESS_9010 is compliant with this correction,\tmodified according SyCR17', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7195]'}, u'SSCS_ESSNESS_4515': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4514': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4517': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4516': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4511': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4510': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4513': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, the ESSNESS board shall transmit to avionic through the ARINC bus data described in GS3058- EPDS and Avionic Communication ICD [3]', 'additional': u'\t', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_007],\t[SDTS_PDS_008],\t[SDTS_PDS_006]'}, u'SSCS_ESSNESS_4512': {'status': u'\tMATURE', 'body': u'The data sent on ARINC bus and generated by FUNC microcontroller shall be sent to BITE microcontroller through SPI bus.', 'additional': u'\tThis requirement will probably be rewritten when ARINC ICD will be finished.', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE,\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tIn order to assure that BITE microcontroller has all needed data to elaborate ARINC words.', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2004': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, the signal DSO_ESS_TRU_STATUS is a PWM signal, it shall be managed as following:\nWhen TC_OVL_UV is inactive AND BAT_HIGH_CURRENT is inactive AND BAT overload protection is inactive, frequency 1KHz +/-10Hz, duty cycle 8% +/-1% (or 92% +/-1%)\nWhen TC_OVL_UV is inactive AND BAT_HIGH_CURRENT is active AND BAT overload protection is inactive, frequency 1KHz +/-10Hz, duty cycle 16% +/-1% (or 84% +/-1%)\nWhen TC_OVL_UV is inactive AND BAT overload protection is active, frequency 1KHz +/-10Hz, duty cycle 24% +/-1% (or 76% +/-1%)\nWhen TC_OVL_UV is active AND BAT_HIGH_CURRENT is inactive AND BAT overload protection is inactive, frequency 1KHz +/-10Hz, duty cycle 32% +/-1% (or 68% +/-1%)\nWhen TC_OVL_UV is active AND BAT_HIGH_CURRENT is active AND BAT overload protection is inactive, frequency 1KHz +/-10Hz, duty cycle 40% +/-1% (or 60% +/-1%)\nWhen TC_OVL_UV is active AND BAT overload protection is active, frequency 1KHz +/-10Hz, duty cycle 48% +/-1% (or 52% +/-1%)', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7132]'}, u'SSCS_ESSNESS_6067': {'status': u'\tMATURE', 'body': u'The uploading shall be performed when A/C is unpowered, Uploading tools provides power.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_2620]'}, u'SSCS_ESSNESS_0700': {'status': u'\tMATURE', 'body': u'In case of RESS configuration, the following SHP protections shall be latched to avoid cycling:\nSHP overload protection\nSHP driver fail protection', 'additional': u'\tThe latch of protections means that if a protection is not reset it will be memorised until the next power down ', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_305]'}, u'SSCS_ESSNESS_0701': {'status': u'\tMATURE', 'body': u'In case of RESS configuration, SHP protections shall be set to inactive when one at least of the following conditions is true:\nAt power-up of the board\nDSI_BACK_UP_PUMP_CABIN_CONV_GALLEY_CMD goes from inactive to active state.\nDSI_RATLC_SLC_OPP_STATUS is closed AND A/C is in flight\nConcerned SHP protections are:\nSHP overload protection\nSHP driver fail protection', 'additional': u'\tModified according SACR439', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_2154]'}, u'SSCS_ESSNESS_0702': {'status': u'\tTBC', 'body': u'In case of RESS configuration, SHP overload protection shall be activated when accumulated calibrated current flowing through SHP (ASI_HES2_CH1) is between the Must Hold Line and the Must Trip Line defined hereafter\nRated to 200A\nMust Hold Line correspond to an I\xb2t curve with following parameters:\nIsat = 1000A tsat = 110ms Ithreshold = 230A TBC\nMust Trip Line corresponds to an I\xb2t curve with following parameters:\nIsat = 1000A tsat = 560ms Ithreshold = 282A TBC', 'additional': u'\tSee \xa73.6.2 for SHP current monitoring,\tHES of SHP can measure a maximum current of 1000A,\tTsat are 40ms shorter than the figure in order to assume system response time', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_304]'}, u'SSCS_ESSNESS_0703': {'status': u'\tTBC', 'body': u'In case of RESS configuration, SHP overload protection shall be inhibited when one at least of the following conditions is met:\nDuring 150ms +/-5ms [TBC] after DSI_SHP_CABC_STATUS goes from open to closed\nDSI_RATLC_SLC_OPP_STATUS is closed\nSHP_CURRENT_CH1_VALID is inactive and A/C is in flight', 'additional': u'\t1% delay tolerance cannot be achieve due to 5ms minimum microcontroller response time', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_2106],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_0704': {'status': u'\tMATURE', 'body': u'In case of RESS configuration, SHP_PROTECTION shall be activated when one at least of the following conditions is TRUE:\nSHP overload protection is active\nSHP driver fail protection is active\nElse it is inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_EQUAT_407]'}, u'SSCS_ESSNESS_0705': {'status': u'\tMATURE', 'body': u'In case of RESS configuration, SHP driver fail protection shall be activated when CONTACT_D_TRIP is active and 28V_D is over 18,5V +/-0,5V', 'additional': u'\tmodified according SyCR17 / SACR258', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7121],\t[SDTS_PDS_8007],\t[SDTS_PDS_8008]'}, u'SSCS_ESSNESS_8023': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4503': {'status': u'\tMATURE', 'body': u'The FUNC microcontroller shall manage the receiver of ARINC429 in low speed.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware,\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_4011],\t[SDTS_PDS_2075]'}, u'SSCS_ESSNESS_9131': {'status': u'\tMATURE', 'body': u'When DSI_TSBC_OVL was active once, if its frequency is out of the range [950Hz, 1.050KHz], failure CBIT_TSBC_OVL_FAIL shall be activated and TSBC_OVL_IN_PROGRESS and TSBC_HIGH_CURRENT are inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7214],\t[SDTS_PDS_7161],\t[SDTS_PDS_7045],\t[SDTS_PDS_7046]'}, u'SSCS_ESSNESS_0119': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0118': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3918': {'status': u'\tMATURE', 'body': u'The BITE microcontroller shall compute MAIN_115_DISP according following rule:\nIf the MAIN_115_MEAN is under 112V, the computed value of AC voltage measurement is:\nMAIN_115_DISP = 114/112* MAIN_115_MEAN\nElse if the MAIN_115_MEAN is over 112V and under 118V, the computed value of AC voltage measurement is:\nMAIN_115_DISP = 114+ 2/6*( MAIN_115_MEAN -112)\nElse\nMAIN_115_DISP = 116+ 14/12*( MAIN_115_MEAN -118)', 'additional': u'\tModified according SACR530', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7008]'}, u'SSCS_ESSNESS_0117': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, the contactor CONTACT_A shall be controlled by FUNC microcontroller when DSI_BC_Bypass is inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_143],\t[SDTS_PDS_150]'}, u'SSCS_ESSNESS_0116': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, the contactor CONTACT_A shall be active (closed) when DSI_BC_Bypass is active', 'additional': u'\tThe BC contactors are driven by FUNC \xb5C or manually controlled by BC_Bypass_cmd', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_143],\t[SDTS_PDS_150]'}, u'SSCS_ESSNESS_9150': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, when DSI_TRU_OVL_GEN_OVL_SC was active once, the failure FUNC_TRU_OVL_FAIL shall be activated if one at least of the following condition is true:\nDSI_TRU_OVL_GEN_OVL_SC frequency is out of the range [950,1050Hz]\nduty cycle of DSI_TRU_OVL_GEN_OVL_SC is out of following ranges:\n15% +/-3%, 30% +/-3%, 45% +/-3%, 55% +/-3%, 70% +/-3%, 85% +/-3%\nElse it is inactive\n ', 'additional': u'\tModified according SACR291', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_7049],\t[SDTS_PDS_7052]'}, u'SSCS_ESSNESS_0110': {'status': u'\tMATURE', 'body': u'Driver of CONTACT_A shall be powered by 28V_A.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_144],\t[SDTS_PDS_151],\t[SDTS_PDS_129],\t[SDTS_PDS_130]'}, u'SSCS_ESSNESS_3919': {'status': u'\tTBC', 'body': u'In case of ESS configuration, the FUNC microcontroller shall activate ALT_115VAC_NOMINAL when all the following conditions are true:\nASI_ALT_GPU_PHA is over 100Vrms [0, +10V] TBC\nASI_ALT_GPU_PHB is over 100Vrms [0, +10V] TBC\nASI_ALT_GPU_PHC is over 100Vrms [0, +10V] TBC\nElse it is inactive', 'additional': u'\t', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7233]'}, u'SSCS_ESSNESS_6066': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall implement a simplex SPI bus between FUNC and BITE microcontroller.', 'additional': u'\tThis bus is chosen simplex (FUNC to BITE) in order to be able to reduce the development DAL of BITE microcontroller', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tThis bus allow to transmit data from FUNC to BITE', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7844': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4500': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall implement one ARINC 429 transmitter channel .', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_005]'}, u'SSCS_ESSNESS_3502': {'status': u'\tMATURE', 'body': u'The BITE and FUNC microcontrollers shall acquire ASI_HES1_CH2.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE,\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tHES1_CH2 corresponds to BAT and TRU current and is used for functional purpose', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3915': {'status': u'\tTBC', 'body': u'The FUNC microcontroller shall activate MAIN_115VAC_NOMINAL when all the following conditions are true:\nASI_MAIN_115_PHA is over 100Vrms [0, +10V] TBC\nASI_MAIN_115_PHB is over 100Vrms [0, +10V] TBC\nASI_MAIN_115_PHC is over 100Vrms [0, +10V] TBC\nElse it is inactive', 'additional': u'\t', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7233],\t[SDTS_PDS_7234]'}, u'SSCS_ESSNESS_9998': {'status': u'\tMATURE', 'body': u'The P/N of the ESSNESS board shall be modify in case of any change (hardware or software).\nNote: Hardware version and Software version are part of the P/N.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\t', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_CHA_160]'}, u'SSCS_ESSNESS_7846': {'status': u'\tDEL', 'body': u'DELETED.', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3917': {'status': u'\tMATURE', 'body': u'The BITE microcontroller shall compute MAIN_115_MEAN as the mean of ASI_MAIN_115_PHA and ASI_MAIN_115_PHB and ASI_MAIN_115_PHC averaged during 250ms +/-2,5ms\nElse it is inactive', 'additional': u'\tThose voltages are sent on ARINC bus / Modified according SACR530', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7007],\t[SDTS_PDS_8037],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_7843': {'status': u'\tTBC', 'body': u'If the ASI_BAT_TRU_TEMP_B is outside the functional range [-55\xb0C; 180\xb0C] TBC, the FUNC microcontroller shall deactivate BAT_TRU_TEMP_B_VALID, else it is active.', 'additional': u'\tSee \xa73.4.1.2 for CAN ICD', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tDefinition of CBIT of temperature sensor', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_8025': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4501': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, the BITE microcontroller shall manage the transmitter channel of ARINC429 in high speed. ', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_005],\t[SDTS_PDS_2075]'}, u'SSCS_ESSNESS_7840': {'status': u'\tTBC', 'body': u'If the ASI_BAT_TRU_TEMP_A is outside the functional range [-55\xb0C; 180\xb0C] TBC, the BITE microcontroller shall deactivate CBIT_BAT_TRU_TEMP_A, else it is active.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tDefinition of CBIT of temperature sensor', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4058': {'status': u'\tMATURE', 'body': u'The transparency time of the ESSNESS board shall be at least 25ms at 16V', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_5045]'}, u'SSCS_ESSNESS_4059': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7875': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration,the FUNC microcontroller shall activate CABC_CURRENT_CH1_VALID when one of the following condition is true:\nAt board power up\nRisind edge on CABIN_MASTER_STATUS', 'additional': u'\tModified according SACR299', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7239]'}, u'SSCS_ESSNESS_7841': {'status': u'\tTBC', 'body': u'If the ASI_BAT_TRU_TEMP_A is outside the functional range [-55\xb0C; 180\xb0C] TBC, the FUNC microcontroller shall deactivate BAT_TRU_TEMP_A_VALID else it is active.', 'additional': u'\tSee \xa73.4.1.2 for CAN ICD', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tDefinition of CBIT of temperature sensor', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7873': {'status': u'\tMATURE', 'body': u'In case of RESS configuration,the FUNC microcontroller shall deactivate SHP_CURRENT_CH1_VALID when DSI_SHP_CABC_STATUS is open, and the ASI_HES2_CH1 is outside the following range [-30A; +30A] during 5s +/-50ms', 'additional': u'\tWhen contactor is open the current flowing through it is null, this test verifies the correct behaviour of HES', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7055],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_7872': {'status': u'\tMATURE', 'body': u'In case of RESS configuration,the FUNC microcontroller shall activate SHP_CURRENT_CH1_VALID when one of the following condition is true:\nAt board power up\nRisind edge on DSI_BACK_UP_PUMP_CABIN_CONV_GALLEY_CMD', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7055]'}, u'SSCS_ESSNESS_7871': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7870': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4050': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall generate its own power supplies for internal circuitry,(5V, -5V, 3V3, 12V)', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tESSNESS board gets 28V from system, and is in charge of generating its own internal supplies', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4051': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall have 5 Ground references: \n28V_RETURN for power supply (primary)\nMECHANICAL_GND\nGND Signal for analog, discrete and digital signals (secondary)\n115Vac neutral reference for AC voltage measurement\nAnalog reference for DC voltage measurement', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_4074],\t[SDTS_PDS_6305]'}, u'SSCS_ESSNESS_4052': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall provide power supplies for two HES.\nSignal name\n12V_HES1_CH1\n12V wire for power supply of HES1 channel 1\nGND_HES1_CH1\n0V wire for power supply of HES1 channel 1\n12V_HES1_CH2\n12V wire for power supply of HES1 channel 2\nGND_HES1_CH2\n0V wire for power supply of HES1 channel 2\n12V_HES2_CH1\n12V wire for power supply of HES2 channel 1\nGND_HES2_CH1\n0V wire for power supply of HES2 channel 1\nTable 5: HES power supply interface', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_516],\t[SDTS_PDS_382]'}, u'SSCS_ESSNESS_4053': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall provide a 12V power supply for HES between 11Vdc to 15 Vdc.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_517],\t[SDTS_PDS_383]'}, u'SSCS_ESSNESS_4054': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4055': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4056': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4057': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall withstand a permanent 80V (-1V,0) on 28V_3.', 'additional': u'\t', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_0460]'}, u'SSCS_ESSNESS_0205': {'status': u'\tTBC', 'body': u'In case of ESS configuration, BAT reverse protection shall be activated when BAT_CURRENT is below :\n\t-500A +/-20A TBC during 2s +/-20ms\n\tor -50A +/-1,5A during 2min +/-1,2s, when A/C is in flight', 'additional': u'\tBattery current is monitoring by Hall Effect Sensor see \xa72.6.6 / A/C in flight is defined in 2.6.1Tolerances in current are defined as the tolerance of the HES and 1% of the full scale for the board', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_146],\t[SDTS_PDS_153],\t[SDTS_PDS_7014],\t[SDTS_PDS_7009]'}, u'SSCS_ESSNESS_0204': {'status': u'\tMATURE', 'body': u'In case of LESS configuration, BAT overload protection shall be inhibited when contactor DSI_BOOC_GPULC_STATUS is closed', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_2014]'}, u'SSCS_ESSNESS_0207': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0206': {'status': u'\tTBC', 'body': u'In case of ESS configuration, BAT deep discharge protection shall be activated when all the following conditions are met:\nDSI_BC_STATUS is closed\nA/C is on ground\nDSI_POWER_ON is active\nASI_28V_BAT_TRU_MON voltage is below 19V[+0;-1V]TBC for more than 10s +/-100ms', 'additional': u'\tA/C on ground is described in \xa72.6.1 / Modified according SACR528', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_4061],\t[SDTS_PDS_2152],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_0201': {'status': u'\tMATURE', 'body': u'In case of ESS configurations, BAT protections shall be set to inactive when BAT_SW enters AUTO state.\nConcerned BAT protections are:\nBAT overload protection\nBAT reverse protection\nBAT deep discharge protection\nBAT driver fail protection', 'additional': u'\tBAT_SW states are defined in \xa72.4.1 / Modified according SACR439', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_149],\t[SDTS_PDS_156]'}, u'SSCS_ESSNESS_0200': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, BAT protections shall be latched to avoid cycling.\nConcerned BAT protections are:\nBAT overload protection\nBAT reverse protection\nBAT deep discharge protection\nBAT driver fail protection', 'additional': u'\tThe latch of protections means that if a protection is not reset it will be memorised until the next power down ', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_148],\t[SDTS_PDS_155]'}, u'SSCS_ESSNESS_0202': {'status': u'\tTBC', 'body': u'In case of ESS configuration, BAT overload protection shall be activated when BAT_CURRENT is above following current threshold during more than the defined delay:\ndelay\ncurrent threshold\n5ms ]-5ms,+0] TBC\n900 A +/-60A TBC\n3,96s +/-40ms\n420 A+/- 30A TBC\n119,96s +/-1,2s\n350 A +/-20A TBC\n299,96s +/- 3s\n245 A +/-20A TBC', 'additional': u'\tBattery current is monitoring by Hall Effect Sensor see \xa72.6.6,\tThe SDTS doesn\u2019t take into account the response time of the system => that\u2019s why delay in this requirement are 40ms shorter than delay in SDTSi5,\tResponse time of the microcontroller cannot be shorter than 5ms, this requirement is not compliant with SDTS_PDS_7014,\tTolerances in current are defined as the tolerance of the HES and 1% of the full scale for the board', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_145],\t[SDTS_PDS_152],\t[SDTS_PDS_7014],\t[SDTS_PDS_7009]'}, u'SSCS_ESSNESS_3925': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, the FUNC microcontroller shall compute GPU_115VAC_MEAN as the sum of ASI_ALT_GPU_PHA, ASI_ALT_GPU_PHB and ASI_ALT_GPU_PHC divided by three.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to be able to send this data on the SPI bus', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_8024': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7845': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0209': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0208': {'status': u'\tDEL', 'body': u'DELETED.', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2132': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, DSO_AFT_WATER_HEATER_AUTHORISED shall be active when all following conditions are true:\nCABIN_MASTER_STATUS is active\nMAIN_115VAC_NOMINAL is active\nDSI_START_IN_PROGRESS is inactive\nDSO_SHED_ENG_FAIL is inactive\nElse it is inactive.', 'additional': u'\tmodified according SyCR17 / SACR299', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7245]'}, u'SSCS_ESSNESS_3618': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\tModified according SACR530', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t6', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0809': {'status': u'\tTBC', 'body': u'In case of RNESS board, CABC2_AUTO_SHED shall be deactivated when all the following conditions are true:\nCABC overload protection is inactive (see \xa72.3.7)\nTSBC_OVL_IN_PROGRESS is inactive or DSI_TC_STATUS is open\nTRU_OVL_IN_PROGRESS is inactive\nNESS_MAIN_115VAC_FAULT is inactive\nTIE_ALT_115VAC_FAULT is inactive or DSI_TAC_STATUS is open\nSTBY_TRU_TEMP below 100\xb0C or STBY_TRU_FAN_FAIL is active or DSI_TSBC_STATUS is open or DSI_TC_STATUS is open\nSTBY_TRU_TEMP below 80\xb0C or STBY_TRU_FAN_FAIL is inactive or DSI_TSBC_STATUS is open or DSI_TC_STATUS is open\nBAT_TRU_TEMP below 100 +/- 10\xb0C TBC OR FUNC_TRU_FAN_FAILURE is active OR DSI_TRC_STATUS is open\nBAT_TRU_TEMP below 80 +/- 10\xb0C TBC OR FUNC_TRU_FAN_FAILURE is inactive OR DSI_TRC_STATUS is open\nASI_DC_AREA_TEMP below 140 +/- 10\xb0C TBC (see \xa72.6.2)\nCABIN_MASTER_STATUS switches from inactive to active', 'additional': u'\tthe condition on CABIN_MASTER_SW is on rising edge, if this condition becomes true whereas one of the other condition is still false CABC_AUTO_SHED will not be deactivated even after this condition becomes true,\tModified according SACR809,\tModified according SACR299', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_7130]'}, u'SSCS_ESSNESS_0807': {'status': u'\tTBC', 'body': u'In case of RNESS board, CABC2_AUTO_SHED shall be activated when at least one of following conditions is met:\nCABC overload protection is active (see \xa72.3.7)\nTSBC_OVL_IN_PROGRESS is active and DSI_TC_STATUS is closed\nTRU_OVL_IN_PROGRESS is active\nNESS_MAIN_115VAC_FAULT is active\nTIE_ALT_115VAC_FAULT is active and DSI_TAC_STATUS is closed\nSTBY_TRU_TEMP above 110\xb0C and STBY_TRU_FAN_FAIL is inactive and DSI_TSBC_STATUS is closed and DSI_TC_STATUS is closed\nSTBY_TRU_TEMP above 90\xb0C and STBY_TRU_FAN_FAIL is active and DSI_TSBC_STATUS is closed and DSI_TC_STATUS is closed\nBAT_TRU_TEMP above 110 +/- 10\xb0C TBC and FUNC_TRU_FAN_FAILURE is inactive and DSI_TRC_STATUS is closed\nBAT_TRU_TEMP above 90 +/- 10\xb0C TBC and FUNC_TRU_FAN_FAILURE is active and DSI_TRC_STATUS is closed\nASI_DC_AREA_TEMP above 150 +/- 10\xb0C TBC (see \xa72.6.2)', 'additional': u'\tModified according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_7129]'}, u'SSCS_ESSNESS_0806': {'status': u'\tTBC', 'body': u'In case of LNESS board, CABC1_AUTO_SHED shall be deactivated when all the following conditions are true:\nCABC overload protection is inactive (see \xa72.3.7)\nTSBC_OVL_IN_PROGRESS is inactive or DSI_TC_STATUS is open\nTRU_OVL_IN_PROGRESS is inactive\nNESS_MAIN_115VAC_FAULT is inactive\nTIE_ALT_115VAC_FAULT is inactive or DSI_TAC_STATUS is open\nSTBY_TRU_TEMP below 100\xb0C or STBY_TRU_FAN_FAIL is active or DSI_TSBC_STATUS is open or DSI_TC_STATUS is open\nSTBY_TRU_TEMP below 80\xb0C or STBY_TRU_FAN_FAIL is inactive or DSI_TSBC_STATUS is open or DSI_TC_STATUS is open\nBAT_TRU_TEMP below 100 +/- 10\xb0C TBC OR FUNC_TRU_FAN_FAILURE is active OR DSI_TRC_STATUS is open\nBAT_TRU_TEMP below 80 +/- 10\xb0C TBC OR FUNC_TRU_FAN_FAILURE is inactive OR DSI_TRC_STATUS is open\nASI_DC_AREA_TEMP below 140 +/- 10\xb0C TBC (see \xa72.6.2)\nCABIN_MASTER_SW enters AUTO state', 'additional': u'\tthe condition on CABIN_MASTER_SW is on rising edge, if this condition becomes true whereas one of the other condition is still false CABC_AUTO_SHED will not be deactivated even after this condition becomes true,\tModified according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_7127]'}, u'SSCS_ESSNESS_0805': {'status': u'\tTBC', 'body': u'In case of LNESS board, CABC1_AUTO_SHED shall be activated when at least one of following conditions is met:\nCABC overload protection is active (see \xa72.3.7)\nTSBC_OVL_IN_PROGRESS is active and DSI_TC_STATUS is closed\nTRU_OVL_IN_PROGRESS is active\nNESS_MAIN_115VAC_FAULT is active\nTIE_ALT_115VAC_FAULT is active and DSI_TAC_STATUS is closed\nSTBY_TRU_TEMP above 110\xb0C and STBY_TRU_FAN_FAIL is inactive and DSI_TSBC_STATUS is closed and DSI_TC_STATUS is closed\nSTBY_TRU_TEMP above 90\xb0C and STBY_TRU_FAN_FAIL is active and DSI_TSBC_STATUS is closed and DSI_TC_STATUS is closed\nBAT_TRU_TEMP above 110 +/- 10\xb0C TBC and FUNC_TRU_FAN_FAILURE is inactive and DSI_TRC_STATUS is closed\nBAT_TRU_TEMP above 90 +/- 10\xb0C TBC and FUNC_TRU_FAN_FAILURE is active and DSI_TRC_STATUS is closed\nASI_DC_AREA_TEMP above 150 +/- 10\xb0C TBC (see \xa72.6.2)', 'additional': u'\tModified according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_7126]'}, u'SSCS_ESSNESS_0804': {'status': u'\tTBC', 'body': u'In case of RNESS board, CABC2_SHED shall be activated when at least one of following conditions is met:\nCABC overload protection is active (see \xa72.3.7)\nCABC driver fail is active\nTSBC_OVL_IN_PROGRESS is active and DSI_TC_STATUS is closed\nTRU_OVL_IN_PROGRESS is active\nNESS_MAIN_115VAC_FAULT is active\nTIE_ALT_115VAC_FAULT is active and DSI_TAC_STATUS is closed\nSTBY_TRU_TEMP above 110\xb0C and STBY_TRU_FAN_FAIL is inactive and DSI_TSBC_STATUS is closed and DSI_TC_STATUS is closed\nSTBY_TRU_TEMP above 90\xb0C and STBY_TRU_FAN_FAIL is active and DSI_TSBC_STATUS is closed and DSI_TC_STATUS is closed\nBAT_TRU_TEMP above 110 +/- 10\xb0C TBC and FUNC_TRU_FAN_FAILURE is inactive and DSI_TRC_STATUS is closed\nBAT_TRU_TEMP above 90 +/- 10\xb0C TBC and FUNC_TRU_FAN_FAILURE is active and DSI_TRC_STATUS is closed\nASI_DC_AREA_TEMP above 150 +/- 10\xb0C TBC (see \xa72.6.2)\nCABIN_MASTER_STATUS is inactive', 'additional': u'\tModified according SACR299 / Modified according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_4029]'}, u'SSCS_ESSNESS_0803': {'status': u'\tTBC', 'body': u'In case of LNESS board, CABC1_SHED shall be activated when at least one of following conditions is met:\nCABC overload protection is active (see \xa72.3.7)\nCABC driver fail is active\nTSBC_OVL_IN_PROGRESS is active and DSI_TC_STATUS is closed\nTRU_OVL_IN_PROGRESS is active\nNESS_MAIN_115VAC_FAULT is active\nTIE_ALT_115VAC_FAULT is active and DSI_TAC_STATUS is closed\nSTBY_TRU_TEMP above 110\xb0C and STBY_TRU_FAN_FAIL is inactive and DSI_TSBC_STATUS is closed and DSI_TC_STATUS is closed\nSTBY_TRU_TEMP above 90\xb0C and STBY_TRU_FAN_FAIL is active and DSI_TSBC_STATUS is closed and DSI_TC_STATUS is closed\nBAT_TRU_TEMP above 110 +/- 10\xb0C TBC and FUNC_TRU_FAN_FAILURE  is inactive and DSI_TRC_STATUS is closed\nBAT_TRU_TEMP above 90 +/- 10\xb0C TBC and FUNC_TRU_FAN_FAILURE is active and DSI_TRC_STATUS is closed\nASI_DC_AREA_TEMP above 150 +/- 10\xb0C TBC (see \xa72.6.2)\nCABIN_MASTER_SW is in OFF mode (see \xa72.4.3)', 'additional': u'\tModified according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_4027]'}, u'SSCS_ESSNESS_0802': {'status': u'\tTBC', 'body': u'In case of NESS configuration, CABC overload protection shall be activated when calibrated current flowing through CABC (ASI_HES2_CH1) is above following current threshold during more than the defined delay:\ndelay\ncurrent threshold\n5ms ]-5ms,+0] TBC\n850 A +/-26A TBC\n60ms +/-5ms TBC\n270 A+/- 20A TBC\n9,96s +/-100ms\n90 A +/-20A TBC', 'additional': u'\tdelay are 40ms shorter due to system response time,\t1% delay tolerance cannot be achieve due to 5ms minimum microcontroller response time,\tCurrent tolerance are defined as the tolerance of HES and 1% of the full scale of the board', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_736],\t[SDTS_PDS_742],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_0801': {'status': u'\tMATURE', 'body': u'In case of LNESS configuration, CABC overload protection and CABC driver fail protection shall be set to inactive when CABIN_MASTER_SW enters AUTO state.', 'additional': u'\tCABIN_MASTER_SW states are defined in \xa72.4.3,\tIn case of protection, the cabin master switch will be depressed twice for resetting the protection (first depress: AUTO to MANUAL mode / second depress: MANUAL to AUTO & reset) / Modified according SACR439', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_737]'}, u'SSCS_ESSNESS_0800': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, the following CABC protections shall be latched to avoid cycling:\nCABC overload protection\nCABC driver fail protection', 'additional': u'\tThe latch of protections means that if a protection is not reset it will be memorised until the next power down', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t ', 'issue': u'\t3', 'refer': u'[SDTS_PDS_5056],\t[SDTS_PDS_5057]'}, u'SSCS_ESSNESS_7888': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, BITE and FUNC microcontrollers shall compute FREQ_TRU_FAN, frequency of DSI_FREQ_TRU_FAN signal.', 'additional': u'\tsee \xa73.4.1.2 for CAN ICD', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tIn order to define FREQ_TRU_FAN alias', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3924': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, at power-up, the FUNC microcontroller shall set GPU_115VAC_MEAN to 0V', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define GPU_115VAC_MEAN at power-up', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2221': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, the FUNC microcontroller shall activate DSO_GALLEY_MASTER_ON according following logic:\nDSO_GALLEY_MASTER_ON  is active when DSI_EMP_B_CMD_HSCM_1_GALC is closed\nDSO_GALLEY_MASTER_ON  is inactive when DSI_EMP_B_CMD_HSCM_1_GALC is open', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_6004]'}, u'SSCS_ESSNESS_2220': {'status': u'\tMATURE', 'body': u'In case of NESS board, at power up, the signal DSO_GALLEY_MASTER_ON shall be inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_9900': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, BAT heater unbalanced shall be activated when current on two phases are over 0,7Arms +/-0,2Arms and current on the third phase is under 0,7Arms +/-0,2Arms during 500ms +/- 5ms\nElse it is inactive\nConsidered signals are ASI_CT2_PhA, ASI_CT2_PhB, ASI_CT2_PhC', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7247],\t[SDTS_PDS_7248],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_3507': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, if DSI_BC_STATUS is open and no fault is detected on HES current monitoring, the reading current shall be calibrated to zero Ampere, for ASI_HES1_CH1 and ASI_HES1_CH2', 'additional': u'\tFault on HES are described in \xa78.4.4,\tThis behaviour is defined according SMS_ECE_00027-12', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThe HES have to be calibrating when the correspondent contactor is open', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2030': {'status': u'\tMATURE', 'body': u'In case of NESS board, at power up, the signal DSO_150MA_GNDOPEN_1 shall be inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware,\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_3505': {'status': u'\tMATURE', 'body': u'The correspondence between the current measured by the channel2 of HES (ASI_HES1_CH2) and the input of ESSNESS board shall be as following\nThe signal level is 5V + (4*current measured / 50)', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7016],\t[SDTS_PDS_7017]'}, u'SSCS_ESSNESS_3504': {'status': u'\tMATURE', 'body': u'The correspondence between the current measured by the channel1 of HES (ASI_HES1_CH1 and ASI_HES2_CH1) and the input of ESSNESS board shall be as following:\nThe signal level is 5V + (4*current measured / 1000)', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7016],\t[SDTS_PDS_7017]'}, u'SSCS_ESSNESS_2140': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2141': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3501': {'status': u'\tMATURE', 'body': u'The BITE and FUNC microcontrollers shall acquire ASI_HES1_CH1.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE,\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tHES1_CH1 corresponds to BAT and TRU current and is used for functional purpose', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2031': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4622': {'status': u'\tMATURE', 'body': u'In case of NESS configurations, If SSM_74 is Normal Operation and bit 12 of label 74 is FALSE (0)\nThen FLIGHT shall be inactive\nElse FLIGHT is active', 'additional': u'\tAdded according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_8056],\t[SDTS_PDS_8061]'}, u'SSCS_ESSNESS_4048': {'status': u'\tMATURE', 'body': u'ESSNESS board power input shall be compliant with EUROCAE ED-14E / RTCA DO 160 Standards, section n\xb0 16 with category Z. [40] and with the following change:\nVoltage steady state range is 20 - 32,2 V in normal and abnormal mode\nVoltage steady state is 19 V for 2 minutes during main engines start\nPower interruption is 50 ms\nUnder voltage during engine or APU start is not applicable', 'additional': u'\tThe power interruption is 25ms not 50ms according to SDTS_PDS_5045', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6150]'}, u'SSCS_ESSNESS_3509': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, if DSI_SHP_CABC_STATUS is open and no fault is detected on HES current monitoring, the reading current shall be calibrated to zero Ampere, for ASI_HES2_CH1.', 'additional': u'\tFault on HES are described in \xa78.4.5,\tThis behaviour is defined according SMS_ECE_00027-12', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThe HES have to be calibrating when the correspondent contactor is open', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3508': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, if DSI_TRC_STATUS is open and no fault is detected on HES current monitoring, the reading current shall be calibrated to zero Ampere, for ASI_HES1_CH1 and ASI_HES1_CH2', 'additional': u'\tFault on HES are described in \xa78.4.4,\tThis behaviour is defined according SMS_ECE_00027-12', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThe HES have to be calibrating when the correspondent contactor is open', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4119': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5608': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall acquire and scale the following AC voltage:\nASI_MAIN_115_PHA corresponds to ANA_MAIN_115_PHA\nASI_MAIN_115_PHB corresponds to ANA_MAIN_115_PHB\nASI_MAIN_115_PHC corresponds to ANA_MAIN_115_PHC.', 'additional': u'\tThe AC voltage at board input is proportionnel to voltage on the bus bar and is in the range [+10V, -10V].', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tVoltages have to be formatted in order to be readable by the microcontroller.', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5609': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall acquire and scale the following AC voltage:\nASI_ALT_GPU_PHA corresponds to ANA_GPU_ALT_115_PHA\nASI_ALT_GPU_PHB corresponds to ANA_GPU_ALT_115_PHB\nASI_ALT_GPU_PHC corresponds to ANA_GPU_ALT_115_PHC.', 'additional': u'\tThe AC voltage at board input is proportionnel to voltage on the bus bar and is in the range [+10V, -10V].', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tVoltages have to be formatted in order to be readable by the microcontroller.', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4118': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5607': {'status': u'\tMATURE', 'body': u'According to the board configuration, the correspondence between ESSNESS board interface and monitored AC voltages shall be as following:\nSignal name\nLESS config.\nRESS config.\nLNESS config.\nRNESS config.\nANA_MAIN_115_PHA\nLH_MAIN_115_VAC_PhA\nRH_MAIN_115_VAC_PhA\nLH_MAIN_115_VAC_PhA\nRH_MAIN_115_VAC_PhA\nANA_MAIN_115_PHB\nLH_MAIN_115_VAC_PhB\nRH_MAIN_115_VAC_PhB\nLH_MAIN_115_VAC_PhB\nRH_MAIN_115_VAC_PhB\nANA_MAIN_115_PHC\nLH_MAIN_115_VAC_PhC\nRH_MAIN_115_VAC_PhC\nLH_MAIN_115_VAC_PhC\nRH_MAIN_115_VAC_PhC\nANA_GPU_ALT_115_PHA\nALT_115_VAC_PhA\nALT_115_VAC_PhA\nNot used\nGPU_115_VAC_PhA\nANA_GPU_ALT_115_PHB\nALT_115_VAC_PhB\nALT_115_VAC_PhB\nNot used\nGPU_115_VAC_PhB\nANA_GPU_ALT_115_PHC\nALT_115_VAC_PhC\nALT_115_VAC_PhC\nNot used\nGPU_115_VAC_PhC\nANA_ALT_115_PhA\nNot used\nNot used\nALT_115_VAC_PhA\nALT_115_VAC_PhA\nANA_ALT_115_PhB\nNot used\nNot used\nALT_115_VAC_PhB\nALT_115_VAC_PhB\nANA_ALT_115_PhC\nNot used\nNot used\nALT_115_VAC_PhC\nALT_115_VAC_PhC\nTable 22: Interface of monitored AC voltages', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_375],\t[SDTS_PDS_533],\t[SDTS_PDS_5048]'}, u'ICD_SPI_ESSNESS_DATA_0010': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0011': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0012': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0013': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0014': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0015': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0016': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0017': {'issue': '3'}, u'ICD_SPI_ESSNESS_DATA_0018': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0019': {'issue': '1'}, u'SSCS_ESSNESS_3916': {'status': u'\tTBC', 'body': u'The FUNC and BITE microcontrollers shall activate MAIN_115VAC_PRESENCE when one at least of the following conditions is true:\nASI_MAIN_115_PHA is over 20Vrms +/-4V TBC\nASI_MAIN_115_PHB is over 20Vrms +/-4V TBC\nASI_MAIN_115_PHC is over 20Vrms +/-4V TBC\nElse it is inactive', 'additional': u'\t', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_5078],\t[SDTS_PDS_5048]'}, u'ICD_SPI_ESSNESS_DATA_0088': {'issue': '1'}, u'SSCS_ESSNESS_3910': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3911': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3912': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3913': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'ICD_SPI_ESSNESS_DATA_0087': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0086': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0085': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0084': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0128': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0129': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0081': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0080': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0124': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0125': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0126': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0127': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0120': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0121': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0122': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0123': {'issue': '1'}, u'SSCS_ESSNESS_4111': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5805': {'status': u'\tTBC', 'body': u'The driver commands CONTACT_X_PU and CONTACT_X_HO shall withstand a voltage of 80V +/-1V TBC for up to 100ms +/-1ms TBC without functional impact', 'additional': u'\tWhere X corresponds to A, B, C, D and E', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThere\u2019s voltage transients on DC network', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6060': {'status': u'\tMATURE', 'body': u'During the uploading, all outputs of processing devices shall be in High Impedance.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_4042]'}, u'SSCS_ESSNESS_4110': {'status': u'\tMATURE', 'body': u'Data transmitted through CAN busses shall be in accordance with ICD_CAN GS3338 [2]', 'additional': u'\tFor all configuration, following signals are present on CAN ICD,DSI_POWER_ON,DSI_BAT_TRU_SW,DSI_CAB_INV1_OVERCURRENT_GPU_CONNECT_CMD,DSI_BACK_UP_PUMP_CABIN_CONV_GALLEY_CMD,DSI_CABIN_MASTER_CMD,DSO_BAT_TRU_LT,DSI_WOW_LHPPDB,DSI_WOW_RHPPDB,In case of NESS configuration, following signals are present on CAN ICD:,GEN_OVL,GEN_SC,DSI_FAN_CMD_xH,ASI_BAT_TRU_TEMP_A,ASI_BAT_TRU_TEMP_B,DSO_MASTER_OFF_LT,In case of ESS configuration, following signal is present on CAN ICD,DSI_FAN_CMD_xH,In case of RNESS configuration, following signal is present on CAN ICD,DSI_CAB_INV1_FAIL_AGCU_POWER_READY,DSO_GPU_CONNECTION_STATUS,DSO_CAB_GAL_LT', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_012],\t[SDTS_PDS_676],\t[SDTS_PDS_710],\t[SDTS_PDS_716],\t[SDTS_PDS_711],\t[SDTS_PDS_714]'}, u'SSCS_ESSNESS_0511': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, GALC_SHED shall be set to active when one at least of the following conditions is true:\nNESS_MAIN_115VAC_FAULT is active\nNESS_MAIN_115V_OVL is active\n(TIE_ALT_115VAC_OVL is active OR TIE_ALT_115VAC_FAULT is active) AND DSI_TAC_STATUS is closed\nGALC_PROTECTION is active', 'additional': u'\tModified according SACR439', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_4031],\t[SDTS_PDS_4033]'}, u'SSCS_ESSNESS_0510': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, GALC driver fail protection shall be activated when CONTACT_B_TRIP is active and 28V_B is over 18,5V +/-0,5V.', 'additional': u'\tmodified according SyCR17 / SACR258', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7122],\t[SDTS_PDS_7124],\t[SDTS_PDS_8007],\t[SDTS_PDS_8008]'}, u'SSCS_ESSNESS_0513': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, at power-up, the current flowing through GALC (CT_GALC_MAX) shall be set to 0A.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define CT_GALC_MAX', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0512': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, GALC_AUTO_SHED shall be set to active when GALC_SHED is active else it is inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7123],\t[SDTS_PDS_7125]'}, u'SSCS_ESSNESS_0514': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, the MAIN_115_MIN shall be set to 0A at power-up. ', 'additional': u'\tModified according SACR439', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tDefines MAIN_115_MIN at power-up', 'issue': u'\t5', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5307': {'status': u'\tMATURE', 'body': u'The DC current measurement accuracy shall be 1%.', 'additional': u'\tBoard is designed with previous value of this requirement which was 5%', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7009]'}, u'SSCS_ESSNESS_2261': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4112': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4038': {'status': u'\tMATURE', 'body': u'The 28V_B supply shall be protected with a fuse', 'additional': u'\tThis fuse is not tested', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tThis fuse is added in order to prevent damage on 28V supplies when a short circuit occurs on contactor driver.', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2260': {'status': u'\tMATURE', 'body': u'In case of NESS board, at power up, the signals DSO_L_GNDOPEN_1 and DSO_L_GNDOPEN_2 shall be inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_3961': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3960': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3963': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3962': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5806': {'status': u'\tTBC', 'body': u'The CONTACT_X_PU is a 28V/OPEN DSO, it shall implement a current limitation to 4A (-0 / +100mA [TBC])', 'additional': u'\tWhere X correspond to A,B,C,D,E,\tIn order to protect the board in case of short circuit', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_5039]'}, u'SSCS_ESSNESS_4114': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4120': {'status': u'\tMATURE', 'body': u'Data requested on SPI busses shall be sent and received according to protocol defined in SMS EPDS SPI ICD [5] and as defined in SMS EPDS ESSNESS SPI Annex [4]', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE,\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tIn order to assure that all requested data in CAN ICD can be provided by the BITE microcontroller as the FUNC as no CAN bus', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7887': {'status': u'\tMATURE', 'body': u'In case of NESS configuration,the BITE microcontroller shall deactivate CBIT_CABC_CURRENT_CH1 when DSI_SHP_CABC_STATUS is open, and the ASI_HES2_CH1 is outside the following range [-30A; +30A] during 5s +/-50ms', 'additional': u'\tWhen contactor is open the current flowing through it is null, this test verifies the correct behaviour of HES', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7238],\t[SDTS_PDS_7239],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_7884': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, at power-up FUNC_TRU_FAN_FAILURE shall be inactive.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define default value', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9050': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7882': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, when TRU FAN is powered (DSO_BAT_HEATER_TRU_FAN_POWER is active) since more than 2s +/-100ms AND the FREQ_TRU_FAN frequency is out of range [160Hz; 250Hz] accuracy +/-10Hz, The FUNC microcontroller shall activate FUNC_TRU_FAN_FAILURE\notherwise FUNC_TRU_FAN_FAILURE is set to inactive', 'additional': u'\tsee \xa73.4.1.2 for CAN ICD', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_4060],\t[SDTS_PDS_7215]'}, u'SSCS_ESSNESS_4117': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7880': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, when TRU FAN is powered (DSO_BAT_HEATER_TRU_FAN_POWER is active) for more than 2s +/-100ms AND FREQ_TRU_FAN is out of range [160Hz; 250Hz] accuracy +/-10Hz, The BITE microcontroller shall deactivate CBIT_TRU_FAN.', 'additional': u'\tmodified according SyCR17 / Modified according SACR448', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_4060],\t[SDTS_PDS_7215]'}, u'SSCS_ESSNESS_7881': {'status': u'\tMATURE', 'body': u'When PPDB fan is powered (DSO_FAN_POWER_PPDB is active) since more than 1s +/-100ms AND FREQ_PPDB_FAN is out of the range [50Hz; 200Hz] accuracy +/-10Hz, The BITE microcontroller shall deactivate CBIT_PPDB_FAN else it is active', 'additional': u'\tDSO_FAN_POWER_PPDB is available through SPI bus / Modified according SACR448', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_2118],\t[SDTS_PDS_2117],\t[SDTS_PDS_527]'}, u'SSCS_ESSNESS_0099': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6205': {'status': u'\tMATURE', 'body': u'The part of flash memory of the BITE microcontroller shall include a checksum.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to be able to detect validity of the data registered', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4116': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6203': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall implement one LED driven by the \xb5C BITE', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6403]'}, u'SSCS_ESSNESS_4034': {'status': u'\tTBC', 'body': u'The presence of each power input shall be monitored.\n28V_1_PRESENCE indicates that there is power on 28V_1 supply (voltage > 16V TBC)\n28V_2_PRESENCE indicates that there is power on 28V_2 supply (voltage > 16V TBC)\n28V_3_PRESENCE indicates that there is power on 28V_3 supply (voltage > 16V TBC)\n28V_4_PRESENCE indicates that there is power on 28V_4 supply (voltage > 16V TBC)', 'additional': u'\tThe voltage presence is monitored but not the state of the diode', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_172],\t[SDTS_PDS_6405]'}, u'SSCS_ESSNESS_6201': {'status': u'\tMATURE', 'body': u'Proper operation of BITE microcontroller shall be monitored through an external watchdog.', 'additional': u'\tA watchdog is implemented in order to monitor good execution of a program => when a problem occurs the microcontroller is reset.', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6201]'}, u'SSCS_ESSNESS_5801': {'status': u'\tMATURE', 'body': u'According to board configuration, the correspondence between signal name in ESSNESS board interface and signal name in the PDS shall be according following table:\nName\nLESS\nRESS\nLNESS\nRNESS\nCONTACT_A_PU\nCONTACT_BC1_PU\nCONTACT_BC2_PU\nCONTACT_TRC1_PU\nCONTACT_TRC2_PU\nCONTACT_A_HO\nCONTACT_BC1_HO\nCONTACT_BC2_HO\nCONTACT_TRC1_HO\nCONTACT_TRC2_HO\nCONTACT_B_PU\nCONTACT_TC1_PU\nCONTACT_TC2_PU\nCONTACT_GALC1_PU\nCONTACT_GALC2_PU\nCONTACT_B_HO\nCONTACT_TC1_HO\nCONTACT_TC2_HO\nCONTACT_GALC1_HO\nCONTACT_GALC2_HO\nCONTACT_C_PU\nCONTACT_GPULC_PU\nCONTACT_C_HO\nCONTACT_GPLULC_HO\nCONTACT_D_PU\nCONTACT_BOOC_PU\nCONTACT_SHP_PU\nCONTACT_CABC1_PU\nCONTACT_CABC2_PU\nCONTACT_D_HO\nCONTACT_BOOC_HO\nCONTACT_SHP_HO\nCONTACT_CABC1_HO\nCONTACT_CABC2_HO\nCONTACT_E_PU\nCONTACT_LALTC1_PU\nCONTACT_RALTC1_PU\nCONTACT_ATRC1_PU\nCONTACT_ATRC2_PU\nCONTACT_E_HO\nCONTACT_LALTC1_HO\nCONTACT_RALTC1_HO\nCONTACT_ATRC1_HO\nCONTACT_ATRC2_HO', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tDue to several board configurations, the ESSNESS interface corresponds to different names in the PPDS system.', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9163': {'status': u'\tMATURE', 'body': u'When CBIT_ALT_STATUS_FAIL is active, CBIT_ALT_STATUS_FAIL shall be deactivated if all the following conditions are true:\nduty cycle of DSI_ALT_STATUS is:\nin the range 8% +/-3% OR in the range 92% +/-3% OR \nin the range 16% +/-3% OR in the range 84% +/-3% OR\nin the range 24% +/-3% OR in the range 76% +/-3% OR\nin the range 32% +/-3% OR in the range 68% +/-3% OR\nin the range 40% +/-3% OR in the range 60% +/-3% OR\nin the range 48% +/-3% OR in the range 52% +/-3%\nfrequency of DSI_ALT_STATUS is in the range [950Hz, 1.050KHz]', 'additional': u'\tModified according SACR291', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tdefines how to deactivate failure on PWM signal', 'issue': u'\t5', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5802': {'status': u'\tTBC', 'body': u'The CONTACT_X_PU is a 28V/OPEN DSO, it shall be able to source 4A +/-500mA [TBC]during 1s +/-100ms [TBC] ', 'additional': u'\tWhere X correspond to A,B,C,D,E', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_6010]'}, u'SSCS_ESSNESS_5803': {'status': u'\tTBC', 'body': u'The CONTACT_X_HO is a 28V/OPEN DSO, it shall implement a current limitation to 200mA (-0 / +50mA [TBC])', 'additional': u'\tWhere X corresponds to A, B,C,D,E,\tIn order to protect the board in case of short circuit', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6011],\t[SDTS_PDS_5039]'}, u'SSCS_ESSNESS_2102': {'status': u'\tMATURE', 'body': u'In case of LNESS configuration, the FUNC microcontroller shall manage DSO_MASTER_SHED_OFF_LT according following logic:\n\tWhen CABIN_MASTER_SW is in SHED state, DSO_MASTER_SHED_OFF_LT is active\nElse DSO_MASTER_SHED_OFF_LT is inactive', 'additional': u'\tCABIN_MASTER_SW states are defined in \xa72.4.3', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_2316]'}, u'SSCS_ESSNESS_5730': {'status': u'\tMATURE', 'body': u'The DSO_28V_OPEN_20mA_WITHOUT_LIGHTNING shall be protected against polarity inversion with a diode', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6118]'}, u'SSCS_ESSNESS_7833': {'status': u'\tTBC', 'body': u'If the ASI_DC_AREA_TEMP is outside the functional range [-55\xb0C; 160\xb0C] TBC, the BITE microcontroller shall deactivate CBIT_DC_AREA_TEMP else it is active.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tDefinition of CBIT of temperature sensor', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7832': {'status': u'\tTBC', 'body': u'In NESS configuration, if the ASI_DC_AREA_TEMP is outside the functional range [-55\xb0C; 160\xb0C] TBC, the FUNC microcontroller shall deactivate DC_AREA_TEMP_VALID else it is active.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tDefinition of CBIT of temperature sensor', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9125': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2103': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, the FUNC microcontroller shall manage DSO_MASTER_SHED_OFF_LT according following logic:\nWhen CABIN_MASTER_STATUS is inactive state, DSO_MASTER_SHED_OFF_LT is active\nElse DSO_MASTER_SHED_OFF_LT is inactive', 'additional': u'\tCABIN_MASTER_SW states are defined in \xa72.4.3,\tModified according SACR299', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_4018]'}, u'SSCS_ESSNESS_4010': {'status': u'\tTBC', 'body': u'The ESSNESS mechanical interface shall comply with the following drawing :\nFE0214-CE0003620Y00 for Mezzanine and Main boards [TBC]\nFE0214-CE0003600Y00 for Main board [TBC]\nFE0214-CE0003610Y00 for Mezzanine board [TBC]', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tInterface is designed at system level', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4011': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall have a mechanical keying.', 'additional': u'\tThis mechanical keying is used in order to assure that a ESSNESS board can never be mounted in place of a TIE board for exemple / till now there is no mechanical keying on boards drawing,\tAdded according SyCR22', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\t', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7272]'}, u'SSCS_ESSNESS_9121': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5306': {'status': u'\tMATURE', 'body': u'According to board configuration, the correspondence between signal names in ESSNESS board interface and signal names in the PDS shall be as following:\nSignal name\nLESS config.\nRESS config.\nLNESS config.\nRNESS config.\nHES1_CH1_HIGH\nHES_BAT1_CH1_HIGH\nHES_BAT2_CH1_HIGH\nHES_TRU1_CH1_HIGH\nHES_TRU2_CH1_HIGH\nHES1_CH1_LOW\nHES_BAT1_CH1_LOW\nHES_BAT2_CH1_LOW\nHES_TRU1_CH1_LOW\nHES_TRU2_CH1_LOW\nHES1_CH2_HIGH\nHES_BAT1_CH2_HIGH\nHES_BAT2_CH2_HIGH\nHES_TRU1_CH2_HIGH\nHES_TRU2_CH2_HIGH\nHES1_CH2_LOW\nHES_BAT1_CH2_LOW\nHES_BAT2_CH2_LOW\nHES_TRU1_CH2_LOW\nHES_TRU2_CH2_LOW\nHES2_CH1_HIGH\nHES_SHP_HIGH\nHES_CABC1_HIGH\nHES_CABC2_HIGH\nHES2_CH1_LOW\nHES_SHP_LOW\nHES_CABC1_LOW\nHES_CABC2_LOW\nTable 19: Correspondence for HES outputs between ESSNESS names and system names', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_531],\t[SDTS_PDS_530],\t[SDTS_PDS_384]'}, u'SSCS_ESSNESS_6063': {'status': u'\tMATURE', 'body': u'The signal COLD_START shall not be de-activated if cold restart has not been completed.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThis requirement will assure that at least one cold restart occurred.', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5102': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall acquire the board temperature through two temperature sensors type LM75B:\nFirst sensor gives PCB_TEMP_A\nSecond sensor gives PCB_TEMP_B', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_524],\t[SDTS_PDS_373]'}, u'SSCS_ESSNESS_2290': {'status': u'\tMATURE', 'body': u'In case of NESS board, at power up, the signal DSO_SHED_GENERATOR_FAIL shall be inactive.', 'additional': u'\tmodified according SyCR17', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7135],\t[SDTS_PDS_163]'}, u'SSCS_ESSNESS_2291': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, DSO_SHED_GENERATOR_FAIL shall be activated when all the following conditions are true:\nDSI_GLC_STATUS is open OR DSI_GLC_OPP_STATUS is open\nA/C is in flight\nDSI_BOOC_GPULC_STATUS is open', 'additional': u'\tmodified according SyCR17', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7135]'}, u'SSCS_ESSNESS_2292': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, DSO_SHED_GENERATOR_FAIL shall be deactivated when the following conditions is true:\nDSI_BOOC_GPULC_STATUS is closed OR(DSI_GLC_STATUS is closed AND DSI_GLC_OPP_STATUS is closed) during 10s +/-100ms', 'additional': u'\tmodified according SyCR17', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7135],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_4625': {'status': u'\tMATURE', 'body': u'In case of NESS configurations, ARINC_RX_FAIL shall be set to active when all the following conditions are true during 2s +/-200ms\nSSM_54 is Failure Warning\nSSM_55 is Failure Warning\nSSM_56 is Failure Warning\nSSM_73 is Failure Warning\nSSM_74 is Failure Warning\nElse it is inactive', 'additional': u'\tAdded according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_8068]'}, u'SSCS_ESSNESS_7305': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t3', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'ICD_SPI_100': {'status': u' \tDEL', 'body': u'DELETED', 'additional': u' \t', 'issue': u' \t2', 'derived': u' \t', 'allocation': u' \t', 'verification': u' \t', 'rationale': u' \t', 'conformity': u' \t', 'refer': 'EMPTY'}, u'ICD_SPI_101': {'status': u' \tMATURE', 'body': u'SPI master shall detect frame overflow (reception buffer full while another data is trying to be pushed in).', 'additional': u' \t', 'issue': u' \t1', 'derived': u' \tYES', 'allocation': u' \tESSNESS_BITE_SW, SDSIO_BITE_SW, TIE_BITE_SW', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'ICD_SPI_102': {'status': u' \tMATURE', 'body': u'SPI master shall discard all incoming SPI words on overflow detection.', 'additional': u' \t', 'issue': u' \t1', 'derived': u' \tYES', 'allocation': u' \tESSNESS_BITE_SW, SDSIO_BITE_SW, TIE_BITE_SW', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'ICD_SPI_103': {'status': u' \tMATURE', 'body': u'SPI master shall respect MSB to LSB reception order when receiving SPI words.', 'additional': u' \t', 'issue': u' \t1', 'derived': u' \tYES', 'allocation': u' \tESSNESS_BITE_SW, SDSIO_BITE_SW, TIE_BITE_SW', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'ICD_SPI_104': {'status': u' \tMATURE', 'body': u'SPI master shall not transmit data on MOSI towards slave.', 'additional': u' \tSee \xa7 2.1 for frame constitution and \xa7 2.2 for exchange principles.', 'issue': u' \t2', 'derived': u' \tYES', 'allocation': u' \tESSNESS_BITE_SW, SDSIO_BITE_SW, TIE_BITE_SW', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'ICD_SPI_105': {'status': u' \tMATURE', 'body': u'SPI slave shall respect MSB to LSB transmission order when sending SPI words.', 'additional': u' \t', 'issue': u' \t1', 'derived': u' \tYES', 'allocation': u' \tESSNESS_ENM_SW, SDSIO_PLD, TIE_PLD', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'ICD_SPI_106': {'status': u' \tMATURE', 'body': u'SPI master shall request 16 bits wide words.', 'additional': u' \t', 'issue': u' \t2', 'derived': u' \tYES', 'allocation': u' \tESSNESS_BITE_SW', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'ICD_SPI_107': {'status': u' \tMATURE', 'body': u'SPI slave shall transmit as many bits as clock edges.', 'additional': u' \t', 'issue': u' \t2', 'derived': u' \tYES', 'allocation': u' \tESSNESS_ENM_SW, SDSIO_PLD, TIE_PLD', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0142': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0143': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0140': {'status': u'\tMATURE', 'body': u'Driver of CONTACT_D shall be powered by 28V_D.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_276],\t[SDTS_PDS_291],\t[SDTS_PDS_734],\t[SDTS_PDS_740]'}, u'SSCS_ESSNESS_0141': {'status': u'\tMATURE', 'body': u'In case of LESS board configuration, the contactor CONTACT_D (BOOC contactor) shall be managed according to the following diagram:', 'additional': u'\tmodified according SyCR17', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7203]'}, u'SSCS_ESSNESS_3107': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, the FUNC microcontroller shall acquire ASI_DC_AREA_TEMP', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tSensor used for CABC shedding is DC_AREA_TEMP', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3106': {'status': u'\tMATURE', 'body': u'The PCB_TEMP temperature used for functional purpose shall be:\nThe max of the two temperatures, PCB_TEMP_A and PCB_TEMP_B, read when signals validity are valid\nThe temperature of the non faulty sensor when one signal validity is inactive \nNot available when both sensors are faulty\nValidity signal are: PCB_AREA_TEMP_A_VALID and PCB_AREA_TEMP_B_VALID', 'additional': u'\tsee \xa78.4.1 for temperature sensor monitoring', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7172],\t[SDTS_PDS_7174]'}, u'SSCS_ESSNESS_0144': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6048': {'status': u'\tMATURE', 'body': u'Integrated circuit with ball grid array connection shall be avoided', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_167]'}, u'SSCS_ESSNESS_7304': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t3', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3110': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3108': {'status': u'\tMATURE', 'body': u'The BITE microcontroller shall acquire ASI_DC_AREA_TEMP.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tboth sensors are used for CAS message elaboration', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3111': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2180': {'status': u'\tMATURE', 'body': u'At power up, the signal DSO_xALTC1_HES_TRU_CURRENT shall be inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_2181': {'status': u'\tTBC', 'body': u'In case of NESS configuration, DSO_xALTC1_HES_TRU_CURRENT shall be activated when one at least of the following conditions is true:\nTRU calibrated current (ASI_HES1_CH2) is higher than 25A +/-2A TBC during 10ms +/-5ms TBC and TRU_CURRENT_CH2_VALID is active\nTRU calibrated current (ASI_HES1_CH1) is higher than 60A +/-20A TBC during 10ms +/-5msTBC and TRU_CURRENT_CH1_VALID is active\nElse it is inactive', 'additional': u'\tsee \xa72.6.6 for TRU current measurement,\tCurrent tolerance is choosen to be the tolerance of HES and 1% of the full scale for the board,\t1% delay tolerance cannot be achieve', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_5007],\t[SDTS_PDS_5008],\t[SDTS_PDS_7014],\t[SDTS_PDS_7009]'}, u'SSCS_ESSNESS_2182': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2183': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, DSO_xALTC1_HES_TRU_CURRENT shall be set to active when the following conditions is true:\nxALTC1_HIGH_CURRENT is active\nElse it is inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7097],\t[SDTS_PDS_7098],\t[SDTS_PDS_7101],\t[SDTS_PDS_7102]'}, u'SSCS_ESSNESS_0322': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, at power-up TRU_HIGH_CURRENT shall be inactive.', 'additional': u'\tModified according SACR439', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define TRU_HIGH_CURRENT at power-up', 'issue': u'\t5', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0323': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, at power-up HES_TRU_CH2_CURRENT shall be inactive.', 'additional': u'\tModified according SACR439', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define HES_TRU_CH2_CURRENT at power-up', 'issue': u'\t5', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0320': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, the FUNC shall compute CT3_SUM as the sum of rms current on each CT3 phasis (ASI_CT3_PhA, ASI_CT3_PhB, ASI_CT3_PhC)', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7057],\t[SDTS_PDS_7060]'}, u'SSCS_ESSNESS_0321': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, at power-up TRU_CURRENT shall be set to 0A', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define TRU_CURRENT at power-up', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3819': {'status': u'\tTBD', 'body': u'In case of NESS configurations, 28V_PRESENCE_MAIN shall be active when ASI_28V_MAIN_MON is over 16V +/-TBD else it is inactive.', 'additional': u'\tAdded according SACR530', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\t???', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_8036]'}, u'SSCS_ESSNESS_3818': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, the FUNC microcontroller shall acquire ASI_28V_C.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tUsed for functional purpose', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3113': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7894': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6069': {'status': u'\tMATURE', 'body': u'The BITE microcontroller shall deactivate SPI_VALID when data received from FUNC microcontroller through SPI bus are not refreshed since more than 25ms +/-2ms, else it is activated.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tallow to know if data on SPI bus are refreshed or not', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6068': {'status': u'\tMATURE', 'body': u'All discrete inputs shall be filtered for 9ms +/-1ms', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tTo define hardware filtering of DSI inputs', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_1000': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, BAT_SW shall be managed according to the following algorithm:', 'additional': u'\tRising edge means from inactive state to active state,\tBAT_TRU_VALIDITY is defined in \xa72.6.12', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_683],\t[SDTS_PDS_684],\t[SDTS_PDS_7182],\t[SDTS_PDS_7183]'}, u'SSCS_ESSNESS_1001': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, TRU_SW shall be managed according to the following algorithm:', 'additional': u'\tRising edge means from inactive state to active state,\tBAT_TRU_VALIDITY is defined in \xa72.6.12', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_687],\t[SDTS_PDS_688],\t[SDTS_PDS_7180],\t[SDTS_PDS_7181]'}, u'SSCS_ESSNESS_1002': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_1003': {'status': u'\tMATURE', 'body': u'In case of LNESS configuration, CABIN_MASTER_SW shall be managed according following algorithm:', 'additional': u'\tRising edge means from inactive state to active state / Modified by SACR542', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7073]'}, u'SSCS_ESSNESS_1004': {'status': u'\tMATURE', 'body': u'In case of LNESS configuration, CABIN_SW shall be managed according following algorithm:', 'additional': u'\tRising edge means from inactive state to active state,\tCABIN_MASTER modes are described in \xa72.5.11', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_696],\t[SDTS_PDS_7185]'}, u'SSCS_ESSNESS_1005': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, GALLEY_SW shall be managed according following algorithm:', 'additional': u'\tRising edge means from inactive state to active state,\tCABIN_MASTER modes are described in \xa72.5.11,\tModified according SACR299', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_698],\t[SDTS_PDS_7184]'}, u'SSCS_ESSNESS_1006': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, the type of battery shall be defined as follow:\nDSI_BAT_PIN_PROG1_GNC_STATUS\nDSI_BAT_PIN_PROG2_GNC_OPP_STATUS\nBATT_TYPE\nActive\nActive\nType 1 (Pb)\nActive\nInactive\nType 1 (Pb)\nInactive\nActive\nType 2 (Ni-Ca)\nInactive\nInactive\nType 2 (Ni-Ca)\nTable 3: Battery type definition', 'additional': u'\tActive corresponds to GND at board input,\tInactive corresponds to Open at board input', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_2153]'}, u'SSCS_ESSNESS_1007': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, BAT_MAINTENANCE shall be activated when DSI_BAT_PIN_PROG1_GNC_STATUS is active and DSI_BAT_PIN_PROG2_GNC_OPP_STATUS is inactive.\nElse it is inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7230]'}, u'SSCS_ESSNESS_1008': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, at power-up BATT_TYPE shall be set to undefined.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tin order to define BATT_TYPE at power-up', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5012': {'status': u'\tMATURE', 'body': u'In case of LESS configuration, the BITE microcontroller shall acquire the following DSI:\nName\nComments\nDSI_TAC_OPP_CABC_OPP_STATUS\nDSI_START_IN_PROGRESS\nDSI_TRC_OPP_STATUS_CABC_SHED\nDSI_TC_OPP_STATUS\nDSI_TSBC_OPP_STATUS\nDSI_GLC_OPP_STATUS\nDSI_APUGLC_STATUS\nDSI_WOW_LHPPDB\nDSI_WOW_RHPPDB\nDSI_ALT_STATUS\nDSI_SPARE_18\nDSI_RALTC1_STATUS\nDSI_SHP_CABC_STATUS\nDSI_BC_STATUS\nDSI_TSBC_OVL\nDSI_TC_SMC_COIL_GND_MON\nDSI_TRC_STATUS\nDSI_TC_STATUS\nDSI_TSBC_STATUS\nDSI_GLC_STATUS\nDSI_TAC_STATUS\nDSI_HES_TRU_CURRENT_SLC_STATUS\nDSI_TC_RESET_ATRC_STATUS\nDSI_FAN_CMD_xH\nDSI_TAC_TSBC_INHIB_RELAY_MON\nDSI_xALTC1_TAC_COIL_GND_MON\nDSI_TRU_OVL_GEN_OVL_SC\nDSI_FREQ_PPDB_FAN\nDSI_START_ACCEPTED_APUSLC_STATUS\nDSI_BOOC_GPULC_STATUS\nDSI_xALTC2_COIL_GND_MON\nDSI_LALTC1_STATUS\nDSI_BACK_UP_PUMP_CABIN_CONV_GALLEY_CMD\nDSI_TRC_CMD_SMC_RATLC_STATUS\nDSI_BAT_PIN_PROG1_GNC_STATUS\nDSI_BAT_TRU_SW\nDSI_BAT_RELAY_STATUS\nDSI_LALTC2_STATUS\nDSI_POWER_ON\nDSI_BAT_PIN_PROG2_GNC_OPP_STATUS\nDSI_ESSTIED_RELAY_ATRC_OPP_STATUS\nDSI_RATLC_SLC_OPP_STATUS\nDSI_APU_START_REQUEST\nDSI_ISOLATION_SMOKE_GALLEY_CABIN_MASTER\nDSI_BC_Bypass\nDSI_RALTC2_STATUS\nDSI_PIN_PROG1\nDSI_PIN_PROG2\nDSI_PIN_PROG3\nDSI_PIN_PROG4\nDSI_PIN_PROG_PARITY\nDSI_BAT_HEATER_RELAY_2_STATUS\nTable 9: DSI for LESS configuration / BITE microcontroller', 'additional': u'\tModified according SyCR36 / SACR442', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_534]'}, u'SSCS_ESSNESS_5011': {'status': u'\tMATURE', 'body': u'In case of LESS configuration, the FUNC microcontroller shall acquire the following DSI:\nName\nComments\nDSI_TAC_OPP_CABC_OPP_STATUS\nDSI_START_IN_PROGRESS\nDSI_TRC_OPP_STATUS_CABC_SHED\nDSI_TC_OPP_STATUS\nDSI_TSBC_OPP_STATUS\nDSI_GLC_OPP_STATUS\nDSI_APUGLC_STATUS\nDSI_WOW_LHPPDB\nDSI_WOW_RHPPDB\nDSI_ALT_STATUS\nDSI_SPARE_18\nDSI_RALTC1_STATUS\nDSI_SHP_CABC_STATUS\nDSI_BC_STATUS\nDSI_TSBC_OVL\nDSI_TRC_STATUS\nDSI_TC_STATUS\nDSI_TSBC_STATUS\nDSI_GLC_STATUS\nDSI_TAC_STATUS\nDSI_HES_TRU_CURRENT_SLC_STATUS\nDSI_TC_RESET_ATRC_STATUS\nDSI_FAN_CMD_xH\nDSI_TRU_OVL_GEN_OVL_SC\nDSI_FREQ_PPDB_FAN\nDSI_START_ACCEPTED_APUSLC_STATUS\nDSI_BOOC_GPULC_STATUS\nDSI_LALTC1_STATUS\nDSI_TRC_CMD_SMC_RATLC_STATUS\nDSI_BAT_PIN_PROG1_GNC_STATUS\nDSI_BAT_TRU_SW\nDSI_BAT_RELAY_STATUS\nDSI_LALTC2_STATUS\nDSI_POWER_ON\nDSI_BAT_PIN_PROG2_GNC_OPP_STATUS\nDSI_ESSTIED_RELAY_ATRC_OPP_STATUS\nDSI_RATLC_SLC_OPP_STATUS\nDSI_APU_START_REQUEST\nDSI_ISOLATION_SMOKE_GALLEY_CABIN_MASTER\nDSI_BC_Bypass\nDSI_RALTC2_STATUS\nDSI_PIN_PROG1\nDSI_PIN_PROG2\nDSI_PIN_PROG3\nDSI_PIN_PROG4\nDSI_PIN_PROG_PARITY\nDSI_BAT_HEATER_RELAY_2_STATUS\nTable 8: DSI for LESS configuration / FUNC microcontroller', 'additional': u'\tModified According SyCR36 / SACR442 / PRR_SMS_PDS_SSCS_ESSNESS_ET2788_S_7D3', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_534]'}, u'SSCS_ESSNESS_5010': {'status': u'\tMATURE', 'body': u'The GND/Open DSI shall detect a GND state when input voltage of the board is included in the range [0, 5V].', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6117]'}, u'SSCS_ESSNESS_5017': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, the FUNC microcontroller shall acquire the following DSI:\nName\nComments\nDSI_TAC_OPP_CABC_OPP_STATUS\nDSI_START_IN_PROGRESS\nDSI_TC_OPP_STATUS\nDSI_TSBC_OPP_STATUS\nDSI_GLC_OPP_STATUS\nDSI_APUGLC_STATUS\nDSI_WOW_LHPPDB\nDSI_WOW_RHPPDB\nDSI_ALT_STATUS\nDSI_EMP_B_CMD_HSCM_2_GALC_OPP\nDSI_SHP_CABC_STATUS\nDSI_BC_STATUS\nDSI_TSBC_OVL\nDSI_TRC_STATUS\nDSI_TC_STATUS\nDSI_TSBC_STATUS\nDSI_GLC_STATUS\nDSI_TAC_STATUS\nDSI_HES_TRU_CURRENT_SLC_STATUS\nDSI_TC_RESET_ATRC_STATUS\nDSI_FAN_CMD_xH\nDSI_TRU_OVL_GEN_OVL_SC\nDSI_FREQ_PPDB_FAN\nDSI_START_ACCEPTED_APUSLC_STATUS\nDSI_BOOC_GPULC_STATUS\nDSI_EMP_B_CMD_HSCM_1_GALC\nDSI_FREQ_TRU_FAN\nDSI_BACK_UP_PUMP_CABIN_CONV_GALLEY_CMD\nDSI_TRC_CMD_SMC_RATLC_STATUS\nDSI_BAT_PIN_PROG1_GNC_STATUS\nDSI_BAT_TRU_SW\nDSI_POWER_ON\nDSI_BAT_PIN_PROG2_GNC_OPP_STATUS\nDSI_ESSTIED_RELAY_ATRC_OPP_STATUS\nDSI_RATLC_SLC_OPP_STATUS\nDSI_ISOLATION_SMOKE_GALLEY_CABIN_MASTER\nDSI_PIN_PROG1\nDSI_PIN_PROG2\nDSI_PIN_PROG3\nDSI_PIN_PROG4\nDSI_PIN_PROG_PARITY\nDSI_CAB_INV1_FAIL_AGCU_POWER_READY\nDSI_CAB_INV1_DIFF_FAULT_SMC_STATUS\nDSI_CAB_INV1_OVERCURRENT_GPU_CONNECT_CMD\nDSI_CAB_INV1_OVERTEMP_GPU_SW_EPPC\nTable 14: DSI for RNESS configuration / FUNC microcontroller', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_379]'}, u'SSCS_ESSNESS_5016': {'status': u'\tMATURE', 'body': u'In case of LNESS configuration, the BITE microcontroller shall acquire the following DSI:\nName\nComments\nDSI_TAC_OPP_CABC_OPP_STATUS\nDSI_START_IN_PROGRESS\nDSI_TRC_OPP_STATUS_CABC_SHED\nDSI_TC_OPP_STATUS\nDSI_TSBC_OPP_STATUS\nDSI_GLC_OPP_STATUS\nDSI_APUGLC_STATUS\nDSI_WOW_LHPPDB\nDSI_WOW_RHPPDB\nDSI_ALT_STATUS\nDSI_EMP_B_CMD_HSCM_2_GALC_OPP\nDSI_SHP_CABC_STATUS\nDSI_BC_STATUS\nDSI_TSBC_OVL\nDSI_TC_SMC_COIL_GND_MON\nDSI_TRC_STATUS\nDSI_TC_STATUS\nDSI_TSBC_STATUS\nDSI_GLC_STATUS\nDSI_TAC_STATUS\nDSI_HES_TRU_CURRENT_SLC_STATUS\nDSI_TC_RESET_ATRC_STATUS\nDSI_FAN_CMD_xH\nDSI_TAC_TSBC_INHIB_RELAY_MON\nDSI_xALTC1_TAC_COIL_GND_MON\nDSI_TRU_OVL_GEN_OVL_SC\nDSI_FREQ_PPDB_FAN\nDSI_START_ACCEPTED_APUSLC_STATUS\nDSI_BOOC_GPULC_STATUS\nDSI_EMP_B_CMD_HSCM_1_GALC\nDSI_FREQ_TRU_FAN\nDSI_BACK_UP_PUMP_CABIN_CONV_GALLEY_CMD\nDSI_TRC_CMD_SMC_RATLC_STATUS\nDSI_BAT_PIN_PROG1_GNC_STATUS\nDSI_BAT_TRU_SW\nDSI_POWER_ON\nDSI_BAT_PIN_PROG2_GNC_OPP_STATUS\nDSI_ESSTIED_RELAY_ATRC_OPP_STATUS\nDSI_RATLC_SLC_OPP_STATUS\nDSI_ISOLATION_SMOKE_GALLEY_CABIN_MASTER\nDSI_PIN_PROG1\nDSI_PIN_PROG2\nDSI_PIN_PROG3\nDSI_PIN_PROG4\nDSI_PIN_PROG_PARITY\nDSI_CAB_INV1_FAIL_AGCU_POWER_READY\nDSI_CAB_INV1_DIFF_FAULT_SMC_STATUS\nDSI_CAB_INV1_OVERCURRENT_GPU_CONNECT_CMD\nDSI_CAB_INV1_OVERTEMP_GPU_SW_EPPC\nDSI_CABIN_MASTER_CMD\nDSI_CAB_INV1_FAN_FAIL\nTable 13: DSI for LNESS configuration / BITE microcontroller', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_379]'}, u'SSCS_ESSNESS_5015': {'status': u'\tMATURE', 'body': u'In case of LNESS configuration, the FUNC microcontroller shall acquire the following DSI:\nName\nComments\nDSI_TAC_OPP_CABC_OPP_STATUS\nDSI_START_IN_PROGRESS\nDSI_TRC_OPP_STATUS_CABC_SHED\nDSI_TC_OPP_STATUS\nDSI_TSBC_OPP_STATUS\nDSI_GLC_OPP_STATUS\nDSI_APUGLC_STATUS\nDSI_WOW_LHPPDB\nDSI_WOW_RHPPDB\nDSI_ALT_STATUS\nDSI_EMP_B_CMD_HSCM_2_GALC_OPP\nDSI_SHP_CABC_STATUS\nDSI_BC_STATUS\nDSI_TSBC_OVL\nDSI_TRC_STATUS\nDSI_TC_STATUS\nDSI_TSBC_STATUS\nDSI_GLC_STATUS\nDSI_TAC_STATUS\nDSI_HES_TRU_CURRENT_SLC_STATUS\nDSI_TC_RESET_ATRC_STATUS\nDSI_FAN_CMD_xH\nDSI_TRU_OVL_GEN_OVL_SC\nDSI_FREQ_PPDB_FAN\nDSI_START_ACCEPTED_APUSLC_STATUS\nDSI_BOOC_GPULC_STATUS\nDSI_EMP_B_CMD_HSCM_1_GALC\nDSI_FREQ_TRU_FAN\nDSI_BACK_UP_PUMP_CABIN_CONV_GALLEY_CMD\nDSI_TRC_CMD_SMC_RATLC_STATUS\nDSI_BAT_PIN_PROG1_GNC_STATUS\nDSI_BAT_TRU_SW\nDSI_POWER_ON\nDSI_BAT_PIN_PROG2_GNC_OPP_STATUS\nDSI_ESSTIED_RELAY_ATRC_OPP_STATUS\nDSI_RATLC_SLC_OPP_STATUS\nDSI_ISOLATION_SMOKE_GALLEY_CABIN_MASTER\nDSI_PIN_PROG1\nDSI_PIN_PROG2\nDSI_PIN_PROG3\nDSI_PIN_PROG4\nDSI_PIN_PROG_PARITY\nDSI_CAB_INV1_FAIL_AGCU_POWER_READY\nDSI_CAB_INV1_DIFF_FAULT_SMC_STATUS\nDSI_CAB_INV1_OVERCURRENT_GPU_CONNECT_CMD\nDSI_CAB_INV1_OVERTEMP_GPU_SW_EPPC\nDSI_CABIN_MASTER_CMD\nDSI_CAB_INV1_FAN_FAIL\nTable 12: DSI for LNESS configuration / FUNC microcontroller', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_379]'}, u'SSCS_ESSNESS_5014': {'status': u'\tMATURE', 'body': u'In case of RESS configuration, the BITE microcontroller shall acquire the following DSI:\nName\nComments\nDSI_TAC_OPP_CABC_OPP_STATUS\nDSI_START_IN_PROGRESS\nDSI_TRC_OPP_STATUS_CABC_SHED\nDSI_TC_OPP_STATUS\nDSI_TSBC_OPP_STATUS\nDSI_GLC_OPP_STATUS\nDSI_APUGLC_STATUS\nDSI_WOW_LHPPDB\nDSI_WOW_RHPPDB\nDSI_ALT_STATUS\nDSI_SPARE_18\nDSI_RALTC1_STATUS\nDSI_EMP_B_CMD_HSCM_2_GALC_OPP\nDSI_SHP_CABC_STATUS\nDSI_BC_STATUS\nDSI_TSBC_OVL\nDSI_TC_SMC_COIL_GND_MON\nDSI_TRC_STATUS\nDSI_TC_STATUS\nDSI_TSBC_STATUS\nDSI_GLC_STATUS\nDSI_TAC_STATUS\nDSI_HES_TRU_CURRENT_SLC_STATUS\nDSI_TC_RESET_ATRC_STATUS\nDSI_FAN_CMD_xH\nDSI_TAC_TSBC_INHIB_RELAY_MON\nDSI_xALTC1_TAC_COIL_GND_MON\nDSI_TRU_OVL_GEN_OVL_SC\nDSI_FREQ_PPDB_FAN\nDSI_xALTC2_COIL_GND_MON\nDSI_EMP_B_CMD_HSCM_1_GALC\nDSI_SPARE_19\nDSI_BACK_UP_PUMP_CABIN_CONV_GALLEY_CMD\nDSI_TRC_CMD_SMC_RATLC_STATUS\nDSI_BAT_PIN_PROG1_GNC_STATUS\nDSI_BAT_TRU_SW\nDSI_BAT_RELAY_STATUS\nDSI_POWER_ON\nDSI_BAT_PIN_PROG2_GNC_OPP_STATUS\nDSI_ESSTIED_RELAY_ATRC_OPP_STATUS\nDSI_RATLC_SLC_OPP_STATUS\nDSI_ISOLATION_SMOKE_GALLEY_CABIN_MASTER\nDSI_BC_Bypass\nDSI_PIN_PROG1\nDSI_PIN_PROG2\nDSI_PIN_PROG3\nDSI_PIN_PROG4\nDSI_PIN_PROG_PARITY\nDSI_BAT_HEATER_RELAY_2_STATUS\nTable 11: DSI for RESS configuration / BITE microcontroller', 'additional': u'\tModified according SyCR36 / SACR442', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_534]'}, u'SSCS_ESSNESS_7886': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration,the BITE microcontroller shall activate CBIT_CABC_CURRENT_CH1 when one of the following condition is true:\nAt board power up\nRisind edge on CABIN_MASTER_STATUS', 'additional': u'\tModified according SACR299', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7239]'}, u'SSCS_ESSNESS_8053': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3210': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, TRU_HIGH_CURRENT and TRU_OVL_IN_PROGRESS shall be managed according following logic, when the CBIT_TRU_OVL_FAIL is inactive:\nIf duty cycle of DSI_TRU_OVL_GEN_OVL_SC is 15% +/-3% or 85% +/-3%\nTRU_HIGH_CURRENT is inactive\nTRU_OVL_IN_PROGRESS is inactive\nElse if Ton of DSI_TRU_OVL_GEN_OVL_SC is 30% +/-3% or 70% +/-3%\nTRU_HIGH_CURRENT is active\nTRU_OVL_IN_PROGRESS is inactive\nElse if Ton of DSI_TRU_OVL_GEN_OVL_SC is 45% +/-3% or 55% +/-3%\nTRU_HIGH_CURRENT is active\nTRU_OVL_IN_PROGRESS is active', 'additional': u'\tsee \xa78.4.8 for CBIT_TRU_OVL_FAIL definition / modified according SACR291 / Modified according SACR448', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_7116],\t[SDTS_PDS_7059],\t[SDTS_PDS_7064],\t[SDTS_PDS_7058],\t[SDTS_PDS_7062],\t[SDTS_PDS_7066]'}, u'SSCS_ESSNESS_3117': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4061': {'status': u'\tTBC', 'body': u'An inrush current limiter shall be implemented on ESSNESS board, if the capacitance on power input is over 10\xb5F (current has to be limited to 1.5 nominal current[TBC]).', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6158]'}, u'SSCS_ESSNESS_4060': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4063': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall withstand abnormal surge of 80V during 100ms.', 'additional': u'\taccording to \xa716.6.2.4 of DO160', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6150]'}, u'SSCS_ESSNESS_4062': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4065': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall withstand A4J44 lightning on following voltage input:\n28V_1\n28V_2\n28V_3\n28V_4\n28V_5\n28V_6\n28V_7\n28V_8\n28V_9', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_2609]'}, u'SSCS_ESSNESS_4064': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall withstand abnormal surge of 48V during 1s.', 'additional': u'\taccording to \xa716.6.2.4 of DO160', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6150]'}, u'SSCS_ESSNESS_4066': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall activate BF_ALIM_28V when 28V board supply is over 26V +/-1V.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tIn order to define BF_ALIM_28V signal', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5411': {'status': u'\tMATURE', 'body': u'The AC RMS current measurement accuracy shall be +/- 5 % of the measured value in the whole frequency range with up to 30% harmonic content', 'additional': u'\tBoard is designed with previous value of this requirement which was 5%,\tThis tolerance has to be achieve at board level (not for the whole system)', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7012]'}, u'SSCS_ESSNESS_3604': {'status': u'\tMATURE', 'body': u'The BITE and FUNC microcontrollers shall acquire \nASI_CT3_PHA\nASI_CT3_PHB\nASI_CT3_PHC', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE,\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tCurrent measured by CT are used for functional purpose', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3800': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall acquire and scale the following DC voltages:\nASI_28V_BAT_TRU_MON corresponds to 28V_BAT_TRU_MON\nASI_28V_ESS_MON corresponds to 28V_ESS_MON\nASI_28V_MAIN_MON.corresponds to 28V_MAIN_MON\nASI_28V_FUSE corresponds to 28V_FUSE', 'additional': u'\tThe DC voltage have the same voltage as the corresponding bus bar.', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tMonitored voltages have to be formatted in order to be readable by the microcontroller', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3602': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, the BITE and FUNC microcontrollers shall acquire \nASI_CT1_PHA\nASI_CT1_PHB\nASI_CT1_PHC', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE,\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tCurrent measured by CT are used for functional purpose', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3603': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, the FUNC microcontroller shall acquire \nASI_CT2_PHA\nASI_CT2_PHB\nASI_CT2_PHC', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tCurrent measured by CT are used for functional purpose', 'issue': u'\t4', 'refer': 'EMPTY'}, u'ICD_SPI_ESSNESS_DATA_0115': {'issue': '2'}, u'ICD_SPI_ESSNESS_DATA_0114': {'issue': '2'}, u'ICD_SPI_ESSNESS_DATA_0117': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0116': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0111': {'issue': '3'}, u'ICD_SPI_ESSNESS_DATA_0110': {'issue': '3'}, u'ICD_SPI_ESSNESS_DATA_0113': {'issue': '2'}, u'ICD_SPI_ESSNESS_DATA_0112': {'issue': '2'}, u'ICD_SPI_ESSNESS_DATA_0119': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0118': {'issue': '1'}, u'SSCS_ESSNESS_0960': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, at power-up, the current flowing through xALTC1 (CT_xALTC1_MAX) shall be set to 0A.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define CT_xALTC1_MAX at power-up', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2270': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2271': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7891': {'status': u'\tMATURE', 'body': u'When duty cycle of DSI_ALT_STATUS is:\nout of the range 8% +/-3% AND out of the range 92% +/-3% AND \nout of the range 16% +/-3% AND out of the range 84% +/-3% AND\nout of the range 24% +/-3% AND out of the range 76% +/-3% AND\nout of the range 32% +/-3% AND out of the range 68% +/-3% AND\nout of the range 40% +/-3% AND out of the range 60% +/-3% AND\nout of the range 48% +/-3% AND out of the range 52% +/-3%\nFUNC_ALT_STATUS_FAIL shall be activated', 'additional': u'\tModified according SACR291', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_7115]'}, u'SSCS_ESSNESS_2171': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, DSO_TC_RESET shall be activated during 500ms +/-5ms when TRU_SW switches from OFF to  AUTO state.', 'additional': u'\tModified according SACR439', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_2667],\t[SDTS_PDS_2668]'}, u'SSCS_ESSNESS_2170': {'status': u'\tMATURE', 'body': u'At power up, the signal DSO_TC_RESET shall be inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_8001': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6202': {'status': u'\tMATURE', 'body': u'The BITE microcontroller of ESSNESS board shall acquire three inputs in order to determine the type of microcontroller (FUNC, BITE or SPARE)\nFor BITE \xb5C, UC_TYPE_1 will be High level\nFor BITE \xb5C, UC_TYPE_2 will be Low level\nFor BITE \xb5C, UC_PARITY will be Low level', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThose pins allow determining whether the microcontroller is a FUNC, BITE or SPARE one, so that if one microcontroller was badly programmed (with the wrong software) it can be detected. The spare configuration is for a third microcontroller if the THD measurement is done with a microcontroller.', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7300': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t3', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6070': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall be dissimilar from TIE board:\nProcessing devices for functional purpose have to be different\nSame components can be used for BITE and communication (CAN & ARINC drivers)\nDesigns have to be different for power supply, DSO and DSI\nPart numbers have to be different for resistors, Aop, diodes and fuses\nSame capacitors can be used', 'additional': u'\tArchitecture of power supply, DSI and DSO are identical, only part numbers are different', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tTRUE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_372]'}, u'SSCS_ESSNESS_2070': {'status': u'\tMATURE', 'body': u'In case of NESS board, at power up, the signal DSO_EPP_LT shall be inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_2071': {'status': u'\tMATURE', 'body': u'In case of NESS board, at power up, the signal DSO_GPU_CONNECTION_STATUS shall be inactive.', 'additional': u'\t', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_2072': {'status': u'\tMATURE', 'body': u'In case of RNESS board, the FUNC microcontroller shall manage DSO_GPU_CONNECTION_STATUS according following logic:\nIf GPU_FAULT is active, DSO_GPU_CONNECTION_STATUS is blinking active/inactive (duty cycle 0.5 frequency 5Hz)\nElse if GPU_AUTO is active, DSO_GPU_CONNECTION_STATUS is active\nElse if GPU_Power_Ready is active, DSO_GPU_CONNECTION_STATUS is blinking (duty cycle 0.5 frequency 1 Hz)\nElse DSO_GPU_CONNECTION_STATUS is inactive ', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_686]'}, u'SSCS_ESSNESS_2073': {'status': u'\tMATURE', 'body': u'In case of RNESS board, the FUNC microcontroller shall manage DSO_EPP_LT according following logic:\nIf GPU_FAULT is active, DSO_EPP_LT is blinking active/inactive (duty cycle 0.5 frequency 5Hz)\nElse if GPU_AUTO is active, DSO_EPP_LT  is active\nElse if GPU_Power_Ready is active, DSO_EPP_LT  is blinking (duty cycle 0.5 frequency 1 Hz)\nElse DSO_EPP_LT  is inactive', 'additional': u'\tGPU_AUTO / GPU_Power_Ready / GPU_FAULT are defined \xa72.4.6.', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_4002]'}, u'SSCS_ESSNESS_6200': {'status': u'\tMATURE', 'body': u'The microcontroller used for BITE functionalities shall be:\nDSP33FJ256GP710A', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tThis requirement defines the microcontroller used for BITE realization', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6072': {'status': u'\tMATURE', 'body': u'Storage temperature of ESSNESS components shall be at least [-55\xb0C;125\xb0C]', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tIn order to define temperature range for component choice', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6073': {'status': u'\tTBD', 'body': u'The ESSNESS board shall have test point (coverage rate has to be defined TBD)', 'additional': u'\tAdded according SyCR22', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\t', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7273]'}, u'SSCS_ESSNESS_3112': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7303': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t3', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'ICD_SPI_ESSNESS_DATA_0029': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0028': {'issue': '1'}, u'SSCS_ESSNESS_3927': {'status': u'\tMATURE', 'body': u'In case of ESS or RNESS configuration, the BITE microcontroller shall compute ALT_GPU_115_DISP according following rule:\nIf ALT_GPU_115_MEAN is under 112V\nALT_GPU_115_DISP = 114/112* ALT_GPU_115_MEAN\nElse if ALT_GPU_115_MEAN is over 112V and under 118V\nALT_GPU_115_DISP = 114+ 2/6(ALT_GPU_115_MEAN-112)\nElse\nALT_GPU_115_DISP = 116+ 14/12(ALT_GPU_115_MEAN-118)', 'additional': u'\tAdded according SACR530', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7008]'}, u'SSCS_ESSNESS_3926': {'status': u'\tMATURE', 'body': u'In case of ESS or RNESS configuration, the BITE microcontroller shall compute ALT_GPU_115_MEAN as the mean of ASI_ALT_GPU_PHA and ASI_ALT_GPU_PHB and ASI_ALT_GPU_PHC averaged during 250ms +/-2,5ms.', 'additional': u'\tAdded according SACR530', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7007],\t[SDTS_PDS_8038],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_3921': {'status': u'\tTBC', 'body': u'In case of RNESS configuration, the FUNC and BITE microcontrollers shall activate GPU_115VAC_PRESENCE when one at least of the following conditions is true:\nASI_ALT_GPU_PHA is over 20Vrms +/-4V TBC\nASI_ALT_GPU_PHB is over 20Vrms +/-4V TBC\nASI_ALT_GPU_PHC is over 20Vrms +/-4V TBC\nElse it is inactive', 'additional': u'\t', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_5048]'}, u'SSCS_ESSNESS_3920': {'status': u'\tTBC', 'body': u'In case of ESS configuration, the FUNC and BITE microcontrollers shall activate ALT_115VAC_PRESENCE when one at least of the following conditions is true:\nASI_ALT_GPU_PHA is over 20Vrms +/-4V TBC\nASI_ALT_GPU_PHB is over 20Vrms +/-4V TBC\nASI_ALT_GPU_PHC is over 20Vrms +/-4V TBC\nElse it is inactive', 'additional': u'\t', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_5078]'}, u'SSCS_ESSNESS_3923': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, the NESS_MAIN_115V_OVL shall be computed as follow:', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7087],\t[SDTS_PDS_7089]'}, u'SSCS_ESSNESS_3922': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, the NESS_MAIN_115VAC_FAULT shall be computed as follow:', 'additional': u'\tModified according SACR439', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_7086],\t[SDTS_PDS_7088]'}, u'ICD_SPI_ESSNESS_DATA_0021': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0020': {'issue': '2'}, u'ICD_SPI_ESSNESS_DATA_0023': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0022': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0025': {'issue': '2'}, u'ICD_SPI_ESSNESS_DATA_0024': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0027': {'issue': '2'}, u'ICD_SPI_ESSNESS_DATA_0026': {'issue': '2'}, u'SSCS_ESSNESS_2001': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2000': {'status': u'\tMATURE', 'body': u'At power up, the signal DSO_ESS_TRU_STATUS shall be inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_2003': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, the signal DSO_ESS_TRU_STATUS is a PWM signal, it shall be managed as following:\nWhen TRU_OVL_IN_PROGRESS is inactive AND TRU_HIGH_CURRENT is inactive, frequency 1KHz +/-10Hz, duty cycle 15% +/-1% (or 85% +/-1%)\nWhen TRU_OVL_IN_PROGRESS is inactive AND TRU_HIGH_CURRENT is active, frequency 1KHz +/-10Hz, duty cycle 30% +/-1% (or 70% +/-1%)\nWhen TRU_OVL_IN_PROGRESS is active, frequency 1KHz +/-10Hz, duty cycle 45% +/-1% (or 55% +/-1%)', 'additional': u'\tsee \xa72.3.2 for TRU_HIGH_CURRENT and TRU_OVL_IN_PROGRESS definition', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_5052],\t[SDTS_PDS_5053]'}, u'SSCS_ESSNESS_2002': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'ICD_SPI_ESSNESS_DATA_0058': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0059': {'issue': '1'}, u'SSCS_ESSNESS_7205': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t3', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'ICD_SPI_ESSNESS_DATA_0054': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0055': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0056': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0057': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0050': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0051': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0052': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0053': {'issue': '1'}, u'SSCS_ESSNESS_7889': {'status': u'\tMATURE', 'body': u'BITE microcontroller shall compute FREQ_PPDB_FAN, frequency of DSI_FREQ_PPDB_FAN signal.', 'additional': u'\tsee \xa73.4.1.2 for CAN ICD', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tIn order to define FREQ_PPDB_FAN alias', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2130': {'status': u'\tMATURE', 'body': u'In case of NESS board, at power up, the signal DSO_AFT_WATER_HEATER_AUTHORISED shall be inactive;', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_9008': {'status': u'\tMATURE', 'body': u'The time between contactor command by microcontroller and output of the board shall be less then 2ms.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThe delay between microcontroller and output of the board has to be as short as possible', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9009': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7202': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t3', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9000': {'status': u'\tMATURE', 'body': u'In case of LESS board configuration, the contactor CONTACT_A (BC1 contactor) shall be managed according the following diagram', 'additional': u'\tmodified according SyCR17', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7201]'}, u'SSCS_ESSNESS_9001': {'status': u'\tMATURE', 'body': u'In case of RESS board configuration, the contactor CONTACT_A (BC2 contactor) shall be managed according the following diagram:', 'additional': u'\tmodified according SyCR17', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7202]'}, u'SSCS_ESSNESS_9002': {'status': u'\tMATURE', 'body': u'In case of LNESS board configuration, the contactor CONTACT_A (TRC1 contactor) shall be managed according to the following diagram:', 'additional': u'\tmodified according SyCR17', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7199]'}, u'SSCS_ESSNESS_9003': {'status': u'\tMATURE', 'body': u'In case of RNESS board configuration, the contactor CONTACT_A (TRC2 contactor) shall be managed according the following diagram:', 'additional': u'\tmodified according SyCR17', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7200]'}, u'SSCS_ESSNESS_9004': {'status': u'\tMATURE', 'body': u'The contactor command CONTACT_A shall be inactive at power-up.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_9005': {'status': u'\tMATURE', 'body': u'When contactor A closure is required (CONTACT_A is active), if  28V_A is greater than 18.5V(+/-0.5V), the pick-up command (CONTACT_A_PU) shall be activated during 60ms (+/-5ms) and the hold command (CONTACT_A_HO) be activated continuously.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_519]'}, u'SSCS_ESSNESS_9006': {'status': u'\tMATURE', 'body': u'In order to keep contactor A closed, when 28V_A goes lower than 12.5V (+/- 0.5V), the pick-up command (CONTACT_A_PU) shall be activated..', 'additional': u'\tThis requirement is not compliant due to the removal of 1s limitation time according ECM_ECE_00077-12', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7056]'}, u'SSCS_ESSNESS_9007': {'status': u'\tMATURE', 'body': u'The pick-up command (CONTACT_A_PU) shall be released 60 ms (+/- 5 ms) after 28V_A has reached at least 14.5 V (+/- 0.5V)', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7056]'}, u'SSCS_ESSNESS_3801': {'status': u'\tMATURE', 'body': u'The FUNC microcontroller shall acquire ASI_28V_BAT_TRU_MON, ASI_28V_ESS_MON and ASI_28V_MAIN_MON.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tUsed for functional purpose', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9162': {'status': u'\tMATURE', 'body': u'When CBIT_ALT_STATUS_FAIL is active, STBY_TRU_FAIL, TIE_ALT_115VAC_OVL and TIE_ALT_115VAC_FAULT shall be inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7163]'}, u'SSCS_ESSNESS_9161': {'status': u'\tMATURE', 'body': u'When FUNC_ALT_STATUS_FAIL is active, FUNC_ALT_STATUS_FAIL shall be deactivated if all the following conditions are true:\nduty cycle of DSI_ALT_STATUS is:\nin the range 8% +/-3% OR in the range 92% +/-3% OR \nin the range 16% +/-3% OR in the range 84% +/-3% OR\nin the range 24% +/-3% OR in the range 76% +/-3% OR\nin the range 32% +/-3% OR in the range 68% +/-3% OR\nin the range 40% +/-3% OR in the range 60% +/-3% OR\nin the range 48% +/-3% OR in the range 52% +/-3%\nfrequency of DSI_ALT_STATUS is in the range [950Hz, 1.050KHz]', 'additional': u'\tModified according SACR291', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tdefines how to deactivate failure on PWM signal', 'issue': u'\t5', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9160': {'status': u'\tMATURE', 'body': u'When FUNC_ALT_STATUS_FAIL is active, STBY_TRU_FAIL, TIE_ALT_115VAC_OVL and TIE_ALT_115VAC_FAULT shall be inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7163]'}, u'SSCS_ESSNESS_9166': {'status': u'\tMATURE', 'body': u'At power-up, CBIT_TSBC_OVL_FAIL shall be inactive.', 'additional': u'\tModified according SACR448', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tdefines the behavior of CBIT_TSBC_OVL_FAIL at power up', 'issue': u'\t5', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9165': {'status': u'\tMATURE', 'body': u'At power up until DSI_ALT_STATUS becomes active once, FUNC_ALT_STATUS_FAIL shall be inactive.', 'additional': u'\tModified according SACR439', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tin order to define FUNC_ALT_STATUS_FAIL at power-up', 'issue': u'\t5', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5005': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall acquire DSI_BAT_TRU_SW. DSI_BAT_TRU_SW is a DSI open / closed with short circuit / open circuit detection(DSI_GND_I).', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_534],\t[SDTS_PDS_379]'}, u'SSCS_ESSNESS_4615': {'status': u'\tMATURE', 'body': u'In case of NESS configurations, at power-up, STBY_TRU_FAN_FAIL shall be inactive.', 'additional': u'\tAdded according SACR809', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define STBY_TRU_FAN_FAIL at power-up', 'issue': u'\t7', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0108': {'status': u'\tMATURE', 'body': u'CONTACT_X_TRIP signals shall be set to inactive when corresponding command (CONTACT_X_PU or CONTACT_X_HO) is set to inactive', 'additional': u'\tWhere X corresponds to the name of the contactor (A or B or C or D or E)', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to allow reset of overcurrent protection of contactor driver', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0109': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0106': {'status': u'\tMATURE', 'body': u'When CONTACT_X is set to inactive, the pick-up (CONTACT_X_PU) and the hold commands (CONTACT_X_HO) shall be released.\nWhere X stands for B,D or E', 'additional': u'\tWhere X corresponds to the name of the contactor (A or B or C or D or E) / Modified according SACR439', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_519]'}, u'SSCS_ESSNESS_0107': {'status': u'\tMATURE', 'body': u'Each contactor command (CONTACT_X_PU & CONTACT_X_HO) shall be protected against overcurrent. When overcurrent occurs, the contactor command of the driver is open, and signal (CONTACT_X_TRIP) is activated.', 'additional': u'\tWhere X corresponds to the name of the contactor (A or B or C or D or E)', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThe \u201chardware\u201d part of the driver protects the driver from overcurrent.', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0104': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0105': {'status': u'\tMATURE', 'body': u'The contactor commands CONTACT_X_PU and CONTACT_X_HO shall be inactive at power-up.\nWhere X stands for B,C,D or E', 'additional': u'\t', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_0102': {'status': u'\tMATURE', 'body': u'The contactor commands CONTACT_X_PU and CONTACT_X_HO shall be managed by the FUNC microcontroller.\nWhere X stands for B,C,D or E', 'additional': u'\t', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_2075]'}, u'SSCS_ESSNESS_0103': {'status': u'\tMATURE', 'body': u'When CONTACT_X is set to active, if ASI_28V_X is greater than 18.5V(+/-0.5V), the pick-up command (CONTACT_X_PU) shall be activated during 60ms (+/-5ms) and the hold command (CONTACT_X_HO) be activated continuously.\nWhere X stands for B, D or E', 'additional': u'\tModified according SACR439', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_519]'}, u'SSCS_ESSNESS_0100': {'status': u'\tMATURE', 'body': u'According to the board configuration, correspondence between ESSNESS board contactor names and corresponding PDS contactor names shall be as following:\nSignal name\nLESS config.\nRESS config.\nLNESS config.\nRNESS config.\nCONTACT_A\nBC1\nBC2\nTRC1\nTRC2\nCONTACT_B\nTC1\nTC2\nGALC1\nGALC2\nCONTACT_C\nNot used\nNot used\nNot used\nGPULC\nCONTACT_D\nBOOC\nSHP\nCABC1\nCABC2\nCONTACT_E\nLALTC1\nRALTC1\nATRC1\nATRC2\nTable 2: Correspondence between ESSNESS contactor\u2019s name and PDS contactor\u2019s name', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_106],\t[SDTS_PDS_281],\t[SDTS_PDS_283],\t[SDTS_PDS_2646],\t[SDTS_PDS_2661],\t[SDTS_PDS_127],\t[SDTS_PDS_128],\t[SDTS_PDS_275],\t[SDTS_PDS_290],\t[SDTS_PDS_722],\t[SDTS_PDS_726],\t[SDTS_PDS_733],\t[SDTS_PDS_739],\t[SDTS_PDS_745],\t[SDTS_PDS_2632],\t[SDTS_PDS_143],\t[SDTS_PDS_150]'}, u'SSCS_ESSNESS_0101': {'status': u'\tMATURE', 'body': u'Each contactor driven by the ESSNESS board has an electronic economizer, i.e. each driver shall manage two command signals, the pick-up and the hold signals.\nCONTACT_X_PU signal corresponds to the \u201cpick-up\u201d command\nCONTACT_X_HO signal corresponds to the \u201chold\u201d command', 'additional': u'\tWhere X corresponds to the name of the contactor (A or B or C or D or E)', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_519]'}, u'SSCS_ESSNESS_3209': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7893': {'status': u'\tMATURE', 'body': u'When FUNC_TSBC_OVL_FAIL is active, FUNC_TSBC_OVL_FAIL shall be deactivated if all the following conditions are true:\nduty cycle of DSI_TSBC_OVL is in the range 15% +/-3% OR in of the range 30% +/-3% OR in of the range 45% +/-3% OR in of the range 55% +/-3% OR in of the range 70% +/-3% OR in of the range 85% +/-3%\nfrequency of DSI_TSBC_OVL is in the range [950Hz, 1.050KHz]', 'additional': u'\tModified according SACR291', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tdefines how to deactivate failure on PWM signal', 'issue': u'\t5', 'refer': 'EMPTY'}, u'ICD_SPI_001': {'status': u' \tMATURE', 'body': u'EPDS boards shall respect the following master/slave configuration:\nBoard\nMaster\nSlave\nESSNESS\nBITE microcontroller\nENM microcontroller\nSDSIO\nBITE microcontroller\nPLD\nTIE\nBITE microcontroller\nPLD\nTable 1 : Master/Slave configuration', 'additional': u' \t', 'issue': u' \t1', 'derived': u' \tYES', 'allocation': u' \tESSNESS_ENM_SW, ESSNESS_BITE_SW, SDSIO_BITE_SW, TIE_BITE_SW, SDSIO_PLD, TIE_PLD', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'ICD_SPI_003': {'status': u' \tMATURE', 'body': u'SPI master shall configure SCK SPI channel frequency to as below with a duty cycle of 50% +/- 20%:\nBoard\nFrequency\nPrecision\nESSNESS\n2.5 MHz\n+/- 1%\nSDSIO\n312.5 KHz\n+/- 1%\nTIE\n312.5 KHz\n+/- 1%\nTable 2 : Frequency per board configuration', 'additional': u' \t', 'issue': u' \t2', 'derived': u' \tYES', 'allocation': u' \tESSNESS_BITE_SW, SDSIO_BITE_SW, TIE_BITE_SW', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'ICD_SPI_002': {'status': u' \tMATURE', 'body': u'SPI master shall active low the SPI clock (SCK) polarity.', 'additional': u' \t', 'issue': u' \t2', 'derived': u' \tYES', 'allocation': u' \tESSNESS_BITE_SW, SDSIO_BITE_SW, TIE_BITE_SW', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'ICD_SPI_005': {'status': u' \tMATURE', 'body': u'The master shall set active Slave Synchronization signal (SS), and hold it during the whole frame reception.', 'additional': u' \t', 'issue': u' \t2', 'derived': u' \tYES', 'allocation': u' \tESSNESS_BITE_SW, SDSIO_BITE_SW, TIE_BITE_SW', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'ICD_SPI_004': {'status': u' \tMATURE', 'body': u'SPI master shall active low the SS signal polarity.', 'additional': u' \t', 'issue': u' \t2', 'derived': u' \tYES', 'allocation': u' \tESSNESS_BITE_SW, SDSIO_BITE_SW, TIE_BITE_SW', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'ICD_SPI_007': {'status': u' \tMATURE', 'body': u'SPI master shall generate the following signals and respect the following timings between them for every frame reception:\nParam n\xb0\nCharacteristic\nMin\nTyp\nMax\nUnits \nt1\nSS assertion to first clock\n200\n-\n-\n\u03bcs\nt2\nLast clock to SS deassertion\n5\n-\n-\n\u03bcs\nTable 3 : Electrical timings', 'additional': u' \tt1 is set to 200\xb5s minimum in order to assure that all data are ready in the slave component (case of ESSNESS boards)', 'issue': u' \t3', 'derived': u' \tYES', 'allocation': u' \tESSNESS_BITE_SW, SDSIO_BITE_SW, TIE_BITE_SW', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'ICD_SPI_006': {'status': u' \tMATURE', 'body': u'SPI slave shall change data on Master In Slave Out(MISO) on transition from active clock state to inactive clock state.', 'additional': u' \t', 'issue': u' \t1', 'derived': u' \tYES', 'allocation': u' \tESSNESS_ENM_SW, SDSIO_PLD, TIE_PLD', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'ICD_SPI_008': {'status': u' \tMATURE', 'body': u'SPI master shall read Master In Slave Out (MISO) on transition from inactive clock state to active clock state.', 'additional': u' \t', 'issue': u' \t2', 'derived': u' \tYES', 'allocation': u' \tESSNESS_BITE_SW, SDSIO_BITE_SW, TIE_BITE_SW', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_1040': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, GPU_PHASE_ORDER_DELAY shall be set to active when one at least of the following condition is true:\nAt power-up\nGPU_POWER_READY goes from ON to OFF state', 'additional': u'\tAdded by SACR541', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define GPU_PHASE_ORDER_DELAY at power-up', 'issue': u'\t6', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_1041': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, GPU_PHASE_ORDER_DELAY shall be set to inactive when GPU_POWER_READY goes from OFF to ON state.', 'additional': u'\tAdded by SACR541', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_8043]'}, u'SSCS_ESSNESS_1042': {'status': u'\tTBC', 'body': u'In case of RNESS configuration, GPU_PHASE_ORDER_DELAY shall be set to active 110ms +/-10ms TBC after GPU_POWER_READY goes from OFF to ON state.', 'additional': u'\tAdded by SACR541', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_8043]'}, u'SSCS_ESSNESS_0601': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, GPU protections shall be set to inactive when one at least of the following conditions is met:\nAt power up of the board\nRising edge on DSI_CAB_INV1_OVERTEMP_GPU_SW_EPPC\nGPU presence is inactive since more than 1s +/-10ms AND 28V_3_PRESENCE is inactive since more than 1s +/-10ms\nConcerned GPU protections are:\nGPU overvoltage protection\nGPU overload protection\nGPU undervoltage protection\nGPU frequency protection\nGPU driver fail protection', 'additional': u'\tThe 7,6V threshold cannot be assumed replace by the presence tension on 28V_GPU (see what is the threshold implemented on board) / Modified according SACR439', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_2028],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_0600': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, GPU protections shall be latched to avoid cycling\nConcerned GPU protections are:\nGPU overvoltage protection\nGPU overload protection\nGPU undervoltage protection\nGPU frequency protection\nGPU phase order protection\nGPU driver fail protection', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_0490]'}, u'SSCS_ESSNESS_0603': {'status': u'\tTBC', 'body': u'In case of RNESS configuration, when GPU_POWER_READY is in ON state, GPU overload protection shall be activated when accumulated current flowing through current transformer (CT_GPU_MAX) is above curve defined hereafter (with 10% tolerances in time and current TBC)\nWhen I > Isat, delay is 100ms\nWhen 120A < I< Isat delay is computed according curve described with following parameters\nIsat = 300A\nTsat = 10s\nIth = 120A\nTth = 680s\nWhen I < 120A, the accumulation current process is stopped\nThe delay computed is 40ms shorter than this curve in order to take into account the system response time', 'additional': u'\tThe overload protection is computed with the max current of the three phases,\tGPU current is monitoring through CT, see \xa72.6.7,\tModified according SyCR54 and SACR700,\tThe accumulation current process is described in GS3682', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_108],\t[SDTS_PDS_0403]'}, u'SSCS_ESSNESS_0602': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, GPU phase order protection shall be set to inactive when all following conditions are true:\nAt power up of the board\nGPU presence is inactive since more than 1s +/- 10ms\n28V_3_PRESENCE is inactive since more than 1s +/- 10ms', 'additional': u'\tModified according SACR439', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_4000],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_0605': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0604': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0607': {'status': u'\tTBC', 'body': u'In case of RNESS configuration, when GPU_POWER_READY is in ON state, GPU frequency protection, measured on GPU_PHA, shall be activated when one of the following condition is true:\nGPU frequency is over 420 Hz (+/-4Hz) TBC since more than 980ms +/-10ms\nGPU frequency is under 380 Hz (+/-4Hz) TBC since more than 980ms +/-10ms', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_110],\t[SDTS_PDS_113],\t[SDTS_PDS_0403],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_0606': {'status': u'\tTBC', 'body': u'In case of RNESS configuration, GPU phase order protection shall be activated when difference between phase GPU_PHA and phase GPU_PHB is not 120\xb0 +/- 10\xb0 and GPU_PHASE_ORDER_DELAY is inactive', 'additional': u'\tPhase order is evaluated through two phases, GPU_PhA and GPU_PhB,\tThis definition corresponds to MIL STD704F (the sign of the difference is relevant -120\xb0 is not equal to 120\xb0),\tModified according SACR541', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_109],\t[SDTS_PDS_0403],\t[SDTS_PDS_8043]'}, u'SSCS_ESSNESS_0609': {'status': u'\tTBC', 'body': u'In case of RNESS configuration, when GPU_POWER_READY is in ON state, GPU undervoltage protection shall be activated when voltage (GPU_MIN) is under following voltage threshold during more than the defined delay:\nThe detection of the default will be 20ms faster than the time defined hereafter.\ndelay\nvoltage threshold\n180ms +/-5ms TBC\n30Vrms +/- 4Vrms TBC\n980ms +/-10ms\n100Vrms +/- 4Vrms TBC\nFigure 11: Undervoltage definition', 'additional': u'\tThe SDTS doesn\u2019t take into account the response time of the system,\t1% delay tolerance cannot be achieve for the first threshold due to 5ms minimum response time of microocntroller', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_112],\t[SDTS_PDS_113],\t[SDTS_PDS_0403],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_0608': {'status': u'\tTBC', 'body': u'In case of RNESS configuration, when GPU_POWER_READY is in ON state, GPU overvoltage protection shall be activated when voltage (GPU_MAX) is over the curve hereafter.\nThe detection of the default will be 40ms faster than the time delay defined  hereafter.\nTolerance in time 10% TBC\nTolerance in tension 10% TBC\nFigure 10: Overvoltage definition', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_111],\t[SDTS_PDS_113],\t[SDTS_PDS_0403]'}, u'SSCS_ESSNESS_5300': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall acquire and scale the following analog inputs, corresponding to currents measured by Hall Effect Sensors (HES):\nASI_HES1_CH1 corresponds to the differential input HES1_CH1_HIGH / HES1_CH1_LOW\nASI_HES1_CH2 corresponds to the differential input HES1_CH2_HIGH / HES1_CH2_LOW\nASI_HES2_CH1 corresponds to the differential input HES2_CH1_HIGH / HES2_CH1_LOW', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_531]'}, u'SSCS_ESSNESS_2302': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, DSO_CABIN_GALLEY_MASTER shall be activated when GALLEY_SW is in AUTO state\nElse it is inactive.', 'additional': u'\tGALLEY_SW is described in 2.4.5', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6510]'}, u'SSCS_ESSNESS_7861': {'status': u'\tMATURE', 'body': u'In case of NESS configuration,the BITE microcontroller shall deactivate CBIT_TRU_CURRENT_CH2_VALID when one at least of the following condition is true:\nDSI_TRC_STATUS is open, and the ASI_HES1_CH2 is outside the following range [-10A; +10A] during 1s +/-10ms\nASI_HES1_CH2 is over 75A +/-1,5A\n(ASI_HES1_CH2 is under -40A AND ASI_HES1_CH1 is over 100A AND CBIT_TRU_CURRENT_CH1_VALID is active) during 1s +/-10ms', 'additional': u'\tThe HES cannot read 75A, this threshold corresponds to the 11V indicating that there is a default on the HES,\tModified according SACR453', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7048],\t[SDTS_PDS_7051],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_2300': {'status': u'\tMATURE', 'body': u'In case of NESS board, at power up, the signal DSO_CABIN_GALLEY_MASTER shall be inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_2301': {'status': u'\tMATURE', 'body': u'In case of LNESS configuration, DSO_CABIN_GALLEY_MASTER shall be activated when one at least of the following conditions is true:\nCABIN_MASTER_SW is in AUTO state\nCABIN_MASTER_SW is in SHED state\nElse it is inactive.', 'additional': u'\tCABIN_MASTER_SW is described in 2.4.3', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7074]'}, u'SSCS_ESSNESS_4021': {'status': u'\tMATURE', 'body': u'The ESSNESS electrical interface shall be according following document [38].', 'additional': 'EMPTY', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tthis document defines pinout allocation for ESSNESS board', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4020': {'status': u'\tMATURE', 'body': u'The ESSNESS electrical connectors P/N shall be:\nP1:\t\tHDC25M42R300ZS1 (SUBD 25)\nP2:\t\tKND98-17-10-110 (HYPERTAC 98)\nP3:\t\tKND98-17-10-110 (HYPERTAC 98)\nP4:\t\t284881 (DIN 64)\nP5:\t\tSMPL26M0NSS0LB (26)\nP6:\t\t364842 (DIN 64)\nP7:\t\tKND98-17-10-110 (HYPERTAC 98)', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tconnector are given in mechanical drawing', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7866': {'status': u'\tMATURE', 'body': u'In case of NESS configuration,the BITE microcontroller shall activate CBIT_TRU_CURRENT_CH1_VALID and CBIT_TRU_CURRENT_CH2_VALID when TRU_SW enters AUTO state.', 'additional': u'\tModified according SACR453', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7047],\t[SDTS_PDS_7048],\t[SDTS_PDS_7050],\t[SDTS_PDS_7051]'}, u'SSCS_ESSNESS_0214': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, BAT driver fail protection shall be activated when CONTACT_A_TRIP is active and 28V_A is over 18,5V +/-0,5V.', 'additional': u'\tmodified according SyCR17 / SACR258', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7158],\t[SDTS_PDS_7119],\t[SDTS_PDS_8007],\t[SDTS_PDS_8008]'}, u'SSCS_ESSNESS_0215': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, at power-up BAT_CURRENT shall be 0A', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define the value of BAT_CURRENT at power-up', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0212': {'status': u'\tTBC', 'body': u'In case of ESS configuration, BAT_HIGH_CURRENT shall be active when BAT_CURRENT is above 400A +/-20A TBC\nElse it is inactive', 'additional': u'\tTolerances in current are defined as the tolerance of the HES and 1% of the full scale for the board', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7117],\t[SDTS_PDS_7118],\t[SDTS_PDS_7009]'}, u'SSCS_ESSNESS_0213': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, BAT reverse protection shall be reset (set to inactive) when DSI_RATLC_SLC_OPP_STATUS is closed', 'additional': u'\tBattery current is monitoring by Hall Effect Sensor see \xa72.6.6 / A/C in flight is defined in 2.6.1 / modified according SyCR17', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7067],\t[SDTS_PDS_7068]'}, u'SSCS_ESSNESS_0210': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, BAT_PROTECTION shall be activated when one at least of the following conditions is TRUE:\nBAT overload protection is active\nBAT reverse protection is active\nBAT deep discharge protection is active\nBAT driver fail protection is active\nElse it is inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_EQUAT_305],\t[SDTS_PDS_EQUAT_405]'}, u'SSCS_ESSNESS_0211': {'status': u'\tTBC', 'body': u'In case of ESS configuration, BAT_CURRENT shall be defined as follow:\nIf ASI_HES1_CH2 (calibrated) goes over 45A +/-1A TBC or under -45A +/-1A TBC then BAT_CURRENT corresponds to ASI_HES1_CH1 (calibrated)\nIf ASI_HES1_CH2 (calibrated) goes under 40A +/-1A TBC and over -40A +/-1A TBC then BAT_CURRENT corresponds to ASI_HES1_CH2 (calibrated)', 'additional': u'\tModified according SyCR59', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7251],\t[SDTS_PDS_7252]'}, u'SSCS_ESSNESS_1031': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, 500ms +/-5ms after power-up, the FUNC and BITE microcontrollers shall:\nset CABIN_MASTER_STATUS to inactive when DSI_ISOLATION_SMOKE_GALLEY_CABIN_MASTER is inactive\nset CABIN_MASTER_STATUS to active when DSI_ISOLATION_SMOKE_GALLEY_CABIN_MASTER is active', 'additional': u'\tAdded according SACR299', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_8042],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_1030': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, the FUNC and BITE microcontrollers shall set to active CABIN_MASTER_STATUS at power-up', 'additional': u'\tAdded according SACR299', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_8042]'}, u'SSCS_ESSNESS_3205': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, TRU_HIGH_CURRENT and TRU_OVL_IN_PROGRESS shall be managed according following logic, when the FUNC_TRU_OVL_FAIL is inactive:\nIf duty cycle of DSI_TRU_OVL_GEN_OVL_SC is 15% +/-3% or 85% +/-3%\nTRU_HIGH_CURRENT is inactive\nTRU_OVL_IN_PROGRESS is inactive\nElse if Ton of DSI_TRU_OVL_GEN_OVL_SC is 30% +/-3% or 70% +/-3%\nTRU_HIGH_CURRENT is active\nTRU_OVL_IN_PROGRESS is inactive\nElse if Ton of DSI_TRU_OVL_GEN_OVL_SC is 45% +/-3% or 55% +/-3%\nTRU_HIGH_CURRENT is active\nTRU_OVL_IN_PROGRESS is active', 'additional': u'\tsee \xa78.4.8 for FUNC_TRU_OVL_FAIL definition / modified according SACR291', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_7116],\t[SDTS_PDS_7059],\t[SDTS_PDS_7064],\t[SDTS_PDS_7058],\t[SDTS_PDS_7062],\t[SDTS_PDS_7066]'}, u'SSCS_ESSNESS_0959': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, at power-up, xALTC1_HIGH_CURRENT shall be set to inactive', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define xALTC1_HIGH_CURRENT at power-up', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0958': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, xALTC1_PROTECTION shall be activated when one at least of the following conditions is TRUE:\nxALTC1 overload protection is active\nxALTC1 driver fail protection is active\nElse it is inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_EQUAT_301],\t[SDTS_PDS_EQUAT_401]'}, u'SSCS_ESSNESS_9124': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3902': {'status': u'\tMATURE', 'body': u'In case of ESS or RNESS configuration, the FUNC and BITE microcontrollers shall acquire:\nASI_ALT_GPU_PHA\nASI_ALT_GPU_PHB\nASI_ALT_GPU_PHC', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThose voltages are used for functional purpose', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0951': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, xALTC1 protections shall be set to inactive when one at least of the following conditions is met:\nAt power-up\nDSI_GLC_STATUS goes from open to closed \nConcerned xALTC1 protections are:\nxALTC1 overload protection\nxALTC1 driver fail protection', 'additional': u'\tModified according SACR439', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_5035],\t[SDTS_PDS_5031]'}, u'SSCS_ESSNESS_0950': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, xALTC1 protections shall be latched in order to avoid cycling.\nConcerned xALTC1 protections are:\nxALTC1 overload protection\nxALTC1 driver fail protection', 'additional': u'\tThe latch of protections means that if a protection is not reset it will be memorised until the next power down', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_5034],\t[SDTS_PDS_5030]'}, u'SSCS_ESSNESS_0953': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, the current flowing through xALTC1 (CT_xALTC1_MAX) shall be evaluated as the maximum of ASI_CT3_PhA, ASI_CT3_PhB, ASI_CT3_PhC.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_2630],\t[SDTS_PDS_2635]'}, u'SSCS_ESSNESS_0952': {'status': u'\tTBC', 'body': u'In case of ESS configuration, xALTC1 overload protection shall be activated when the accumulated current through xALTC1 contactor (CT_xALTC1_MAX) is above curve defined  according parameters (with 10% tolerance in time and current TBC):\nIsat = 400A\nTsat = 0,1s\nIth = 40A\nTth = 4000s\nThe delay computed is 40ms shorter than this curve in order to take into account the system response time', 'additional': u'\tModified according SyCR56,\tThe accumulation current process is described in GS3682', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_2630],\t[SDTS_PDS_2635]'}, u'SSCS_ESSNESS_0955': {'status': u'\tTBC', 'body': u'In case of ESS configuration, xALTC1_HIGH_CURRENT shall be activated when CT_xALTC1_MAX  is over 40 Arms (+/-10%) TBC', 'additional': u'\tProcess active is not defined in GS3682 / when the current is over current threshold the computed energy is increasing otherwise it\u2019s decreasing', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7097],\t[SDTS_PDS_7101]'}, u'SSCS_ESSNESS_3901': {'status': u'\tMATURE', 'body': u'The FUNC and BITE microcontrollers shall acquire:\nASI_MAIN_115_PHA\nASI_MAIN_115_PHB\nASI_MAIN_115_PHC', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThose voltages are used for functional purpose', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0957': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, xALTC1 driver fail protection shall be activated when CONTACT_E_TRIP is active and 28V_E is over 18,5V +/-0,5V', 'additional': u'\tmodified according SyCR17 / SACR258', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7146],\t[SDTS_PDS_7148],\t[SDTS_PDS_8007],\t[SDTS_PDS_8008]'}, u'SSCS_ESSNESS_0956': {'status': u'\tTBC', 'body': u'In case of ESS configuration, xALTC1_HIGH_CURRENT shall be deactivated when the following condition is true:\nCT_xALTC1_MAX  is under 40Arms (+/-10%) TBC for at least 100ms +/-5ms TBC', 'additional': u'\taccumulation current process cannot be active and decreasing simultaneously,\t1% delay tolerance will not be achieved,\tDefinition of accumulation process is available in GS3682  / when the current is over current threshold the computed energy is increasing otherwise it\u2019s decreasing', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7098],\t[SDTS_PDS_7102],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_4620': {'status': u'\tMATURE', 'body': u'In case of NESS configurations, if SSM_56 is Normal Operation and bit 19 of label 56 is TRUE (1)\nThen ENG2_OFF shall be active\nElse ENG2_OFF is inactive', 'additional': u'\tAdded according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_8055],\t[SDTS_PDS_8060]'}, u'SSCS_ESSNESS_5410': {'status': u'\tMATURE', 'body': u'The AC RMS current measurement accuracy shall be +/- 3 % of the measured value in the whole frequency range.', 'additional': u'\tBoard is designed with previous value of this requirement which was 5%,\tThis tolerance has to be achieve at board level (not for the whole system)', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7011]'}, u'SSCS_ESSNESS_8011': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9120': {'status': u'\tDEL', 'body': u'DELETED.', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2230': {'status': u'\tMATURE', 'body': u'At power up, the signal DSO_L_28OPEN_1 shall be inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_2231': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3518': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, the BITE microcontroller shall acquire and average during 250ms +/-2,5ms ASI_HES1_CH2 current (calibrated) measurement, if the CBIT_BITE_BAT_CURRENT_CH2_VALID is active, computed value is called ASI_HES1_CH2_AV.', 'additional': u'\tdata are sent on ARINC / Modified according SACR448', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_7010],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_3519': {'status': u'\tMATURE', 'body': u'In case of RESS configuration, the BITE microcontroller shall acquire and average during 250ms +/-2,5ms ASI_HES2_CH1 current measurement, if the CBIT_SHP_CURRENT_CH1 is active computed value is called ASI_HES2_CH1_AV..', 'additional': u'\tdata are sent on ARINC', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7010],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_7852': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3905': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3510': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3511': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3512': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3513': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3514': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3515': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3516': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, the BITE microcontroller shall acquire and average during 250ms +/-2,5ms ASI_HES1_CH1 current (calibrated) measurement, if the CBIT_BITE_BAT_CURRENT_CH1_VALID is active, computed value is called ASI_HES1_CH1_AV.', 'additional': u'\tdata are sent on ARINC', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7010],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_2025': {'status': u'\tMATURE', 'body': u'In case of ESS board configuration, the ESSNESS board shall control DSO_BAT_HEATER_RELAY2 according following logic:\nWhen DSI_BC_STATUS is closed and DSI_POWER_ON is active, DSO_BAT_HEATER_RELAY2 is active\nWhen DSI_BC_STATUS is open, DSO_BAT_HEATER_RELAY2 is inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7075],\t[SDTS_PDS_7078]'}, u'ICD_SPI_ESSNESS_DATA_0065': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0064': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0067': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0066': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0061': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0060': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0063': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0062': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0069': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0068': {'issue': '1'}, u'SSCS_ESSNESS_7892': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0810': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, CABC driver fail protection shall be activated when CONTACT_D_TRIP is active and 28V_D is over 18,5V +/-0,5V', 'additional': u'\tmodified according SyCR17 / SACR258', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7128],\t[SDTS_PDS_7131],\t[SDTS_PDS_8007],\t[SDTS_PDS_8008]'}, u'SSCS_ESSNESS_0811': {'status': u'\tTBC', 'body': u'In case of LNESS board, CABC1_SHED shall be deactivated when all following conditions are met:\nCABC overload protection is not active (see \xa72.3.7)\nCABC driver fail protection is not active\nTSBC_OVL_IN_PROGRESS is not active or DSI_TC_STATUS is open\nTRU_OVL_IN_PROGRESS is not active\nNESS_MAIN_115VAC_FAULT is not active\nTIE_ALT_115VAC_FAULT is inactive or DSI_TAC_STATUS is open\nSTBY_TRU_TEMP below 100\xb0C or STBY_TRU_FAN_FAIL is active or DSI_TSBC_STATUS is open or DSI_TC_STATUS is open\nSTBY_TRU_TEMP below 80\xb0C or STBY_TRU_FAN_FAIL is inactive or DSI_TSBC_STATUS is open or DSI_TC_STATUS is open\nBAT_TRU_TEMP below 100 +/- 10\xb0C TBC OR FUNC_TRU_FAN_FAILURE is active OR DSI_TRC_STATUS is open\nBAT_TRU_TEMP below 80 +/- 10\xb0C TBC OR FUNC_TRU_FAN_FAILURE is inactive OR DSI_TRC_STATUS is open\nASI_DC_AREA_TEMP below 140\xb0C +/- 10\xb0C TBC (see \xa72.6.2)\nCABIN_MASTER_SW enters AUTO state (see \xa72.4.3)', 'additional': u'\tModified according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_4028]'}, u'SSCS_ESSNESS_0812': {'status': u'\tTBC', 'body': u'In case of RNESS board, CABC2_SHED shall be deactivated when all the following conditions are met:\nCABC overload protection is not active (see \xa72.3.7)\nCABC driver fail is not active\nTSBC_OVL_IN_PROGRESS is inactive or DSI_TC_STATUS is open\nTRU_OVL_IN_PROGRESS is inactive\nNESS_MAIN_115VAC_FAULT is inactive\nTIE_ALT_115VAC_FAULT is inactive or DSI_TAC_STATUS is open\nSTBY_TRU_TEMP below 100\xb0C or STBY_TRU_FAN_FAIL is active or DSI_TSBC_STATUS is open or DSI_TC_STATUS is open\nSTBY_TRU_TEMP below 80\xb0C or STBY_TRU_FAN_FAIL is inactive or DSI_TSBC_STATUS is open or DSI_TC_STATUS is open\nBAT_TRU_TEMP below 100 +/- 10\xb0C TBC OR FUNC_TRU_FAN_FAILURE is active OR DSI_TRC_STATUS is open\nBAT_TRU_TEMP below 80 +/- 10\xb0C TBC OR FUNC_TRU_FAN_FAILURE is inactive OR DSI_TRC_STATUS is open\nASI_DC_AREA_TEMP below 140 +/- 10\xb0C TBC (see \xa72.6.2)\nCABIN_MASTER_STATUS switches from inactive to active', 'additional': u'\tModified according SACR299 / Modified according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_4030]'}, u'SSCS_ESSNESS_0813': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, CABC overload protection and CABC driver fail protection shall be set to inactive when CABIN_MASTER_STATUS goes from inactive to active.', 'additional': u'\tModified according SACR439 / SACR299', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_743]'}, u'SSCS_ESSNESS_2041': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2040': {'status': u'\tMATURE', 'body': u'In case of NESS board, at power up, the signal DSO_150MA_GNDOPEN_2 shall be inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware,\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_163]'}, u'ICD_SPI_ESSNESS_DATA_0098': {'issue': '2'}, u'ICD_SPI_ESSNESS_DATA_0099': {'issue': '2'}, u'SSCS_ESSNESS_0508': {'status': u'\tTBC', 'body': u'In case of NESS configuration, the MAIN_115_MIN shall be evaluated as the minimum of ASI_MAIN_115_PhA, ASI_MAIN_115_PhB, ASI_MAIN_115_PhC [TBC] ', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tAs the protection deals with undervoltage, the voltage used to compute the protection is the minimum voltage in order to reduce activation delay', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0509': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, GALC_PROTECTION shall be activated when one at least of the following is true:\nGALC overload protection is active\nGALC distortion protection is active\nGALC unbalanced load protection is active\nGALC undervoltage protection is active\nGALC driver fail protection is active\nElse it is inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_EQUAT_101],\t[SDTS_PDS_EQUAT_203]'}, u'SSCS_ESSNESS_0502': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, GALC protections shall be set to inactive when GALLEY_SW enters AUTO state.\nConcerned GALC protections are:\nGALC overload protection\nGALC distortion protection\nGALC unbalanced load protection\nGALC undervoltage protection\nGALC driver fail protection\nGALC_SHED', 'additional': u'\tGALLEY_SW states are defined in \xa72.4.5 / Modified according SACR439', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_4054]'}, u'SSCS_ESSNESS_0503': {'status': u'\tTBC', 'body': u'In case of NESS configuration, GALC overload protection shall be activated when current flowing through GALC (CT_GALC_MAX) is above curve defined hereafter (40ms earlier):\nThreshold tolerance in current is 10%TBC\nFirst delay 100ms +/-5ms TBC\nSecond delay 500ms +/-5ms\nThird delay 120s +/-120ms\nFigure 8 : GALC overload protection', 'additional': u'\tGALC current is monitoring through CT see \xa72.6.7,\tThe SDTS doesn\u2019t take into account the response time of the system,\tThe delay tolerance of 1% cannot be achieve for the first point due to 5ms minimum response time of the microcontroller', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_728],\t[SDTS_PDS_609],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_0500': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, GALC protections shall be latched to avoid cycling.\nConcerned GALC protections are:\nGALC overload protection\nGALC distortion protection\nGALC unbalanced load protection\nGALC undervoltage protection\nGALC driver fail protection\nGALC_SHED', 'additional': u'\tThe latch of protections means that if a protection is not reset it will be memorised until the next power down ,\tGALC1_SHED and GALC2_SHED are not latched in SDTS5d4', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_729],\t[SDTS_PDS_720]'}, u'SSCS_ESSNESS_0501': {'status': u'\tMATURE', 'body': u'In case of LNESS configuration, GALC protections shall be set to inactive when CABIN_SW enters AUTO state\nConcerned GALC protections are:\nGALC overload protection\nGALC distortion protection\nGALC unbalanced load protection\nGALC undervoltage protection\nGALC driver fail protection\nGALC_SHED', 'additional': u'\tCABIN_SW states are defined in \xa72.4.4 / Modified according SACR439', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_2021]'}, u'SSCS_ESSNESS_0506': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, the current flowing through GALC (CT_GALC_MAX) shall be evaluated as the maximum of ASI_CT1_PhA, ASI_CT1_PhB, ASI_CT1_PhC.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_609],\t[SDTS_PDS_728]'}, u'SSCS_ESSNESS_0507': {'status': u'\tTBC', 'body': u'In case of NESS configuration, GALC undervoltage protection shall be active when all the following conditions are true:\nMAIN_115_MIN is below 100Vrms +/-4V TBC during 110ms +/-5ms TBC\nDSI_EMP_B_CMD_HSCM_1_GALC is closed \nDSI_GLC_STATUS is closed or DSI_TAC_STATUS is closed', 'additional': u'\tThe SDTS doesn\u2019t take into account the response time of the system (delay reduced by 40ms),\t1% delay tolerance cannot be respected due to 5ms microcontroller minimum response time,\tModified according SACR533', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_0811],\t[SDTS_PDS_0814],\t[SDTS_PDS_7006],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_0504': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, GALC distortion protection shall be activated when GALC_DISTO is active', 'additional': u'\tThis requirement has to be written more clearly', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThe distortion will be computed by a dedicated programmable device and the output of this device is read by FUNC microcontroller', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0505': {'status': u'\tTBC', 'body': u'In case of NESS configuration, GALC unbalanced load protection shall be active when at least one difference between phases is higher than 10Arms +/-5Arms (absolute value) TBC during 2min +/-1,2s, Current on GALC load correspond to ASI_CT1_PhA, ASI_CT1_PhB, ASI_CT1_PhC', 'additional': u'\tCalibre CT of GALC are 100A => an error of 5% on the CT channel can activate the protection whereas there is no problem, threshold is fixed to 10Arms ', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_0810],\t[SDTS_PDS_0813],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_5703': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, the ESSNESS board shall generate the following DSO:\nName\nType\nComments\nDSO_L_GNDOPEN_1\nGND / Open\nDSO_GND_OPEN_20mA_WITHOUT_LIGHTNING\nDSO_L_GNDOPEN_2\nGND / Open\nDSO_GND_OPEN_20mA_WITHOUT_LIGHTNING\nDSO_CAB_GAL_LT\nGND / Open\nDSO_GND_OPEN_50mA_OCP_WITH_LIGHTNING\nDSO_MASTER_SHED_OFF_LT\nGND / Open\nDSO_GND_OPEN_50mA_OCP_WITH_LIGHTNING\nDSO_CABIN_GALLEY_MASTER\nGND / Open\nDSO_GND_OPEN_20mA_WITH_LIGHTNING\nDSO_150MA_GNDOPEN_1\nGND / Open\nDSO_GND_OPEN_150mA_WITHOUT_LIGHTNING\nDSO_150MA_GNDOPEN_2\nGND / Open\nDSO_GND_OPEN_150mA_WITHOUT_LIGHTNING\nDSO_FWD_WATER_HEATER_AUTHORISED\nGND / Open\nDSO_GND_OPEN_400mA_WITH_LIGHTNING\nDSO_AFT_WATER_HEATER_AUTHORISED\nGND / Open\nDSO_GND_OPEN_400mA_WITH_LIGHTNING\nDSO_SHED_GENERATOR_FAIL\nGND / Open\nDSO_GND_OPEN_500mA_WITH_LIGHTNING\nDSO_CABIN_MASTER_ON\nGND / Open\nDSO_GND_OPEN_500mA_WITH_LIGHTNING\nDSO_CABIN_AC_MASTER_GALLEY_MASTER\nGND / Open\nDSO_GND_OPEN_500mA_WITH_LIGHTNING\nDSO_GALLEY_MASTER_ON\nGND / Open\nDSO_GND_OPEN_500mA_WITH_LIGHTNING\nDSO_EPP_LT\n28V / Open\nDSO_28V_OPEN_20mA_WITH_LIGHTNING\nDSO_GPU_CONNECTION_STATUS\n28V / Open\nDSO_28V_OPEN_20mA_WITH_LIGHTNING\nDSO_SPARE\n28V / Open\nDSO_28V_OPEN_20mA_WITH_LIGHTNING\nTable 24: DSO complementary interface of NESS board', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_386]'}, u'SSCS_ESSNESS_5702': {'status': u'\tMATURE', 'body': u'According to board configuration, the correspondence between signal name in ESSNESS board interface and signal name in the PDS shall be according following table:\nName\nLESS\nRESS\nLNESS\nRNESS\nDSO_BAT_TRU_LT\nBC1_STATUS\nBC2_STATUS\nTRU1_LT\nTRU2_LT\nDSO_TRC_CMD\nSPARE\nSPARE\nTRC1_CMD\nTRC2_CMD\nDSO_TC_RESET\nSPARE\nSPARE\nTC1_RESET\nTC2_RESET\nDSO_xALTC1_HES_TRU_CURRENT\nLALTC1_HIGH_CURRENT\nRALTC1_HIGH_CURRENT\nHES_TRU1_CURRENT\nHES_TRU2_CURRENT\nDSO_CABC_SHED\nSPARE\nSPARE\nSPARE\nCABC2_SHED\nDSO_SHED_ENG_FAIL\nSPARE\nSPARE\nSHED_ENG_FAIL_1\nSHED_ENG_FAIL_2\nDSO_SHED_START\nSPARE\nSPARE\nSHED_START_1\nSHED_START_2\nDSO_BAT_HEATER_TRU_FAN_POWER\nBAT1_Heater_Relay\nBAT2_Heater_Relay\nTRU1_FAN_POWER\nTRU2_FAN_POWER\nDSO_L_28OPEN_1\nSPARE\nSPARE\nSPARE\nSPARE\nDSO_APU_ECU_HPP_RELAY_CMD\nSPARE\nAPU_ECU_RELAY_CMD\nHPP_A_CMD_RELAY\nHPP_B_CMD_RELAY\nDSO_M_28OPEN_1\nSPARE\nSPARE\nSPARE\nSPARE\nDSO_M_28OPEN_2\nSPARE\nSPARE\nSPARE\nSPARE\nDSO_FAN_POWER_PPDB\nFAN1_POWER_B\nFAN2_POWER_B\nFAN1_POWER_A\nFAN2_POWER_A\nDSO_ESS_TRU_STATUS\nLESS_STATUS\nRESS_STATUS\nTRU1_OVL\nTRU2_OVL\nDSO_BAT_HEATER_RELAY2\nBAT1_Heater_Relay_2\nBAT2_Heater_Relay_2\nSPARE\nSPARE\nTable 25: DSO correspondence between ESSNESS names and system names', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_535],\t[SDTS_PDS_386]'}, u'SSCS_ESSNESS_3978': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, the FUNC microcontroller shall acquire:\nCONTACT_C_TRIP', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tto define monitoring of contactor driver failure', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3979': {'status': u'\tMATURE', 'body': u'In case of LESS, RESS and RNESS configuration, the BITE microcontroller shall acquire  28V_3_PRESENCE.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tto define voltage presence monitoring', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5704': {'status': u'\tMATURE', 'body': u'According to board configuration, the correspondence between signal name in ESSNESS board interface and signal name in the PDS shall be according following table:\nName\nLNESS\nRNESS\nDSO_L_GNDOPEN_1\nSPARE\nSPARE\nDSO_L_GNDOPEN_2\nSPARE\nSPARE\nDSO_CAB_GAL_LT\nCABIN_LT\nGALLEY_LT\nDSO_MASTER_SHED_OFF_LT\nMASTER_SHED_LT\nMASTER_OFF_LT\nDSO_CABIN_GALLEY_MASTER\nCABIN_MASTER_STATUS\nGALLEY_MASTER_TO_LH\nDSO_150MA_GNDOPEN_1\nSPARE\nSPARE\nDSO_150MA_GNDOPEN_2\nSPARE\nSPARE\nDSO_FWD_WATER_HEATER_AUTHORISED\nLH_FWD_WATER_HEATER_AUTHORISED\nRH_FWD_WATER_HEATER_AUTHORISED\nDSO_AFT_WATER_HEATER_AUTHORISED\nLH_AFT_WATER_HEATER_AUTHORISED\nRH_AFT_WATER_HEAT_AUTHORIZED\nDSO_SHED_GENERATOR_FAIL\nSHED_GENERATOR_FAIL1\nSHED_GENERATOR_FAIL2\nDSO_CABIN_MASTER_ON\nLH_CABIN_MASTER_ON_1\nRH_CABIN_MASTER_ON_2\nDSO_CABIN_AC_MASTER_GALLEY_MASTER\nCABIN_AC_MAST_ON\nGALLEY_MASTER_ON_1\nDSO_GALLEY_MASTER_ON\nSPARE\nGALLEY_MASTER_ON_2\nDSO_EPP_LT\nSPARE\nEXTERNAL_POWER_PANEL_LT\nDSO_GPU_CONNECTION_STATUS\nSPARE\nGPU_CONNECTION_STATUS\nDSO_SPARE\nSPARE\nSPARE\nTable 26: DSO complementary correspondence between NESS names and system names', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_386]'}, u'SSCS_ESSNESS_3972': {'status': u'\tMATURE', 'body': u'The FUNC microcontroller shall acquire:\nCONTACT_A_TRIP\nCONTACT_B_TRIP\nCONTACT_D_TRIP\nCONTACT_E_TRIP', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tto define monitoring of contactor driver failure', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3973': {'status': u'\tMATURE', 'body': u'The BITE microcontroller shall acquire 28V_1_PRESENCE, 28V_2_PRESENCE, BAT_TRU_SW_ERROR, COLD_START, BF_ALIM_28V', 'additional': u'\tModified according SACR814', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tto define voltage presence monitoring, BAT_TRU_SW monitoring and COLD_START ', 'issue': u'\t7', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3970': {'status': u'\tMATURE', 'body': u'The FUNC microcontroller shall acquire 28V_1_PRESENCE, 28V_2_PRESENCE, BAT_TRU_SW_ERROR,.COLD_START, BF_ALIM_28V', 'additional': u'\tModified according SACR814', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tto define voltage presence monitoring, BAT_TRU_SW monitoring and COLD_START ', 'issue': u'\t7', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3971': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, the FUNC microcontroller shall acquire:\nTRU_OR\nGALC_DISTO\nMEZZA_PRESENCE, ', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tto define over ripple, presence of the mezzanine and GALC_DISTO acquisition', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3976': {'status': u'\tMATURE', 'body': u'In case of LESS, RESS, RNESS configurations, the FUNC microcontroller shall acquire 28V_3_PRESENCE.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tto define voltage presence monitoring', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3977': {'status': u'\tMATURE', 'body': u'In case of LNESS, RNESS configurations, the FUNC microcontroller shall acquire 28V_4_PRESENCE', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tto define voltage presence monitoring', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3974': {'status': u'\tMATURE', 'body': u'The BITE microcontroller shall acquire:\nCONTACT_A_TRIP\nCONTACT_B_TRIP\nCONTACT_D_TRIP\nCONTACT_E_TRIP', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tto define monitoring of contactor driver failure', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3975': {'status': u'\tMATURE', 'body': u'The BITE microcontroller shall acquire:\nDSO_BAT_HEATER_RELAY2_TRIP\nDSO_APU_ECU_HPP_RELAY_CMD_TRIP\nDSO_FAN_POWER_PPDB_TRIP\nDSO_M_28OPEN_1_TRIP\nDSO_M_28OPEN_2_TRIP\nDSO_SHED_ENG_FAIL_TRIP\nDSO_SHED_GENERATOR_FAIL_TRIP\nDSO_BAT_HEATER_TRU_FAN_POWER_TRIP\nDSO_150MA_GNDOPEN_1_TRIP\nDSO_150MA_GNDOPEN_2_TRIP\nDSO_FWD_WATER_HEATER_AUTHORISED_TRIP\nDSO_AFT_WATER_HEATER_AUTHORISED_TRIP\nDSO_SHED_START_TRIP\nDSO_CABIN_MASTER_ON_TRIP\nDSO_CABIN_AC_MASTER_GALLEY_MASTER_TRIP\nDSO_GALLEY_MASTER_ON_TRIP', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tto define monitoring of DSO driver failure', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9040': {'status': u'\tMATURE', 'body': u'In case of LESS board configuration, the contactor CONTACT_E (LALTC1 contactor) shall be managed according the following diagram', 'additional': u'\tmodified according SyCR17,\tmodified according SyCR43', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7189]'}, u'SSCS_ESSNESS_9041': {'status': u'\tMATURE', 'body': u'In case of RESS board configuration, the contactor CONTACT_E (RALTC1 contactor) shall be managed according the following diagram:', 'additional': u'\tmodified according SyCR17,\tModified according SyCR43', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7191]'}, u'SSCS_ESSNESS_9042': {'status': u'\tMATURE', 'body': u'In case of LNESS board configuration, the contactor CONTACT_E (ATRC1 contactor) shall be managed according the following diagram:', 'additional': u'\tmodified according SyCR17', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7197]'}, u'SSCS_ESSNESS_9043': {'status': u'\tMATURE', 'body': u'In case of RNESS board configuration, the contactor CONTACT_E (ATRC2 contactor) shall be managed according the following diagram:', 'additional': u'\tmodified according SyCR17', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7198]'}, u'SSCS_ESSNESS_4518': {'status': u'\tMATURE', 'body': u'The data sent on ARINC bus and generated by NESS boards shall be sent to BITE of ESS board through CAN bus.', 'additional': u'\tThis requirement will probably be rewritten when ARINC ICD will be finished.', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tIn order to assure that BITE microcontroller has all needed data to elaborate ARINC words.', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9158': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, at power up until DSI_TRU_OVL_GEN_OVL_SC becomes active once, the associated signals shall have the following values:\nTRU_HIGH_CURRENT is inactive\nTRU_OVL_IN_PROGRESS is inactive', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE,\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tdefines the behavior at power up', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6324': {'status': u'\tMATURE', 'body': u'The BITE microcontroller  shall read the P/N of the board', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tBITE has to read the board P/N in order to be able to send it on the CAN busses.', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6325': {'status': u'\tMATURE', 'body': u'The FUNC microcontroller shall read its checksum once at power-up (called FUNC_CHECKSUM).', 'additional': u'\tAdded according SACR485', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to able to send the FUNC checksum on the SPI bus', 'issue': u'\t6', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6326': {'status': u'\tMATURE', 'body': u'The BITE microcontroller shall read its checksum once at power-up (called BITE_CHECKSUM).', 'additional': u'\tAdded according SACR485', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to able to send the BITE checksum on CAN busses', 'issue': u'\t6', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9159': {'status': u'\tMATURE', 'body': u'At power-up FUNC_TSBC_OVL_FAIL shall be inactive.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tdefines the behavior of FUNC_TSBC_OVL_FAIL at power up', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6320': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall acquire its discrete inputs at least every 10ms +/- 1ms', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to assure the refreshing rate of inputs', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6321': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\tRemoved according SACR798', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t7', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6322': {'status': u'\tMATURE', 'body': u'After COLD_START reading, The FUNC microcontroller shall activate UC_FUNC_5S_IN.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThis signal allow to charge the capacitor used for cold start monitoring', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6323': {'status': u'\tMATURE', 'body': u'The BITE microcontroller  shall read three dedicated signals in order to verify which type of microcontroller it is.\nUC_TYPE_1_BITE is active\nUC_TYPE_2_BITE is inactive\nUC_PARITY_BITE is inactive', 'additional': u'\tActive corresponds to 1,\tInactive corresponds to 0', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThose pins allow verifying whether the microcontroller is a FUNC, BITE one, so that if one microcontroller was badly programmed (with the wrong software) it can be detected Three signals are used in order to be able to have a spare configuration is for a third microcontroller if the THD measurement is done with a microcontroller.', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9156': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, when FUNC_TRU_OVL_FAIL is active, TRU_HIGH_CURRENT and TRU_OVL_IN_PROGRESS shall be inactive.', 'additional': u'\tModified according SACR439', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_7116]'}, u'SSCS_ESSNESS_4608': {'status': u'\tTBC', 'body': u'In case of RNESS configuration, when the label [LabelNumber] which b9b10 is 10, SDI of the corresponding label, is not received since more than 200ms +/-20ms TBC, LabelReceived_[LabelNumber] shall be set inactive\nWhere [LabelNumber] is 54, 55, 56 or 74', 'additional': u'\tAdded according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_8067]'}, u'SSCS_ESSNESS_9157': {'status': u'\tMATURE', 'body': u'When CBIT_TRU_OVL_FAIL is active, TRU_HIGH_CURRENT and TRU_OVL_IN_PROGRESS shall be inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7116]'}, u'SSCS_ESSNESS_9154': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9031': {'status': u'\tMATURE', 'body': u'In case of RESS board configuration, the contactor CONTACT_D (SHP contactor) shall be managed according to the following diagram:', 'additional': u'\tmodified according SyCR17 / Modified according SACR439', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_7204]'}, u'SSCS_ESSNESS_9033': {'status': u'\tMATURE', 'body': u'In case of RNESS board configuration, the contactor CONTACT_D (CABC2 contactor) shall be managed according the following diagram:', 'additional': u'\tmodified according SyCR17,\tModified according SyCR28,\tModified according SACR299', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7208]'}, u'SSCS_ESSNESS_9032': {'status': u'\tMATURE', 'body': u'In case of LNESS board configuration, the contactor CONTACT_D (CABC1 contactor) shall be managed according the following diagram:', 'additional': u'\tmodified according SyCR17,\tmodified according SyCR28', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7207]'}, u'SSCS_ESSNESS_7820': {'status': u'\tTBC', 'body': u'If the PCB_TEMP_A is outside the functional range [-55\xb0C; 125\xb0C] TBC, the FUNC microcontroller shall deactivate PCB_AREA_TEMP_A_VALID, else it is be active.', 'additional': u'\tThe range corresponds to the maximal range readable by LM75 component', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tdefinition of CBIT on temperature sensor', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7821': {'status': u'\tTBC', 'body': u'If the PCB_TEMP_B is outside the functional range [-55\xb0C; 125\xb0C] TBC, the FUNC microcontroller shall deactivate PCB_AREA_TEMP_B_VALID, else it is active.', 'additional': u'\tThe range corresponds to the maximal range readable by LM75 component', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tDefinition of CBIT of temperature sensor', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7822': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9130': {'status': u'\tMATURE', 'body': u'TSBC_OVL_IN_PROGRESS and TSBC_HIGH_CURRENT shall be inactive until DSI_TSBC_OVL becomes active once.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE,\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tdefines the behavior of TSBC_OVL_IN_PROGRESS at power up', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9152': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9132': {'status': u'\tMATURE', 'body': u'When duty cycle of DSI_TSBC_OVL is out of the range 15% +/-3% AND out of the range 30% +/-3% AND out of the range 45% +/-3% AND out of the range 55% +/-3% AND out of the range 70% +/-3% AND out of the range 85% +/-3%\nTSBC_OVL_IN_PROGRESS and TSBC_HIGH_CURRENT shall be inactive and FUNC_TSBC_OVL_FAIL is activated', 'additional': u'\tModified according SACR291', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_7046],\t[SDTS_PDS_7045],\t[SDTS_PDS_7214],\t[SDTS_PDS_7161]'}, u'SSCS_ESSNESS_9133': {'status': u'\tMATURE', 'body': u'When CBIT_TSBC_OVL_FAIL is active, CBIT_TSBC_OVL_FAIL shall be deactivated if all the following conditions are true:\nduty cycle of DSI_TSBC_OVL is in the range 15% +/-3% OR out of the range 30% +/-3% OR out of the range 45% +/-3% OR out of the range 55% +/-3% OR out of the range 70% +/-3% OR out of the range 85% +/-3%\nfrequency of DSI_TSBC_OVL is in the range [950Hz, 1.050KHz]', 'additional': u'\tModified according SACR291', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tdefines how to deactivate failure on PWM signal', 'issue': u'\t5', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9134': {'status': u'\tMATURE', 'body': u'When DSI_TSBC_OVL was active once, if its frequency is out of the range [950Hz, 1.050KHz], failure FUNC_TSBC_OVL_FAIL shall be activated and TSBC_OVL_IN_PROGRESS and TSBC_HIGH_CURRENT are inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7214],\t[SDTS_PDS_7161],\t[SDTS_PDS_7045],\t[SDTS_PDS_7046]'}, u'SSCS_ESSNESS_9135': {'status': u'\tMATURE', 'body': u'When duty cycle of DSI_TSBC_OVL is out of the range 15% +/-3% AND out of the range 30% +/-3% AND out of the range 45% +/-3% AND out of the range 55% +/-3% AND out of the range 70% +/-3% AND out of the range 85% +/-3%\nTSBC_OVL_IN_PROGRESS and TSBC_HIGH_CURRENT shall be inactive and CBIT_TSBC_OVL_FAIL is activated', 'additional': u'\tModified according SACR291', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_7045],\t[SDTS_PDS_7046],\t[SDTS_PDS_7214],\t[SDTS_PDS_7161]'}, u'SSCS_ESSNESS_9153': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6104': {'status': u'\tMATURE', 'body': u'A part of the flash memory of the FUNC microcontroller shall be reserved to store hardware data:\nBoard part number\nCompatibility index', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to allow detection of incompatible hardware and software', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6105': {'status': u'\tMATURE', 'body': u'The part of flash memory of the FUNC microcontroller shall include a checksum.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to be able to detect validity of the data registered', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6106': {'status': u'\tMATURE', 'body': u'During PBIT, DSO shall be maintained to inactive state\nESS configuration\nNESS configuration\nDSO_BAT_TRU_LT\nDSO_BAT_TRU_LT\nDSO_CABC_SHED\nDSO_CABC_SHED\nDSO_TRC_CMD\nDSO_TRC_CMD\nDSO_TC_RESET\nDSO_TC_RESET\nDSO_xALTC1_HES_TRU_CURRENT\nDSO_xALTC1_HES_TRU_CURRENT\nDSO_SHED_ENG_FAIL\nDSO_SHED_ENG_FAIL\nDSO_SHED_START\nDSO_SHED_START\nDSO_BAT_HEATER_TRU_FAN_POWER\nDSO_BAT_HEATER_TRU_FAN_POWER\nDSO_ESS_TRU_STATUS\nDSO_ESS_TRU_STATUS\nDSO_BAT_HEATER_RELAY2\nDSO_BAT_HEATER_RELAY2\nDSO_APU_ECU_HPP_RELAY_CMD\nDSO_APU_ECU_HPP_RELAY_CMD\nDSO_FAN_POWER_PPDB\nDSO_FAN_POWER_PPDB\nDSO_L_28OPEN_1\nDSO_L_28OPEN_1\nDSO_M_28OPEN_1\nDSO_M_28OPEN_1\nDSO_M_28OPEN_2\nDSO_M_28OPEN_2\nDSO_CONTACT_B_PU\nDSO_CONTACT_B_PU\nDSO_CONTACT_B_HO\nDSO_CONTACT_B_HO\nDSO_CONTACT_C_PU\nDSO_CONTACT_C_PU\nDSO_CONTACT_C_HO\nDSO_CONTACT_C_HO\nDSO_CONTACT_D_PU\nDSO_CONTACT_D_PU\nDSO_CONTACT_D_HO\nDSO_CONTACT_D_HO\nDSO_CONTACT_E_PU\nDSO_CONTACT_E_PU\nDSO_CONTACT_E_HO\nDSO_CONTACT_E_HO\nNA\nDSO_L_GNDOPEN_1\nNA\nDSO_L_GNDOPEN_2\nNA\nDSO_CAB_GAL_LT\nNA\nDSO_MASTER_SHED_OFF_LT\nNA\nDSO_CABIN_GALLEY_MASTER\nNA\nDSO_150MA_GNDOPEN_1\nNA\nDSO_150MA_GNDOPEN_2\nNA\nDSO_FWD_WATER_HEATER_AUTHORISED\nNA\nDSO_AFT_WATER_HEATER_AUTHORISED\nNA\nDSO_SHED_GENERATOR_FAIL\nNA\nDSO_CABIN_MASTER_ON\nNA\nDSO_CABIN_AC_MASTER_GALLEY_MASTER\nNA\nDSO_GALLEY_MASTER_ON\nNA\nDSO_EPP_LT\nNA\nDSO_GPU_CONNECTION_STATUS\nNA\nDSO_SPARE', 'additional': u'\tModified according SACR439', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_6100': {'status': u'\tMATURE', 'body': u'The microcontroller used for FUNC functionalities shall be:\nDSP33FJ256GP710A', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tThis requirement defines the microcontroller used for FUNC realization', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6101': {'status': u'\tMATURE', 'body': u'Proper operation of FUNC microcontroller shall be monitored through an external watchdog.', 'additional': u'\tA watchdog is implemented in order to monitor good execution of a program => when a problem occurs the microcontroller is reset.', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6201]'}, u'SSCS_ESSNESS_6102': {'status': u'\tMATURE', 'body': u'Three inputs of the FUNC microcontroller shall be dedicated to determination of type of microcontroller (FUNC, BITE or SPARE)\nFor FUNC \xb5C, UC_TYPE_1 will be Low level\nFor FUNC \xb5C, UC_TYPE_2 will be High level\nFor FUNC \xb5C, UC_PARITY will be Low level', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThose pins allow determining whether the microcontroller is a FUNC, BITE or SPARE one, so that if one microcontroller was badly programmed (with the wrong software) it can be detected. The spare configuration is for a third microcontroller if the THD measurement is done with a microcontroller.', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6103': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall implement one LED driven by the \xb5C FUNC', 'additional': u'\tallow seeing if the \xb5C FUNC is \u201calive\u201d or not', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6403]'}, u'SSCS_ESSNESS_9151': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, when DSI_TRU_OVL_GEN_OVL_SC was active once, the failure CBIT_TRU_OVL_FAIL shall be activated if one at least of the following condition is true:\nDSI_TRU_OVL_GEN_OVL_SC frequency is out of the range [950,1050Hz]\nduty cycle of DSI_TRU_OVL_GEN_OVL_SC is out of following ranges:\n15% +/-3%, 30% +/-3%, 45% +/-3%, 55% +/-3%, 70% +/-3%, 85% +/-3%\nElse it is inactive', 'additional': u'\tModified according SACR291', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_7049],\t[SDTS_PDS_7052]'}, u'SSCS_ESSNESS_7862': {'status': u'\tMATURE', 'body': u'In case of ESS configuration,the FUNC microcontroller shall activate BAT_CURRENT_CH1_VALID and BAT_CURRENT_CH2_VALID when BAT_SW enters AUTO state.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7236],\t[SDTS_PDS_7237]'}, u'SSCS_ESSNESS_7863': {'status': u'\tMATURE', 'body': u'In case of NESS configuration,the FUNC microcontroller shall activate TRU_CURRENT_CH1_VALID and TRU_CURRENT_CH2_VALID when TRU_SW enters AUTO state.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7047],\t[SDTS_PDS_7048],\t[SDTS_PDS_7050],\t[SDTS_PDS_7051]'}, u'SSCS_ESSNESS_7703': {'status': u'\tMATURE', 'body': u'For each microcontroller, when reset is deasserted RAM and ROM shall be tested\n\t', 'additional': u'\tAutotests are done at every reset and not only at power up,\tmodified according SyCR19', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7246],\t[SDTS_PDS_6201]'}, u'SSCS_ESSNESS_7864': {'status': u'\tMATURE', 'body': u'In case of NESS configuration,the FUNC microcontroller shall deactivate TRU_CURRENT_CH2_VALID when one at least of the following condition is true:\nDSI_TRC_STATUS is open, and the ASI_HES1_CH2 is outside the following range [-10A; +10A] during 1s +/-10ms\nASI_HES1_CH2 is over 75A +/-1,5A\n(ASI_HES1_CH2 is under -40A AND ASI_HES1_CH1 is over 100A AND TRU_CURRENT_CH1_VALID is active) during 1s +/-10ms', 'additional': u'\tThe HES cannot read 75A, this threshold corresponds to the 11V indicating that there is a default on the HES', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7048],\t[SDTS_PDS_7051],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_7865': {'status': u'\tMATURE', 'body': u'In case of ESS configuration,the BITE microcontroller shall activate CBIT_BITE_BAT_CURRENT_CH1_VALID and CBIT_BAT_CURRENT_CH2_VALID when BAT_SW enters AUTO state.', 'additional': u'\tModified according SACR453', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7236],\t[SDTS_PDS_7237]'}, u'SSCS_ESSNESS_3114': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3115': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3116': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0174': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, when CONTACT_C is set to inactive, the pick-up (CONTACT_C_PU) and the hold commands (CONTACT_C_HO) shall be released.', 'additional': u'\tModified according SACR439', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_519]'}, u'SSCS_ESSNESS_0173': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, when CONTACT_C is set to active, if ASI_28V_C is greater than 18.5V(+/-0.5V), the pick-up command (CONTACT_C_PU) shall be activated during 60ms (+/-5ms) and the hold command (CONTACT_C_HO) be activated continuously.', 'additional': u'\tModified according SACR439', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_519]'}, u'SSCS_ESSNESS_0172': {'status': u'\tMATURE', 'body': u'At power-up, CONTACT_X shall be set to inactive.\nWhere X stands for B,C,D or E', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define value of contactors command at power-up', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0171': {'status': u'\tMATURE', 'body': u'This requirement aims at explaining how to read the DELAY OFF boxes used in contactors equations.\nWhen the input becomes FALSE, the output shall be FALSE after the specified time delay +/-10% as long as the input is still FALSE.\nIf the input becomes TRUE before the time delay expired, the output stays TRUE', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7226]'}, u'SSCS_ESSNESS_0170': {'status': u'\tMATURE', 'body': u'This requirement aims at explaining how to read the DELAY ON boxes used in contactors equations.\nWhen the input becomes TRUE, the output shall be TRUE after the specified time delay +/-10% as long as the input is still TRUE.\nIf the input becomes FALSE before the time delay expired, the output stays FALSE', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7225]'}, u'SSCS_ESSNESS_3118': {'status': u'\tMATURE', 'body': u'At power-up, the BAT_TRU_TEMP temperature shall be not available', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define the value of BAT_TRU_TEMP at power-up', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3119': {'status': u'\tMATURE', 'body': u'At power-up, PCB_TEMP shall be set to not available', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tin order to define PCB_TEMP at power-up', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3802': {'status': u'\tMATURE', 'body': u'The BITE microcontroller shall acquire and average during 250ms +/-2,5ms the following voltage measurement:\nASI_28V_BAT_TRU_MON (averaged data is called 28V_BAT_TRU_MON_AV)\nASI_28V_ESS_MON (averaged data is called 28V_ESS_MON_AV)\nASI_28V_MAIN_MON.(averaged data is called 28V_MAIN_MON_AV)', 'additional': u'\tdata are sent on ARINC / modified according SACR451', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7005],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_3803': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall acquire and scale the following DC voltages:\nASI_28V_A corresponds to 28V_A\nASI_28V_B corresponds to 28V_B\nASI_28V_C corresponds to 28V_C\nASI_28V_D corresponds to 28V_D\nASI_28V_E corresponds to 28V_E', 'additional': u'\tThe DC voltage at board inputs are not scaled', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThose voltages, used for contactor drivers purpose, have to be formatted in order to be readable by the microcontroller', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0319': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, at power-up CT3_SUM shall be set to 0A', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define CT3_SUM at power-up', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0318': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, TRU driver fail protection shall be activated when CONTACT_A_TRIP is active and 28V_A is over 18,5V +/-0,5V.', 'additional': u'\tmodified according SyCR17 / SACR258', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7156],\t[SDTS_PDS_7157],\t[SDTS_PDS_8007],\t[SDTS_PDS_8008]'}, u'SSCS_ESSNESS_3806': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3804': {'status': u'\tMATURE', 'body': u'The FUNC microcontroller shall acquire ASI_28V_A, ASI_28V_B, ASI_28V_D and ASI_28V_E.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tUsed for functional purpose', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3805': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0313': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, TRU_PROTECTION shall be activated when one at least of the following conditions is TRUE:\nTRU overload protection is active\nTRU undervoltage protection is active\nTRU over ripple protection is active\nTRU reverse protection is active\nTRU driver fail protection is active\nElse it is inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_EQUAT_105],\t[SDTS_PDS_EQUAT_207]'}, u'SSCS_ESSNESS_0312': {'status': u'\tTBC', 'body': u'In case of NESS configuration, TRU_OVL_IN_PROGRESS shall be activated when the accumulated current flowing through corresponding TRU (TRU_CURRENT) is above curve defined hereafter TBC (40ms earlier), else it is inactive\nWhen I > Isat overload delay is 50ms\nWhen I < Isat delay is computed according curve described with following parameters\n\tIsat = 1364A\n\tTsat = 0,1s\n\tIth = 300A\n\tTth = 322s\nThe delay computed is 40ms shorter than this curve in order to take into account the system response time', 'additional': u'\tmodified according SyCR55 and SACR363', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_5087],\t[SDTS_PDS_5086]'}, u'SSCS_ESSNESS_0311': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, FUNC microcontroller shall activate TRU over ripple protection when TRU_OR is active for more than 100ms +/-5ms.', 'additional': u'\tdelay tolerance cannot be achieved', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_2150],\t[SDTS_PDS_2151],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_0310': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, TRU undervoltage protection shall be inhibited when DSI_TRC_STATUS is opened', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_361],\t[SDTS_PDS_360]'}, u'SSCS_ESSNESS_0317': {'status': u'\tTBC', 'body': u'In case of NESS configuration, TRU_HIGH_CURRENT shall be deactivated when all the following conditions are true:\nTRU_CURRENT is under 330A +/-10% TBC for at least 100ms +/-5ms TBC\nCT_ATRC_MAX is under 42A +/-10% for at least 100ms +/-5ms TBC', 'additional': u'\taccumulation current process cannot be active and decreasing simultaneously,\t1% delay tolerance will not be achieved,\tdefinition of accumulation process is available in GS3682', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7083],\t[SDTS_PDS_7114],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_0316': {'status': u'\tTBC', 'body': u'In case of NESS configuration, TRU_HIGH_CURRENT shall be activated when TRU_CURRENT is over 330A +/-10% TBC or CT_ATRC_MAX is over 42A +/-10% TBC', 'additional': u'\tdefinition of process active has to be available in GS3682', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7063],\t[SDTS_PDS_7065]'}, u'SSCS_ESSNESS_0315': {'status': u'\tTBC', 'body': u'In case of NESS configuration, HES_TRU_CH2_CURRENT shall be activated when current flowing through the TRU contactor ASI_HES1_CH2 (calibrated) is over 20A +/-1,5A TBC\nElse it is inactive', 'additional': u'\tTolerances in current are defined as the tolerance of the HES and 1% of the full scale for the board', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define when TRC current is positive, this signal is used in contactor equations SDTS_PDS_7199 and SDTS_PDS_7200', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0314': {'status': u'\tTBC', 'body': u'In case of NESS configuration, the current flowing through the TRU contactor, TRU_CURRENT shall be defined as follow:\nIf ASI_HES1_CH1 (calibrated current) is under 700A +/-7A TBC and TRU_CURRENT_CH1_VALID is active then TRU_CURRENT corresponds to ASI_HES1_CH1\nElse TRU_CURRENT corresponds to the sum of rms current on each phases (CT3_SUM) multiplied by k\nWhere k is 115/29,5.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7057],\t[SDTS_PDS_7060]'}, u'SSCS_ESSNESS_5008': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, the ESSNESS board shall acquire the following GND/open DSI:\nName\nType\nComments\nDSI_CAB_INV1_FAIL_AGCU_POWER_READY\nGND/open\nlightning protection A3J33\nDSI_SPARE_16\nGND/open\nlightning protection A3J33\nDSI_SPARE_17\nGND/open\nlightning protection A3J33\nDSI_CAB_INV1_DIFF_FAULT_SMC_STATUS\nGND/open\nlightning protection A3J33\nDSI_CAB_INV1_OVERCURRENT_GPU_CONNECT_CMD\nGND/open\nlightning protection A3J33\nDSI_CAB_INV1_OVERTEMP_GPU_SW_EPPC\nGND/open\nlightning protection A3J33\nDSI_CABIN_MASTER_CMD\nGND/open\nlightning protection A3J33\nDSI_CAB_INV1_FAN_FAIL\nGND/open\nlightning protection A3J33\nTable 7: DSI complementary interface of NESS board', 'additional': u'\t', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_379],\t[SDTS_PDS_2609]'}, u'SSCS_ESSNESS_5009': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, the ESSNESS board shall acquire the following GND/open DSI:\nName\nLNESS\nRNESS\nDSI_CAB_INV1_FAIL_AGCU_POWER_READY\nCABIN_AC_INV_1_FAIL\nAGCU_POWER_READY\nDSI_SPARE_16\nSPARE\nSPARE\nDSI_SPARE_17\nSPARE\nSPARE\nDSI_CAB_INV1_DIFF_FAULT_SMC_STATUS\nCABIN_AC_INV_1_DIFF_FAULT\nSMC_STATUS_NO\nDSI_CAB_INV1_OVERCURRENT_GPU_CONNECT_CMD\nCABIN_AC_INV_1_OVERCURRENT\nGPU_CONNECT_CMD\nDSI_CAB_INV1_OVERTEMP_GPU_SW_EPPC\nCABIN_AC_INV_1_OVERTEMP\nEXTERNAL_POWER_PANEL_SW\nDSI_CABIN_MASTER_CMD\nCABIN_MASTER_CMD\n\xa0\nDSI_CAB_INV1_FAN_FAIL\nCABIN_AC_INV_1_FAN_FAIL\n\xa0\nTable 17: DSI complementary correspondence between ESSNESS names and system names', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_379]'}, u'SSCS_ESSNESS_5800': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall generate the following DSO: \nName\nType\nLogic\nGoing to\nComments\nCONTACT_A_PU\n28V/open\n28V when coil is energized\nContactor A\nHDSO\nCONTACT_A_HO\n28V/open\n28V when coil is energized\nContactor A\nMDSO\nCONTACT_B_PU\n28V/open\n28V when coil is energized\nContactor B\nHDSO\nCONTACT_B_HO\n28V/open\n28V when coil is energized\nContactor B\nMDSO\nCONTACT_C_PU\n28V/open\n28V when coil is energized\nContactor C\nHDSO\nCONTACT_C_HO\n28V/open\n28V when coil is energized\nContactor C\nMDSO\nCONTACT_D_PU\n28V/open\n28V when coil is energized\nContactor D\nHDSO\nCONTACT_D_HO\n28V/open\n28V when coil is energized\nContactor D\nMDSO\nCONTACT_E_PU\n28V/open\n28V when coil is energized\nContactor E\nHDSO\nCONTACT_E_HO\n28V/open\n28V when coil is energized\nContactor E\nMDSO\nTable 27: HDSO interface of ESSNESS board', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tDue to several board configurations, the ESSNESS board can be in charge of 5 contactors command', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3990': {'status': u'\tMATURE', 'body': u'In case of LNESS and RNESS configuration, the BITE microcontroller shall acquire  28V_4_PRESENCE.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tto define voltage presence monitoring', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5007': {'status': u'\tMATURE', 'body': u'The polarisation current of following GND/Open DSI shall be 50mA .DSI LATLC1_STATUS , LATLC2_STATUS, LATLC1_STATUS and RATLC2_STATUS.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_5015]'}, u'SSCS_ESSNESS_5000': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall have 25% of spares for DSI and DSO with a minimum of 10.', 'additional': u'\t', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_4013],\t[SDTS_PDS_4014]'}, u'SSCS_ESSNESS_5001': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall acquire the following GND/open DSI:\nName\nType\nComments\nDSI_TAC_OPP_CABC_OPP_STATUS\nGND/open\nlightning protection A3J33\nDSI_START_IN_PROGRESS\nGND/open\nlightning protection A3J33\nDSI_TRC_OPP_STATUS_CABC_SHED\nGND/open\nlightning protection A3J33\nDSI_TC_OPP_STATUS\nGND/open\nlightning protection A3J33\nDSI_TSBC_OPP_STATUS\nGND/open\nlightning protection A3J33\nDSI_GLC_OPP_STATUS\nGND/open\nlightning protection A3J33\nDSI_APUGLC_STATUS\nGND/open\nlightning protection A3J33\nDSI_WOW_LHPPDB\nGND/open\nlightning protection A3J33\nDSI_WOW_RHPPDB\nGND/open\nlightning protection A3J33\nDSI_ALT_STATUS\nGND/open\nlightning protection A3J33This is a PWM input\nDSI_SPARE_18\nGND/open\nlightning protection A3J33\nDSI_RALTC1_STATUS\nGND/open\nlightning protection A3J33\nDSI_EMP_B_CMD_HSCM_2_GALC_OPP\nGND/open\nlightning protection A3J33\nDSI_SHP_CABC_STATUS\nGND/open\nlightning protection A3J33\nDSI_BC_STATUS\nGND/open\nlightning protection A3J33\nDSI_TSBC_OVL\nGND/open\nlightning protection A3J33This is a PWM input\nDSI_TC_SMC_COIL_GND_MON\nGND/open\nlightning protection A3J33\nDSI_TRC_STATUS\nGND/open\nDSI_TC_STATUS\nGND/open\nDSI_TSBC_STATUS\nGND/open\nDSI_GLC_STATUS\nGND/open\nDSI_TAC_STATUS\nGND/open\nDSI_HES_TRU_CURRENT_SLC_STATUS\nGND/open\nDSI_TC_RESET_ATRC_STATUS\nGND/open\nDSI_FAN_CMD_xH\nGND/open\nlightning protection A3J33\nDSI_TAC_TSBC_INHIB_RELAY_MON\nGND/open\nDSI_xALTC1_TAC_COIL_GND_MON\nGND/open\nlightning protection A3J33\nDSI_SPARE_8\nGND/open\nlightning protection A3J33\nDSI_SPARE_9\nGND/open\nlightning protection A3J33\nDSI_SPARE_10\nGND/open\nlightning protection A3J33\nDSI_SPARE_11\nGND/open\nlightning protection A3J33\nDSI_BAT_HEATER_RELAY_2_STATUS\nGND/open\nDSI_SPARE_13\nGND/open\nDSI_SPARE_14\nGND/open\nDSI_SPARE_15\nGND/open\nDSI_TRU_OVL_GEN_OVL_SC\nGND/open\nlightning protection A3J33This is a PWM input\nDSI_FREQ_PPDB_FAN\nGND/open\nThis is a PWM input\nDSI_START_ACCEPTED_APUSLC_STATUS\nGND/open\nlightning protection A3J33\nDSI_BOOC_GPULC_STATUS\nGND/open\nlightning protection A3J33\nDSI_xALTC2_COIL_GND_MON\nGND/open\nDSI_LALTC1_STATUS\nGND/open\nDSI_EMP_B_CMD_HSCM_1_GALC\nGND/open\nlightning protection A3J33\nDSI_SPARE_19\nGND/open\nDSI_FREQ_TRU_FAN\nGND/open\nlightning protection A3J33This is a PWM input\nDSI_BACK_UP_PUMP_CABIN_CONV_GALLEY_CMD\nGND/open\nlightning protection A3J33\nDSI_TRC_CMD_SMC_RATLC_STATUS\nGND/open\nDSI_BAT_PIN_PROG1_GNC_STATUS\nGND/open\nlightning protection A3J33\nDSI_BAT_TRU_SW\nGND/open\nlightning protection A3J33\nDSI_BAT_RELAY_STATUS\nGND/open\nDSI_LALTC2_STATUS\nGND/open\nDSI_POWER_ON\nGND/open\nlightning protection A3J33\nDSI_BAT_PIN_PROG2_GNC_OPP_STATUS\nGND/open\nlightning protection A3J33\nDSI_ESSTIED_RELAY_ATRC_OPP_STATUS\nGND/open\nlightning protection A3J33\nDSI_RATLC_SLC_OPP_STATUS\nGND/open\nlightning protection A3J33\nDSI_APU_START_REQUEST\nGND/open\nlightning protection A3J33\nDSI_ISOLATION_SMOKE_GALLEY_CABIN_MASTER\nGND/open\nlightning protection A3J33\nDSI_BC_Bypass\nGND/open\nlightning protection A3J33\nDSI_RALTC2_STATUS\nGND/open\nlightning protection A3J33\nDSI_PIN_PROG1\nGND/open\nDSI_PIN_PROG2\nGND/open\nDSI_PIN_PROG3\nGND/open\nDSI_PIN_PROG4\nGND/open\nDSI_PIN_PROG_PARITY\nGND/open\nTable 6: DSI interface of ESSNESS board', 'additional': u'\tModified according SyCR36 / SACR442', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_534],\t[SDTS_PDS_379],\t[SDTS_PDS_2609]'}, u'SSCS_ESSNESS_5002': {'status': u'\tMATURE', 'body': u'According to board configuration, the correspondence between signal names in ESSNESS board interface and signal name in the PDS shall be according following table:\nName\nLESS\nRESS\nLNESS\nRNESS\nDSI_TAC_OPP_CABC_OPP_STATUS\nTAC2_STATUS_NC\nTAC1_STATUS_NC\nCABC2_STATUS_NC\nCABC1_STATUS_NC\nDSI_START_IN_PROGRESS\nSTART_IN_PROGRESS\nSTART_IN_PROGRESS\nSTART_IN_PROGRESS\nSTART_IN_PROGRESS\nDSI_TRC_OPP_STATUS_CABC_SHED\nTRC2_STATUS_NC\nTRC1_STATUS_NC\nCABC2_SHED\n\xa0\nDSI_TC_OPP_STATUS\nTC2_STATUS_NO\nTC1_STATUS_NC\nTC2_STATUS_NC\nTC1_STATUS_NC\nDSI_TSBC_OPP_STATUS\nTSBC2_STATUS_NC\nTSBC1_STATUS_NC\nTSBC2_STATUS_NC\nTSBC1_STATUS_NC\nDSI_GLC_OPP_STATUS\nGLC2_STATUS_NC\nGLC1_STATUS_NC\nGLC2_STATUS_NO\nGLC1_STATUS_NO\nDSI_APUGLC_STATUS\nAPUGLC_STATUS_NC\nAPUGLC_STATUS_NC\nAPUGLC_STATUS_NO\nAPUGLC_STATUS_NO\nDSI_WOW_LHPPDB\nWOW_LHPPDB\nWOW_LHPPDB\nWOW_LHPPDB\nWOW_LHPPDB\nDSI_WOW_RHPPDB\nWOW_RHPPDB\nWOW_RHPPDB\nWOW_RHPPDB\nWOW_RHPPDB\nDSI_ALT_STATUS\nALT_STATUS\nALT_STATUS\nALT_STATUS\nALT_STATUS\nDSI_SPARE_18\nSPARE\nSPARE\nSPARE\nSPARE\nDSI_RALTC1_STATUS\nRALTC1_STATUS_NO\nRALTC1_STATUS_NC\n\xa0\n\xa0\nDSI_EMP_B_CMD_HSCM_2_GALC_OPP\n\xa0\nEMP_B_CMD_HSCM_2\nGALC2_STATUS_NC\nGALC1_STATUS_NC\nDSI_SHP_CABC_STATUS\nSHP_STATUS_NC\nSHP_STATUS_NO\nCABC1_STATUS_NO\nCABC2_STATUS_NO\nDSI_BC_STATUS\nBC1_STATUS_NO\nBC2_STATUS_NO\nBC2_STATUS_NC\nBC1_STATUS_NC\nDSI_TSBC_OVL\nTSBC1_OVL\nTSBC2_OVL\nTSBC1_OVL\nTSBC2_OVL\nDSI_TC_SMC_COIL_GND_MON\nTC1_COIL_GND_MON\nTC2_COIL_GND_MON\nSMC_COIL_GND_MON\n\xa0\nDSI_TRC_STATUS\nTRC1_STATUS_NC\nTRC2_STATUS_NC\nTRC1_STATUS_NO\nTRC2_STATUS_NO\nDSI_TC_STATUS\nTC1_STATUS_NO\nTC2_STATUS_NC\nTC1_STATUS_NC\nTC2_STATUS_NC\nDSI_TSBC_STATUS\nTSBC1_STATUS_NC\nTSBC2_STATUS_NC\nTSBC1_STATUS_NO\nTSBC2_STATUS_NO\nDSI_GLC_STATUS\nGLC1_STATUS_NC\nGLC2_STATUS_NC\nGLC1_STATUS_NO\nGLC2_STATUS_NO\nDSI_TAC_STATUS\nTAC1_STATUS_NC\nTAC2_STATUS_NC\nTAC1_STATUS_NO\nTAC2_STATUS_NO\nDSI_HES_TRU_CURRENT_SLC_STATUS\nHES_TRU1_CURRENT\nHES_TRU2_CURRENT\nSLC1_STATUS_NC\nSLC2_STATUS_NO\nDSI_TC_RESET_ATRC_STATUS\nTC1_RESET\nTC2_RESET\nATRC1_STATUS_NO\nATRC2_STATUS_NO\nDSI_FAN_CMD_xH\nFAN_CMD_LH\nFAN_CMD_RH\nFAN_CMD_LH\nFAN_CMD_RH\nDSI_TAC_TSBC_INHIB_RELAY_MON\nTAC1_INHIB_Relay_MON\nTAC2_INHIB_Relay_MON\nTSBC1_INHIB_RELAY_MON\nTSBC2_INHIB_RELAY_MON\nDSI_xALTC1_TAC_COIL_GND_MON\nLALTC1_COIL_GND_MON\nRALTC1_COIL_GND_MON\nTAC1_COIL_GND_MON\nTAC2_COIL_GND_MON\nDSI_SPARE_8\nSPARE\nSPARE\nSPARE\nSPARE\nDSI_SPARE_9\nSPARE\nSPARE\nSPARE\nSPARE\nDSI_SPARE_10\nSPARE\nSPARE\nSPARE\nSPARE\nDSI_SPARE_11\nSPARE\nSPARE\nSPARE\nSPARE\nDSI_BAT_HEATER_RELAY_2_STATUS\nBAT1_HEATER_RELAY_2_STATUS\nBAT2_HEATER_RELAY_2_STATUS\nSPARE\nSPARE\nDSI_SPARE_13\nSPARE\nSPARE\nSPARE\nSPARE\nDSI_SPARE_14\nSPARE\nSPARE\nSPARE\nSPARE\nDSI_SPARE_15\nSPARE\nSPARE\nSPARE\nSPARE\nDSI_TRU_OVL_GEN_OVL_SC\nTRU1_OVL\nTRU2_OVL\nGEN1_OVERLOAD_PWM_GCU1\nGEN2_OVERLOAD_PWM_GCU2\nDSI_FREQ_PPDB_FAN\nLH_PPDB_FAN_B_ROT\nRH_PPDB_FAN_B_ROT\nLH_PPDB_FAN_A_ROT\nRH_PPDB_FAN_A_ROT\nDSI_START_ACCEPTED_APUSLC_STATUS\nSTART_ACCEPTED_APU\n\xa0\nAPUSLC_STATUS_NC\nAPUSLC_STATUS_NO\nDSI_BOOC_GPULC_STATUS\nBOOC_STATUS_NO\n\xa0\nGPULC_STATUS_NO\nGPULC_STATUS_NO\nDSI_xALTC2_COIL_GND_MON\nLALTC2_COIL_GND_MON\nRALTC2_COIL_GND_MON\n\xa0\n\xa0\nDSI_LALTC1_STATUS\nLALTC1_STATUS_NC\n\xa0\n\xa0\n\xa0\nDSI_EMP_B_CMD_HSCM_1_GALC\n\xa0\nEMP_B_CMD_HSCM_1\nGALC1_STATUS_NO\nGALC2_STATUS_NO\nDSI_SPARE_19\nSPARE\nSPARE\nSPARE\nSPARE\nDSI_FREQ_TRU_FAN\n\xa0\n\xa0\nTRU1_FAN_ROT\nTRU2_FAN_ROT\nDSI_BACK_UP_PUMP_CABIN_CONV_GALLEY_CMD\nEMP_B_OCP_AUTO_OFF_CMD\nCABIN_CONV_LH_CMD\nGALLEY_CMD\nDSI_TRC_CMD_SMC_RATLC_STATUS\nTRC1_CMD\nTRC2_CMD\nSMC_STATUS_NC\nRATLC_STATUS_NO\nDSI_BAT_PIN_PROG1_GNC_STATUS\nBAT_PinProg1\nBAT_PinProg1\nGNC1_STATUS_NC\nGNC2_STATUS_NO\nDSI_BAT_TRU_SW\nBAT1_ON_OFF_CMD\nBAT2_ON_OFF_CMD\nTRU1_OFFLINE_CMD\nTRU2_OFFLINE_CMD\nDSI_BAT_RELAY_STATUS\nBAT1_HEATER_RELAY_STATUS\nBAT2_HEATER_RELAY_STATUS\n\xa0\n\xa0\nDSI_LALTC2_STATUS\nLALTC2_STATUS_NO\n\xa0\n\xa0\n\xa0\nDSI_POWER_ON\nPOWER_ON_LH\nPOWER_ON_RH\nPOWER_ON_LH\nPOWER_ON_RH\nDSI_BAT_PIN_PROG2_GNC_OPP_STATUS\nBAT_PinProg2\nBAT_PinProg2\nGNC2_STATUS_NC\nGNC1_STATUS_NO\nDSI_ESSTIED_RELAY_ATRC_OPP_STATUS\nLH_ESS_TIED_RELAY_STATUS\nRH_ESS_TIED_RELAY_STATUS\nATRC2_STATUS_NC\nATRC1_STATUS_NC\nDSI_RATLC_SLC_OPP_STATUS\nRATLC_STATUS_NC\nRATLC_STATUS_NO\nSLC2_STATUS_NC\nSLC1_STATUS_NO\nDSI_APU_START_REQUEST\nAPU_START_REQUEST\n\xa0\n\xa0\n\xa0\nDSI_ISOLATION_SMOKE_GALLEY_CABIN_MASTER\nISOLATION_LH_SMOKE_CMD2\nISOLATION_RH_SMOKE_CMD2\nGALLEY_MASTER_TO_LH\nCABIN_MASTER_STATUS\nDSI_BC_Bypass\nBC1_BYPASS_CMD\nBC2_BYPASS_CMD\n\xa0\n\xa0\nDSI_RALTC2_STATUS\nRALTC2_STATUS_NO\n\xa0\n\xa0\n\xa0\nDSI_PIN_PROG1\nPin_Prog1\nPin_Prog1\nPin_Prog1\nPin_Prog1\nDSI_PIN_PROG2\nPin_Prog2\nPin_Prog2\nPin_Prog2\nPin_Prog2\nDSI_PIN_PROG3\nPin_Prog3\nPin_Prog3\nPin_Prog3\nPin_Prog3\nDSI_PIN_PROG4\nPin_Prog4\nPin_Prog4\nPin_Prog4\nPin_Prog4\nDSI_PIN_PROG_PARITY\nParity\nParity\nParity\nParity\nTable 16: DSI correspondence between ESSNESS names and system names', 'additional': u'\tModified according SyCR36 / SACR442', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_534],\t[SDTS_PDS_379]'}, u'SSCS_ESSNESS_3991': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, the BITE microcontroller shall acquire:\nCONTACT_C_TRIP', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tto define monitoring of contactor driver failure', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3208': {'status': u'\tMATURE', 'body': u'TSBC_OVL_IN_PROGRESS and TSBC_HIGH_CURRENT shall be managed according following logic, if the DSI_TSBC_OVL frequency is  in the range [950Hz, 1.050KHz]:\nWhen duty cycle of DSI_TSBC_OVL is 15%+/-3% or 85% +/-3%\nTSBC_OVL_IN_PROGRESS is inactive\nTSBC_HIGH_CURRENT is inactive\nWhen duty cycle of DSI_TSBC_OVL is 30%+/-3% or 70% +/-3%\nTSBC_OVL_IN_PROGRESS is inactive\nTSBC_HIGH_CURRENT is active\nWhen duty cycle of DSI_TSBC_OVL is 45%+/-3% or 55% +/-3%\nTSBC_OVL_IN_PROGRESS is active\nTSBC_HIGH_CURRENT is active\nElse see \xa78.4.8', 'additional': u'\tModified according SACR291', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_7221],\t[SDTS_PDS_7220],\t[SDTS_PDS_7260],\t[SDTS_PDS_7261]'}, u'SSCS_ESSNESS_3103': {'status': u'\tMATURE', 'body': u'The BITE microcontroller shall acquire ASI_BAT_TRU_TEMP_A and ASI_BAT_TRU_TEMP_B.', 'additional': u'\tSee \xa78.4.3 for tests definition', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThe good behavior of temperature sensors are checked', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3102': {'status': u'\tMATURE', 'body': u'The BAT_TRU_TEMP temperature used for functional purpose shall be:\nThe max of the two temperatures read (ASI_BAT_TRU_TEMP_A and ASI_BAT_TRU_TEMP_B) when both signals validity are valid\nThe temperature of the non faulty sensor when one signal validity is invalid\nNot available when both signals validity is invalid\nValidity signal are: BAT_TRU_TEMP_A_VALID and BAT_TRU_TEMP_B_VALID', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7173],\t[SDTS_PDS_7175]'}, u'SSCS_ESSNESS_3200': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall acquire and scale two PWM signals corresponding to rotation speed of fans:\nDSI_FREQ_PPDB_FAN\nDSI_FREQ_TRU_FAN', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_527],\t[SDTS_PDS_376]'}, u'SSCS_ESSNESS_3201': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall acquire and scale three PWM signals:\nDSI_ALT_STATUS\nDSI_TRU_OVL_GEN_OVL_SC\nDSI_TSBC_OVL', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define internal system PWM signals', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3202': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3203': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3204': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t,\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3101': {'status': u'\tMATURE', 'body': u'The FUNC microcontroller shall acquire ASI_BAT_TRU_TEMP_A and ASI_BAT_TRU_TEMP_B.', 'additional': u'\tsee \xa73.6.1 for ESSNESS board interface description', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tBAT and TRU temperatures are used for functional purpose', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3206': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, GEN_OVL and GEN_SC shall be managed according following logic, if the DSI_TRU_OVL_GEN_OVL_SC frequency is  in the range [990Hz, 1.010KHz]:\nWhen duty cycle of DSI_TRU_OVL_GEN_OVL_SC is 10% +/-3% (or 90% +/-3%):\nGEN_OVL is inactive\nGEN_HC is inactive\nGEN_SC is inactive\nWhen duty cycle of DSI_TRU_OVL_GEN_OVL_SC is 20% +/- 3% (or 80% +/-3%)\nGEN_OVL is inactive\nGEN_HC is active\nGEN_SC is inactive\nWhen duty cycle of DSI_TRU_OVL_GEN_OVL_SC is 30% +/- 3% (or 70% +/-3%)\nGEN_OVL is active\nGEN_HC is inactive\nGEN_SC is inactive\nWhen duty cycle of DSI_TRU_OVL_GEN_OVL_SC is 40% +/- 3% (or 60% +/-3%)\nGEN_OVL is inactive\nGEN_HC is inactive\nGEN_SC is active\nElse see \xa78.4.8', 'additional': u'\tModified according SACR291 / SACR530', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_5080]'}, u'SSCS_ESSNESS_3207': {'status': u'\tMATURE', 'body': u'STBY_TRU_FAIL, TIE_ALT_115VAC_OVL and TIE_ALT_115VAC_FAULT shall be managed according following logic if the DSI_ALT_STATUS is in the range [950Hz, 1.050KHz]:\nWhen duty cycle of DSI_ALT_STATUS is 8%+/-3% or 92% +/-3%\nSTBY_TRU_FAIL is inactive\nTIE_ALT_115VAC_OVL is inactive\nTIE_ALT_115VAC_FAULT is inactive\nWhen duty cycle of DSI_ALT_STATUS is 16%+/-3% or 84% +/-3%\nSTBY_TRU_FAIL is inactive\nTIE_ALT_115VAC_OVL is active\nTIE_ALT_115VAC_FAULT is inactive\nWhen duty cycle of DSI_ALT_STATUS is 24%+/-3% or 76% +/-3%\nSTBY_TRU_FAIL is inactive\nTIE_ALT_115VAC_OVL is inactive\nTIE_ALT_115VAC_FAULT is active\nWhen duty cycle of DSI_ALT_STATUS is 32%+/-3% or 68% +/-3%\nSTBY_TRU_FAIL is active\nTIE_ALT_115VAC_OVL is inactive\nTIE_ALT_115VAC_FAULT is inactive\nWhen duty cycle of DSI_ALT_STATUS is 40%+/-3% or 60% +/-3%\nSTBY_TRU_FAIL is active\nTIE_ALT_115VAC_OVL is active\nTIE_ALT_115VAC_FAULT is inactive\nWhen duty cycle of DSI_ALT_STATUS is 48%+/-3% or 52% +/-3%\nSTBY_TRU_FAIL is active\nTIE_ALT_115VAC_OVL is inactive\nTIE_ALT_115VAC_FAULT is active\nElse see \xa78.4.8', 'additional': u'\tModified according SACR291', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_7228],\t[SDTS_PDS_7227],\t[SDTS_PDS_7258]'}, u'SSCS_ESSNESS_7851': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7850': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7853': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4624': {'status': u'\tMATURE', 'body': u'In case of NESS configurations, if SSM_73 is Normal Operation and bit 26 of label 73 is TRUE (1)\nThen TAKE_OFF shall be active\nElse TAKE_OFF is inactive', 'additional': u'\tAdded according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_8057],\t[SDTS_PDS_8062]'}, u'SSCS_ESSNESS_7855': {'status': u'\tMATURE', 'body': u'In case of ESS configuration,the BITE microcontroller shall deactivate CBIT_BITE_BAT_CURRENT_CH1_VALID when the following condition is true:\nDSI_BC_STATUS is open, and the ASI_HES1_CH1 is outside the following range [-30A; +30A] during 5s +/-50ms', 'additional': u'\tModified according SACR448', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_7236],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_7854': {'status': u'\tMATURE', 'body': u'In case of ESS configuration,the FUNC microcontroller shall deactivate BAT_CURRENT_CH1_VALID when the following condition is true:\nDSI_BC_STATUS is open, and the ASI_HES1_CH1 is outside the following range [-30A; +30A] during 5s +/-50ms', 'additional': u'\tWhen contactor is open the current flowing through it is null, this test verifies the correct behaviour of HES', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7236],\t[SDTS_PDS_7237],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_7857': {'status': u'\tMATURE', 'body': u'In case of ESS configuration,the BITE microcontroller shall deactivate CBIT_BAT_CURRENT_CH2_VALID when the following condition is true:\nDSI_BC_STATUS is open, and the ASI_HES1_CH2 is outside the following range [-30A; +30A] during 5s +/-50ms', 'additional': u'\tModified according SACR448 / SACR453', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7237],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_7856': {'status': u'\tMATURE', 'body': u'In case of ESS configuration,the FUNC microcontroller shall deactivate BAT_CURRENT_CH2_VALID when the following condition is true:\nDSI_BC_STATUS is open, and the ASI_HES1_CH2 is outside the following range [-30A; +30A] during 5s +/-50ms', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7236],\t[SDTS_PDS_7237],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_7859': {'status': u'\tMATURE', 'body': u'In case of NESS configuration,the BITE microcontroller shall deactivate CBIT_TRU_CURRENT_CH1_VALID when one at least of the following condition is true:\nDSI_TRC_STATUS is open, and the ASI_HES1_CH1 is outside the following range [-100A; +100A] during 1s +/-10ms\nASI_HES1_CH1 is over 1500A +/-60A', 'additional': u'\tThe HES cannot read 1500A, this threshold corresponds to the 11V indicating that there is a default on the HES,\tModified according SACR453', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7047],\t[SDTS_PDS_7050],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_7858': {'status': u'\tMATURE', 'body': u'In case of NESS configuration,the FUNC microcontroller shall deactivate TRU_CURRENT_CH1_VALID when one at least of the following condition is true:\nDSI_TRC_STATUS is open, and the ASI_HES1_CH1 is outside the following range [-100A; +100A] during 1s +/-10ms\nASI_HES1_CH1 is over 1500A +/-60A', 'additional': u'\tWhen contactor is open the current flowing through it is null, this test verifies the correct behaviour of HES,\tThe HES cannot read 1500A, this threshold corresponds to the 11V indicating that there is a default on the HES', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7047],\t[SDTS_PDS_7050],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_7860': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7704': {'status': u'\tMATURE', 'body': u'During the PBIT, the watchdog of each microcontroller shall be tested.', 'additional': u'\tmodified according SyCR19', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7171]'}, u'SSCS_ESSNESS_3105': {'status': u'\tMATURE', 'body': u'The FUNC microcontroller shall acquire PCB_TEMP_A and PCB_TEMP_B.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tPCB temperatures are used for functional purpose', 'issue': u'\t1', 'refer': 'EMPTY'}, u'ICD_SPI_ESSNESS_DATA_0106': {'issue': '2'}, u'ICD_SPI_ESSNESS_DATA_0107': {'issue': '2'}, u'ICD_SPI_ESSNESS_DATA_0104': {'issue': '2'}, u'ICD_SPI_ESSNESS_DATA_0105': {'issue': '2'}, u'ICD_SPI_ESSNESS_DATA_0102': {'issue': '2'}, u'ICD_SPI_ESSNESS_DATA_0103': {'issue': '2'}, u'ICD_SPI_ESSNESS_DATA_0100': {'issue': '2'}, u'ICD_SPI_ESSNESS_DATA_0101': {'issue': '2'}, u'ICD_SPI_ESSNESS_DATA_0108': {'issue': '3'}, u'ICD_SPI_ESSNESS_DATA_0109': {'issue': '3'}, u'SSCS_ESSNESS_7895': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2241': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2240': {'status': u'\tMATURE', 'body': u'In case of NESS board, at power up, the signal DSO_SPARE shall be inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_0854': {'status': u'\tTBD', 'body': u'In case of NESS configuration, ATRC unbalanced shall be activated when the difference of rms current between two phases (ASI_CT3_PhA, ASI_CT3_PhB ASI_CT3_PhC) is over 7Arms +/-TBD for 5s +/-50ms.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_2400],\t[SDTS_PDS_2402],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_0855': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, ATRC driver fail protection shall be activated when CONTACT_E_TRIP is active and 28V_E is over 18,5V +/-0,5V', 'additional': u'\tmodified according SyCR17 / SACR258', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7154],\t[SDTS_PDS_7155],\t[SDTS_PDS_8007],\t[SDTS_PDS_8008]'}, u'SSCS_ESSNESS_0856': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, ATRC_PROTECTION shall be activated when one at least of the following conditions is TRUE:\nATRC overload protection is active\nATRC driver fail protection is active\nElse it is inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_EQUAT_103],\t[SDTS_PDS_EQUAT_205]'}, u'SSCS_ESSNESS_0857': {'status': u'\tMATURE', 'body': u'In case of NESS configuration,at power-up the current flowing through ATRC (CT_ATRC_MAX) shall be set to 0A ', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define CT_ATRC_MAX at power-up', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0850': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, ATRC protections shall be latched in order to avoid cycling.\nConcerned ATRC protections are:\nATRC overload protection\nATRC driver fail protection', 'additional': u'\tThe latch of protections means that if a protection is not reset it will be memorised until the next power down,\tThe driver fail protection is not latched according to SDTSi5d4', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_2401],\t[SDTS_PDS_2403]'}, u'SSCS_ESSNESS_0851': {'status': u'\tTBC', 'body': u'In case of NESS configuration, ATRC overload protection shall be activated when the accumulated current flowing through ATRC contactor (CT_ATRC_MAX) is above curve defined with the following parameters:  with 10% of tolerance TBC in time and current\nIsat = 290A\nTsat = 0,1s\nIth = 42A\nTth = 400s\nThe delay computed is 40ms shorter than this curve in order to take into account the system response time', 'additional': u'\tThe SDTS doesn\u2019t take into account the response time of the system => that\u2019s why delay are 40ms shorter than in SDTSi5d4,\tModified according SyCR55,\tThe accumulation current process is described in GS3682', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_2648],\t[SDTS_PDS_2663]'}, u'SSCS_ESSNESS_0852': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, ATRC protections shall be set to inactive when all the following conditions are met:\nTRU_SW enters AUTO state, see \xa72.4.2\nConcerned ATRC protections are:\nATRC overload protection\nATRC driver fail protection', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_2660],\t[SDTS_PDS_2666]'}, u'SSCS_ESSNESS_0853': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, the current flowing through ATRC (CT_ATRC_MAX) shall be evaluated as the maximum of ASI_CT3_PhA, ASI_CT3_PhB, ASI_CT3_PhC ', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_2648],\t[SDTS_PDS_2663]'}, u'SSCS_ESSNESS_3521': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, the BITE microcontroller shall acquire and average during 250ms +/-2,5ms ASI_HES1_CH2 current (calibrated) measurement, if the CBIT_TRU_CURRENT_CH2_VALID is active, computed value is called ASI_HES1_CH2_AV..', 'additional': u'\tdata are sent on ARINC / modified according SACR453', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7010],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_2088': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3523': {'status': u'\tMATURE', 'body': u'In case of RESS configuration, if DSI_SHP_CABC_STATUS is open and no fault is detected on HES current monitoring, the reading current shall be calibrated to zero Ampere, for ASI_HES2_CH1.', 'additional': u'\tFault on HES are described in \xa78.4.5,\tThis behaviour is defined according SMS_ECE_00027-12', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThe HES have to be calibrating when the correspondent contactor is open', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3522': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, the BITE microcontroller shall acquire and average during 250ms +/-2,5ms ASI_HES2_CH1 current measurement, if the CBIT_CABC_CURRENT_CH1 is active, computed value is called ASI_HES2_CH1_AV..', 'additional': u'\tdata are sent on ARINC', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7010],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_3525': {'status': u'\tMATURE', 'body': u'In case of RESS and NESS configuration, at power-up the current read through ASI_HES2_CH1 shall not be calibrated (HES is considered with no error)', 'additional': u'\tThis behaviour is defined according SMS_ECE_00027-12', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tAt power-up the HES channel are not calibrated and will be calibrated only if the corresponding contactor is open', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3524': {'status': u'\tMATURE', 'body': u'At power-up the current read through ASI_HES1_CH1 and ASI_HES1_CH2 shall not be calibrated (HES is considered with no error)', 'additional': u'\tThis behaviour is defined according SMS_ECE_00027-12', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tAt power-up the HES channel are not calibrated and will be calibrated only if the corresponding contactor is open', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7204': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t3', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_8017': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2081': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2080': {'status': u'\tMATURE', 'body': u'At power up, the signal DSO_CABC_SHED shall be inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_2083': {'status': u'\tMATURE', 'body': u'In case of RNESS board, DSO_CABC_SHED shall be activated when CABC2_SHED is active, else it is inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_4029],\t[SDTS_PDS_4030]'}, u'SSCS_ESSNESS_2082': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2084': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2087': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7890': {'status': u'\tMATURE', 'body': u'When DSI_ALT_STATUS was active once, if its frequency is out of the range [950,1050Hz], failure FUNC_ALT_STATUS_FAIL shall be activated', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7115]'}, u'SSCS_ESSNESS_3811': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3701': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall read up to 63 circuit breakers status.', 'additional': u'\tThere are 54 Circuit Breakers to monitor in ESS configurations / There are 47 Circuit Breakers to monitor in NESS configurations.', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_532],\t[SDTS_PDS_666]'}, u'SSCS_ESSNESS_3700': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall manage reading of an eight rows by nine columns matrix.', 'additional': u'\t', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_666],\t[SDTS_PDS_532]'}, u'SSCS_ESSNESS_3703': {'status': u'\tMATURE', 'body': u'When activating the signal Lx, if the Cx signal is not closed after 10ms +/-1ms, failure CB_xy_VALID and CB_yx_VALID shall be set to FAIL.', 'additional': u'\tWhere x is 1,2,3,4,5,6,7,8,\tWhere y is 1,2,3,4,5,6,7,8,9,\tModified according SACR361', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tdefine CBIT of the matrix', 'issue': u'\t5', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3702': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall acquire circuit breakers status as describe hereunder:\nA row is selected by setting active one single Lx (i.e. others are inactive)\nThen , after 10ms +:-1ms status of circuit breakers are read by sampling all Cy\nx is [1,2,3,4,5,6,7,8]\ny is[1,2,3,4,5,6,7,8,9]', 'additional': u'\tModified according SACR361', 'conformity': u'\tcompliant', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_666],\t[SDTS_PDS_532]'}, u'SSCS_ESSNESS_4523': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3813': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4616': {'status': u'\tMATURE', 'body': u'In case of NESS configurations, if SSM_54 is Normal Operation and bit 19 of label 54 is TRUE (1)\nThen STBY_TRU_FAN_FAIL shall be active \nElse STBY_TRU_FAN_FAIL is inactive', 'additional': u'\tAdded according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_8052],\t[SDTS_PDS_8053]'}, u'SSCS_ESSNESS_4617': {'status': u'\tMATURE', 'body': u'In case of NESS configurations, at power-up, ENG1_OFF shall be inactive.', 'additional': u'\tAdded according SACR809', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define ENG1_OFF at power-up', 'issue': u'\t7', 'refer': 'EMPTY'}, u'ICD_SPI_ESSNESS_DATA_0038': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0039': {'issue': '1'}, u'SSCS_ESSNESS_4612': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, SSM_[LabelNumber] shall be decoded according following rules, if LabelReceived_[LabelNumber] is active\nset to Normal Operation if b30b31 of the corresponding label is 11\nset to No Computed Data if b30b31 of the corresponding label is 01\nset to Functional Test if b30b31 of the corresponding label is 10\nset to Failure Warning if b30b31 of the corresponding label is 00\nelse\nset to Failure Warning\nWhere [LabelNumber] is 54, 55 or 56', 'additional': u'\tAdded according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_8064],\t[SDTS_PDS_8065]'}, u'SSCS_ESSNESS_2160': {'status': u'\tMATURE', 'body': u'At power up, the signal DSO_SHED_START shall be inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_0180': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, it shall be possible to close the contactor CONTACT_A (by DSI_BC_Bypass) even if ESS board supplies are not present.', 'additional': u'\tmodified according SyCR17', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7162],\t[SDTS_PDS_7166]'}, u'SSCS_ESSNESS_4611': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, SSM_[LabelNumber] shall be decoded according following rules if LabelReceived_[LabelNumber] is active,\nset to Normal Operation if b30b31 of the corresponding label is 00\nset to No Computed Data if b30b31 of the corresponding label is 01\nset to Functional Test if b30b31 of the corresponding label is 10\nset to Failure Warning if b30b31 of the corresponding label is 11\nelse\nset to Failure Warning\nWhere [LabelNumber] is 73 or 74', 'additional': u'\tAdded according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_8064],\t[SDTS_PDS_8066]'}, u'ICD_SPI_ESSNESS_DATA_0032': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0033': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0030': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0031': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0036': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0037': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0034': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0035': {'issue': '1'}, u'SSCS_ESSNESS_2012': {'status': u'\tMATURE', 'body': u'In case of NESS board configuration, the ESSNESS board shall control DSO_APU_ECU_HPP_RELAY_CMD relay according following logic:\nDSO_APU_ECU_HPP_RELAY_CMD is activated when DSI_START_IN_PROGRESS is inactive\nDSO_APU_ECU_HPP_RELAY_CMD is deactivated when DSI_START_IN_PROGRESS is active', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_4025],\t[SDTS_PDS_4026]'}, u'SSCS_ESSNESS_8010': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2010': {'status': u'\tMATURE', 'body': u'At power up, the signal DSO_APU_ECU_HPP_RELAY_CMD shall be inactive ', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_2016': {'status': u'\tMATURE', 'body': u'In case of RESS board configuration, the ESSNESS board shall control DSO_APU_ECU_HPP_RELAY_CMD according following logic\nDSO_APU_ECU_HPP_RELAY_CMD is activated when A/C on ground\nDSO_APU_ECU_HPP_RELAY_CMD is deactivated 10s +/-1s after aircraft goes from ground to flight', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_2129]'}, u'SSCS_ESSNESS_3817': {'status': u'\tTBC', 'body': u'In case of ESS configuration, 28V_BAT_MIN shall be activated when ASI_28V_BAT_TRU_MON is over 19V +/-0,5V TBC\nElse it is inactive.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tdefines the lowest acceptable BAT voltage, it is used in contactor equation / the validity of 28V_BAT_MON is added at SSCS level TBC by GS ', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2015': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t,\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3816': {'status': u'\tTBC', 'body': u'In case of NESS configuration, 28V_TRU_MIN shall be activated when ASI_28V_BAT_TRU_MON is over 24V +/-0,5V TBC\nElse it is inactive.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tdefines the lowest acceptable TRU voltage, it is used in contactor equation', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6307': {'status': u'\tMATURE', 'body': u'Single Event Upset shall not affect the operation of control and protection function (justification has to be provided to DASSAULT)', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_165]'}, u'SSCS_ESSNESS_0954': {'status': u'\tTBD', 'body': u'In case of ESS configuration, xALTC1 unbalanced shall be activated when the sum of the rms current of each phasis is above 40Arms +/-TBD AND the rms current on only one phasis is under 3Arms +/-TBD during 5s +/-50ms\nCurrent considered are ASI_CT3_PhA, ASI_CT3_PhB, ASI_CT3_PhC.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_2700],\t[SDTS_PDS_2702],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_7206': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t3', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_8013': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_8014': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_8015': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3982': {'status': u'\tTBC', 'body': u'In case of ESS configuration, ESS_OK shall be activated when the following conditions is true:\n[(DSI_TSBC_STATUS is closed AND TSBC_HIGH_CURRENT is inactive)\nOR\n(DSI_BC_STATUS is closed AND BAT_HIGH_CURRENT is inactive)]\nAND\nASI_28V_ESS is over 21V +/-0,5V TBC\nElse it is inactive', 'additional': u'\tThose information are transmitted on ARINC bus', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_5000]'}, u'SSCS_ESSNESS_0131': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0130': {'status': u'\tMATURE', 'body': u'Driver of CONTACT_C shall be powered by 28V_C.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_260]'}, u'SSCS_ESSNESS_3987': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, DC_MAIN_FAULT shall be deactivated and latched to inactive when DC_MAIN_FAULT is active for more than 30s +/-300ms.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7178],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_3986': {'status': u'\tMATURE', 'body': u'At power-up, NESS_MAIN_115VAC_FAULT and NESS_MAIN_115V_OVL shall be inactive.', 'additional': u'\tModified according SACR439', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tdefinition of default state', 'issue': u'\t5', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3985': {'status': u'\tMATURE', 'body': u'At power-up CAS_DC_MAIN_FAULT, ESS_OK and NESS_MAIN_115VAC_FAULT shall be inactive.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tdefinition of default state', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3984': {'status': u'\tMATURE', 'body': u'At power-up DC_MAIN_FAULT shall be inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7219]'}, u'SSCS_ESSNESS_4605': {'status': u'\tTBC', 'body': u'In case of LNESS configuration, when the label [LabelNumber] which b9b10 is 00, SDI of the corresponding label, is not received since more than 1s +/-100ms TBC, LabelReceived_[LabelNumber] shall be set inactive.\nWhere [LabelNumber] is 73', 'additional': u'\tAdded according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_8067]'}, u'SSCS_ESSNESS_4100': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall implement two CAN busses, CAN1 and CAN2', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_664],\t[SDTS_PDS_536],\t[SDTS_PDS_010],\t[SDTS_PDS_011]'}, u'SSCS_ESSNESS_4101': {'status': u'\tMATURE', 'body': u'The two CAN busses shall be managed by BITE microcontroller.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_2075]'}, u'SSCS_ESSNESS_6304': {'status': u'\tMATURE', 'body': u'At power up, each microcontroller shall read COLD_START signal in order to determine if a cold or a hot restart will be performed', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThis signal allow determining if the board has to perform hot or a cold restart', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9901': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, BAT heater current presence shall be activated when current on the three phases are over 0,7Arms +/-0,2Arms during 500ms +/-5ms\nElse it is inactive\nConsidered signals are ASI_CT2_PhA, ASI_CT2_PhB, ASI_CT2_PhC', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7249],\t[SDTS_PDS_7250],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_8018': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4115': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_8019': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6315': {'status': u'\tMATURE', 'body': u'The software shall refresh the watchdog every 10ms +/-1ms', 'additional': u'\tIn order to assure that the watchdog is refreshed', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6201]'}, u'SSCS_ESSNESS_6314': {'status': u'\tMATURE', 'body': u'If the checksum of the hardware data zone in flash memory of the microcontroller is false, the microcontroller shall enter its default state:', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE,\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to assure that the microcontroller will not run in case of corrupted data in hardware data zone', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6317': {'status': u'\tMATURE', 'body': u'The FUNC microcontroller default state shall be:\nOutputs are inactive\nContactors are open\nNo emission on SPI bus\nRefresh the watchdog every 10ms +/-1ms', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define the default behavior of the FUNC microcontroller', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6316': {'status': u'\tMATURE', 'body': u'In order to refresh the watchdog, the software shall send the word Hi X X X Hi Hi Lo Lo on the serial link with watchdog function', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to describe the watchdog refreshing mechanism', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6311': {'status': u'\tMATURE', 'body': u'If the pin programming check is false, the microcontroller shall enter its default state:', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE,\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_6013]'}, u'SSCS_ESSNESS_6310': {'status': u'\tMATURE', 'body': u'The pin programming shall be read once at power up.', 'additional': u'\tSDTS precises that pin programming is read at power up and on ground, or it cannot be the case at power up the microcontroller has always to read the pin programming even in flight', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE,\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6012]'}, u'SSCS_ESSNESS_4604': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, LabelReceived_[LabelNumber] is set to active when all the following conditions are true:\nthe label [LabelNumber].is received\nb9b10 of the label [LabelNumber] is 10\nThe parity of label [LabelNumber] is odd (i.e. the number of bit with the value (1) in the whole word is odd)\nWhere [LabelNumber] is 54, 55, 56, 73 or 74', 'additional': u'\tAdded according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_8064],\t[SDTS_PDS_8071],\t[SDTS_PDS_8070]'}, u'SSCS_ESSNESS_6312': {'status': u'\tMATURE', 'body': u'The microcontroller type (UC_TYPE_1_FUNC / UC_TYPE_2_FUNC / UC_PARITY_FUNC in  case of FUNC microcontroller - UC_TYPE_1_BITE / UC_TYPE_2_BITE / UC_PARITY_BITE in  case of BITE microcontroller) shall be read once at power up.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE,\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define when the microcontroller type has to be read', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6319': {'status': u'\tMATURE', 'body': u'If an incoherence is detected during compatibility index check, the microcontroller shall enter its default state:', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE,\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to assure that the microcontroller will not run in case of error of compatibility index', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6318': {'status': u'\tMATURE', 'body': u'The BITE microcontroller default state shall be:\nNo emission on ARINC bus \nNo emission on CAN busses\nNo reception on SPI busses\nRefresh the watchdog', 'additional': u'\tModified according SACR448', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define the default behavior of the BITE microcontroller', 'issue': u'\t5', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6204': {'status': u'\tMATURE', 'body': u'A part of the flash memory of the BITE microcontroller shall be reserved to store hardware data:\nBoard part number\nCompatibility index', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to allow detection of incompatible hardware and software', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5018': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, the BITE microcontroller shall acquire the following DSI:\nName\nComments\nDSI_TAC_OPP_CABC_OPP_STATUS\nDSI_START_IN_PROGRESS\nDSI_TC_OPP_STATUS\nDSI_TSBC_OPP_STATUS\nDSI_GLC_OPP_STATUS\nDSI_APUGLC_STATUS\nDSI_WOW_LHPPDB\nDSI_WOW_RHPPDB\nDSI_ALT_STATUS\nDSI_EMP_B_CMD_HSCM_2_GALC_OPP\nDSI_SHP_CABC_STATUS\nDSI_BC_STATUS\nDSI_TSBC_OVL\nDSI_TRC_STATUS\nDSI_TC_STATUS\nDSI_TSBC_STATUS\nDSI_GLC_STATUS\nDSI_TAC_STATUS\nDSI_HES_TRU_CURRENT_SLC_STATUS\nDSI_TC_RESET_ATRC_STATUS\nDSI_FAN_CMD_xH\nDSI_TAC_TSBC_INHIB_RELAY_MON\nDSI_xALTC1_TAC_COIL_GND_MON\nDSI_TRU_OVL_GEN_OVL_SC\nDSI_FREQ_PPDB_FAN\nDSI_START_ACCEPTED_APUSLC_STATUS\nDSI_BOOC_GPULC_STATUS\nDSI_EMP_B_CMD_HSCM_1_GALC\nDSI_FREQ_TRU_FAN\nDSI_BACK_UP_PUMP_CABIN_CONV_GALLEY_CMD\nDSI_TRC_CMD_SMC_RATLC_STATUS\nDSI_BAT_PIN_PROG1_GNC_STATUS\nDSI_BAT_TRU_SW\nDSI_POWER_ON\nDSI_BAT_PIN_PROG2_GNC_OPP_STATUS\nDSI_ESSTIED_RELAY_ATRC_OPP_STATUS\nDSI_RATLC_SLC_OPP_STATUS\nDSI_ISOLATION_SMOKE_GALLEY_CABIN_MASTER\nDSI_PIN_PROG1\nDSI_PIN_PROG2\nDSI_PIN_PROG3\nDSI_PIN_PROG4\nDSI_PIN_PROG_PARITY\nDSI_CAB_INV1_FAIL_AGCU_POWER_READY\nDSI_CAB_INV1_DIFF_FAULT_SMC_STATUS\nDSI_CAB_INV1_OVERCURRENT_GPU_CONNECT_CMD\nDSI_CAB_INV1_OVERTEMP_GPU_SW_EPPC\nTable 15: DSI for RNESS configuration / BITE microcontroller', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_379]'}, u'SSCS_ESSNESS_3520': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, the BITE microcontroller shall acquire and average during 250ms +/-2,5ms ASI_HES1_CH1 current (calibrated) measurement, if the CBIT_TRU_CURRENT_CH1_VALID is active, computed value is called ASI_HES1_CH1_AV..', 'additional': u'\tdata are sent on ARINC / modified according SACR453', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7010],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_3812': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9101': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, when DSI_TRU_OVL_GEN_OVL_SC was active once, the failure FUNC_GEN_OVL_FAIL shall be activated if one at least of the following conditions is met:\nDSI_TRU_OVL_GEN_OVL_SC frequency is out of the range [990,1010Hz]\nduty cycle of DSI_TRU_OVL_GEN_OVL_SC is out of following ranges:\n10% +/-3%, 20% +/-3%, 30% +/-3%, 40% +/-3%, 60% +/-3%, 70% +/-3%, 80% +/-3%, 90% +/-3%\nElse it is inactive', 'additional': u'\tModified according SACR291', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_5080]'}, u'SSCS_ESSNESS_9100': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, at power up until DSI_TRU_OVL_GEN_OVL_SC becomes active once, the associated signals shall have the following values:\nGEN_OVL is inactive\nGEN_SC is inactive\nGEN_HC is inactive', 'additional': u'\tModified according SACR530', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE,\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tdefines the behavior at power up', 'issue': u'\t6', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9103': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9102': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, when FUNC_GEN_OVL_FAIL is active, GEN_OVL and GEN_SC and GEN_HC shall be managed as following:\nIf the signal is invalid since less than 5 consecutive periods they keep their previous value\nIf the signal is invalid since more than 5 consecutive periods (or 5 periods included)\nGEN_OVL is inactive\nGEN_SC is inactive\nGEN_HC is inactive', 'additional': u'\tvalue in case of invalid signals are not described / Modified according SACR530', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_5080]'}, u'SSCS_ESSNESS_9105': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, when CBIT_BITE_GEN_OVL_FAIL is active, GEN_OVL and GEN_SC and GNE_HC shall be managed as following:\nIf the signal is invalid since less than 5 consecutive periods they keep their previous value\nIf the signal is invalid since more than 5 consecutive periods (or 5 periods included)\nGEN_OVL is inactive\nGEN_SC is inactive\nGEN_HC is inactive', 'additional': u'\tvalue in case of invalid signals are not described / Modified according SACR530', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_5080]'}, u'SSCS_ESSNESS_9104': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, when DSI_TRU_OVL_GEN_OVL_SC was active once, the failure CBIT_BITE_GEN_OVL_FAIL shall be activated if one at least of the following conditions is met:\nDSI_TRU_OVL_GEN_OVL_SC frequency is out of the range [990,1010Hz]\nduty cycle of DSI_TRU_OVL_GEN_OVL_SC is out of following ranges:\n10% +/-3%, 20% +/-3%, 30% +/-3%, 40% +/-3%, 60% +/-3%, 70% +/-3%, 80% +/-3%, 90% +/-3%\nElse it is inactive', 'additional': u'\tModified according SACR291', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_5080]'}, u'SSCS_ESSNESS_9106': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6000': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall be varnished ', 'additional': u'\tAdded according SyCR22', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\t', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7271]'}, u'SSCS_ESSNESS_5013': {'status': u'\tMATURE', 'body': u'In case of RESS configuration, the FUNC microcontroller shall acquire the following DSI:\nName\nComments\nDSI_TAC_OPP_CABC_OPP_STATUS\nDSI_START_IN_PROGRESS\nDSI_TRC_OPP_STATUS_CABC_SHED\nDSI_TC_OPP_STATUS\nDSI_TSBC_OPP_STATUS\nDSI_GLC_OPP_STATUS\nDSI_APUGLC_STATUS\nDSI_WOW_LHPPDB\nDSI_WOW_RHPPDB\nDSI_ALT_STATUS\nDSI_SPARE_18\nDSI_RALTC1_STATUS\nDSI_EMP_B_CMD_HSCM_2_GALC_OPP\nDSI_SHP_CABC_STATUS\nDSI_BC_STATUS\nDSI_TSBC_OVL\nDSI_TRC_STATUS\nDSI_TC_STATUS\nDSI_TSBC_STATUS\nDSI_GLC_STATUS\nDSI_TAC_STATUS\nDSI_HES_TRU_CURRENT_SLC_STATUS\nDSI_TC_RESET_ATRC_STATUS\nDSI_FAN_CMD_xH\nDSI_TRU_OVL_GEN_OVL_SC\nDSI_FREQ_PPDB_FAN\nDSI_EMP_B_CMD_HSCM_1_GALC\nDSI_SPARE_19\nDSI_BACK_UP_PUMP_CABIN_CONV_GALLEY_CMD\nDSI_TRC_CMD_SMC_RATLC_STATUS\nDSI_BAT_PIN_PROG1_GNC_STATUS\nDSI_BAT_TRU_SW\nDSI_BAT_RELAY_STATUS\nDSI_POWER_ON\nDSI_BAT_PIN_PROG2_GNC_OPP_STATUS\nDSI_ESSTIED_RELAY_ATRC_OPP_STATUS\nDSI_RATLC_SLC_OPP_STATUS\nDSI_ISOLATION_SMOKE_GALLEY_CABIN_MASTER\nDSI_BC_Bypass\nDSI_PIN_PROG1\nDSI_PIN_PROG2\nDSI_PIN_PROG3\nDSI_PIN_PROG4\nDSI_PIN_PROG_PARITY\nDSI_BAT_HEATER_RELAY_2_STATUS\nTable 10: DSI for RESS configuration / FUNC microcontroller', 'additional': u'\tModified according SyCR36 / SACR442', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_534]'}, u'SSCS_ESSNESS_9155': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'ICD_SPI_010': {'status': u' \tMATURE', 'body': u'SPI master and slave shall respect the following timings between signals:\nParam n\xb0\nCharacteristic\nMin\nTyp\nMax\nUnits \nT3\nSetup Time\n\t\t3/(2 SCK)\n-\n-\nns +/-1%\nTable 4 : Electrical timings', 'additional': u' \tTiming due to master input interface technology.', 'issue': u' \t2', 'derived': u' \tYES', 'allocation': u' \tESSNESS_ENM_SW, SDSIO_PLD, TIE_PLD, ESSNESS_BITE_SW', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'ICD_SPI_011': {'status': u' \tTBC', 'body': u'SPI slave shall respect the following timings between signals:\nParam n\xb0\nCharacteristic\nMin\nTyp\nMax\nUnits \nt2\nTDATA_SETUP_MIN\n30\n(TBC)\n-\n-\nns\nt3\nTDATA_HOLD_MIN\n30\n(TBC)\n-\n-\nns\nTable 5 : Electrical timings', 'additional': u' \tTiming due to master input interface technology.', 'issue': u' \t2', 'derived': u' \tYES', 'allocation': u' \tSDSIO_PLD, TIE_PLD', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3815': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0612': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, the current flowing through GPU (CT_GPU_MAX) shall be evaluated as the maximum of ASI_CT2_PhA, ASI_CT2_PhB, ASI_CT2_PhC', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tAs the protection deals with overload, the current used to compute the protection is the maximum current in order to reduce activation delay', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0613': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, for overvoltage protection, GPU voltage (GPU_MAX) shall be evaluated as the maximum of ASI_ALT_GPU_PHA, ASI_ALT_GPU_PHB, ASI_ALT_GPU_PHC .', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tAs the protection deals with overvoltage, the voltage used to compute the protection is the maximum voltage in order to reduce activation delay', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0610': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, GPU presence shall be active when at least one phase voltage is over 30V +/-4V  (ASI_ALT_GPU_PHA, ASI_ALT_GPU_PHB, ASI_ALT_GPU_PHC).\nOtherwise it is inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_2028],\t[SDTS_PDS_4000]'}, u'SSCS_ESSNESS_0611': {'status': u'\tTBD', 'body': u'In case of RNESS configuration, GPU unbalanced shall be activated when the difference of rms current between two phases (ASI_CT2_PhA, ASI_CT2_PhB ASI_CT2_PhC) is over 50Arms +/-TBD for 5s +/-50ms.', 'additional': u'\t', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_0402],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_0616': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, when GPU_POWER_READY is in ON state, GPU driver fail protection shall be activated when CONTACT_C_TRIP is active and 28V_C is over 18,5V +/-0,5V', 'additional': u'\tmodified according SyCR17 / SACR258', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7143],\t[SDTS_PDS_0403],\t[SDTS_PDS_8007],\t[SDTS_PDS_8008]'}, u'SSCS_ESSNESS_0617': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, at power-up the current flowing through GPU (CT_GPU_MAX) shall be set to 0A.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define CT_GPU_MAX at power-up', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0614': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, for undervoltage protection, GPU voltage (GPU_MIN) shall be evaluated as the minimum of ASI_ALT_GPU_PHA, ASI_ALT_GPU_PHB, ASI_ALT_GPU_PHC.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tAs the protection deals with undervoltage, the voltage used to compute the protection is the minimum voltage in order to reduce activation delay', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0615': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, GPU_PROTECTION shall be activated when one at least of the following conditions is TRUE:\nGPU overvoltage protection is active\nGPU overload protection is active\nGPU undervoltage protection is active\nGPU frequency protection is active\nGPU phase order protection is active\nGPU driver fail protection is active\nElse it is inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_EQUAT_210]'}, u'SSCS_ESSNESS_0618': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, at power-up, GPU voltage (GPU_MAX) shall be set 0V.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define GPU_MAX at power-up', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0619': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, at power-up GPU voltage (GPU_MIN) shall be set to 0V', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define GPU_MIN at power-up', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3121': {'status': u'\tMATURE', 'body': u'PCB_OVER_TEMP shall be set to active when PCB_TEMP is above 45\xb0C +/-5\xb0C', 'additional': u'\tAdded according SACR530', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_8035]'}, u'SSCS_ESSNESS_3120': {'status': u'\tMATURE', 'body': u'The BAT_TRU_TEMP temperature shall be:\nThe max of the two temperatures read (ASI_BAT_TRU_TEMP_A and ASI_BAT_TRU_TEMP_B) when both signals validity are valid (CBIT_BAT_TRU_TEMP_A is active AND CBIT_BAT_TRU_TEMP_B is active)\nThe temperature of the non faulty sensor when one signal validity is invalid (CBIT_BAT_TRU_TEMP_A is inactive OR CBIT_BAT_TRU_TEMP_B is inactive)\nNot available when both signals validity is invalid (CBIT_BAT_TRU_TEMP_A is inactive AND CBIT_BAT_TRU_TEMP_B is inactive)', 'additional': u'\tModified according SACR448', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_7173],\t[SDTS_PDS_7175]'}, u'SSCS_ESSNESS_3122': {'status': u'\tMATURE', 'body': u'PCB_OVER_TEMP shall be set to inactive when PCB_TEMP is not available or under 30\xb0C +/-5\xb0C', 'additional': u'\tAdded according SACR530', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_8041]'}, u'SSCS_ESSNESS_6062': {'status': u'\tMATURE', 'body': u'The signal COLD_START shall be generated on ESSNESS board in order to know if the board is supplied after a short supply interruption or not.\nWhen Power has been shut down for more than 5 +/-2 seconds, COLD_START signal will be activated.', 'additional': u'\t', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_2321]'}, u'SSCS_ESSNESS_0005': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0004': {'status': u'\tMATURE', 'body': u'The different configurations of ESSNESS board shall be identified by the following pin programming:\nPin Prog\nLESS\nLNESS\nRESS\nRNESS\nDSI_PIN_PROG1\nInactive\nActive\nInactive\nActive\nDSI_PIN_PROG2\nActive\nInactive\nActive\nInactive\nDSI_PIN_PROG3\nInactive\nInactive\nInactive\nInactive\nDSI_PIN_PROG4\nInactive\nInactive\nActive\nActive\nDSI_PIN_PROG_PARITY\nActive\nActive\nInactive\nInactive\nTable 1: PIN PROG of ESSNESS board', 'additional': u'\tActive corresponds to GND at board input,\tInactive corresponds to Open at board input ', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_380]'}, u'SSCS_ESSNESS_7301': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t3', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0001': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4039': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall generate 28V_C which is composed of 2 different supply sources:\n28V_3\n28V_5', 'additional': u'\t ', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tTRUE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_260]'}, u'SSCS_ESSNESS_4036': {'status': u'\tMATURE', 'body': u'The 28V_A supply shall be protected with a fuse', 'additional': u'\tThis fuse is not tested', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tThis fuse is added in order to prevent damage on 28V supplies when a short circuit occurs on contactor driver.', 'issue': u'\t1', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4037': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall generate 28V_B which is composed of 3 different supply sources:\n28V_2\n28V_8\n28V_6', 'additional': u'\t ', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tTRUE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_282],\t[SDTS_PDS_284],\t[SDTS_PDS_727],\t[SDTS_PDS_723]'}, u'SSCS_ESSNESS_3814': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4035': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall generate 28V_A which is composed of 3 different supply sources:\n28V_1\n28V_2\n28V_5', 'additional': u'\t ', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tTRUE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_144],\t[SDTS_PDS_151],\t[SDTS_PDS_129],\t[SDTS_PDS_130]'}, u'SSCS_ESSNESS_4032': {'status': u'\tMATURE', 'body': u'According to board configuration, the correspondence between signal names in ESSNESS board interface and signal names in the PDS shall according following table\nName\nLESS\nRESS\nLNESS\nRNESS\n28V_1\n28V_BAT1\n28V_BAT2\n28V_TRU1\n28V_TRU2\n28V_2\nRH_28V_ESS\nLH_28V_ESS\nRH_28V_ESS\nLH_28V_ESS\n28V_3\n28V_TRU1\n28V_TRU2\nNot used\n28V_GPU\n28V_4\nSpare\nSpare\nLH_28V_ESS\nRH_28V_ESS\n28V_5\nLH_28V_ESS\nRH_28V_ESS\nLH_28V_ESS\nRH_28V_ESS\n28V_6\n28V_BAT1\n28V_BAT2\nNot used\nNot used\n28V_7\n28V_BAT1\nRH_28V_ESS\nLH_28V_MAIN\nRH_28V_MAIN\n28V_8\nLH_28V_MAIN\nRH_28V_MAIN\nLH_28V_MAIN\nRH_28V_MAIN\n28V_9\n28V_TRU1\n28V_TRU2\n28V_TRU1\n28V_TRU2\nTable 4: Correspondence between ESSNESS names of supplies and PDS names', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tTRUE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_515],\t[SDTS_PDS_381],\t[SDTS_PDS_144],\t[SDTS_PDS_151],\t[SDTS_PDS_129],\t[SDTS_PDS_130],\t[SDTS_PDS_282],\t[SDTS_PDS_284],\t[SDTS_PDS_727],\t[SDTS_PDS_723],\t[SDTS_PDS_260],\t[SDTS_PDS_276],\t[SDTS_PDS_291],\t[SDTS_PDS_734],\t[SDTS_PDS_740],\t[SDTS_PDS_2622],\t[SDTS_PDS_2633],\t[SDTS_PDS_2647],\t[SDTS_PDS_2662]'}, u'SSCS_ESSNESS_4033': {'status': u'\tMATURE', 'body': u'Each channel of multiple power supply sources generated with OR diodes shall be protected with a fuse.\nConcerned power supplies are:\n28V_board\n28V_A\n28V_B\n28V_C\n28V_D\n28V_E', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tIn order to protect board against overcurrent on its supplies', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4030': {'status': u'\tMATURE', 'body': u'The ESSNESS board electronic shall be powered by 28V_BOARD which is composed of 4 different supply sources \n28V_1\n28V_2\n28V_3\n28V_4', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_515],\t[SDTS_PDS_381]'}, u'SSCS_ESSNESS_4031': {'status': u'\tMATURE', 'body': u'In order to supply contactors commands, the ESSNESS board shall be interfaced with 5 other power sources:\n28V_5\n28V_6\n28V_7\n28V_8\n28V_9', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tESSNESS board has to be connected to those power supplies in order to generate supplies for the various contactor drivers', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6041': {'status': u'\tMATURE', 'body': u'Trimmer potentiometer shall not be used.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_158]'}, u'SSCS_ESSNESS_6040': {'status': u'\tMATURE', 'body': u'Use of large value electrolytic (untill 500\xb5F) capacitors is subject to No technical objection. If electrolytic capacitors are used, at least protection against explosion and smoke emission shall be provided', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_157]'}, u'SSCS_ESSNESS_6043': {'status': u'\tMATURE', 'body': u'In case of improper connection of 115Vac voltage on any input, damages shall be limited to the related input.', 'additional': u'\tInput corresponding of CB matrix don\u2019t respect this requirement', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_160]'}, u'SSCS_ESSNESS_6042': {'status': u'\tMATURE', 'body': u'All discrete inputs shall have an input diode.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6118]'}, u'SSCS_ESSNESS_6045': {'status': u'\tMATURE', 'body': u'The electronic shall initialize in less than 220 ms, as soon as power is applied.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_162]'}, u'SSCS_ESSNESS_6044': {'status': u'\tMATURE', 'body': u'All low level input /output shall support reverse polarity application without damage.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_161]'}, u'SSCS_ESSNESS_6047': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6046': {'status': u'\tMATURE', 'body': u'If digital counters are used, it shall be demonstrated that they cannot be subject to overflow and give erroneous data.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_164]'}, u'SSCS_ESSNESS_1022': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, GPU_AUTO shall be managed according following algorithm:', 'additional': u'\tRising edge means from inactive state to active state,\tModified according SACR541', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_685],\t[SDTS_PDS_8043]'}, u'SSCS_ESSNESS_1023': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, GPU_FAULT shall be managed according following algorithm:', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7235]'}, u'SSCS_ESSNESS_1020': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, GPU_POWER_READY shall be managed according following algorithm:', 'additional': u'\tRising edge means from inactive state to active state / modified according SACR252', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_5019]'}, u'SSCS_ESSNESS_1021': {'status': u'\tMATURE', 'body': u'In case of RNESS configuration, GPU_POWER shall be set to active when all the following conditions are true:\n28V_3_PRESENCE is active for 150ms +/- 5ms\nGPU_115VAC_PRESENCE is active for 150ms +/-5ms\nElse it is inactive', 'additional': u'\t1% delay tolerance cannot be achieve due to 5ms minimum response time of the microcontroller', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_5019],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_5725': {'status': u'\tMATURE', 'body': u'The DSO_GND_OPEN_20mA_WITH/WITHOUT_LIGHTNING and DSO_PWM_20mA_WITH_LIGHTNING shall be protected against polarity inversion with a diode', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6118]'}, u'SSCS_ESSNESS_7307': {'status': u'\tMATURE', 'body': u'For electrostatic discharge, the ESSNESS board shall withstand +/-15kV pulse on programming connector', 'additional': u'\tQualification test at system level \u2013 Verification test at product level for risk mitigation purpose,\tESD are limited to accessible pins when board is mounted in the equipement', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_1034]'}, u'SSCS_ESSNESS_5724': {'status': u'\tTBC', 'body': u'The DSO_28V_OPEN_20mA_WITHOUT_LIGHTNING shall implement a current limitation to 20mA (-0 / +10mA TBC)', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_5038],\t[SDTS_PDS_5039]'}, u'ICD_SPI_302': {'status': u' \tMATURE', 'body': u'SPI master shall launch a unique transmission request every 20ms (+/-1ms).', 'additional': u' \tin the case of ESSNESS boards the period of request (BITE side) has to be different from the period of data preparation (FUNC side) in order to assure that data can be refresh even if the \xb5C are  synchron', 'issue': u' \t3', 'derived': u' \tYES', 'allocation': u' \tESSNESS_BITE_SW, SDSIO_BITE_SW, TIE_BITE_SW', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'ICD_SPI_306': {'status': u' \tMATURE', 'body': u'The SPI slave shall restart frame transmission from beginning on each master request.\n ', 'additional': u' \tTo prevent from unknown behaviour if master resets or if any bad transmission occurs.', 'issue': u' \t2', 'derived': u' \tYES', 'allocation': u' \tESSNESS_ENM_SW, SDSIO_PLD, TIE_PLD ', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5727': {'status': u'\tMATURE', 'body': u'The DSO_GND_OPEN_500mA_WITH/WITHOUT_LIGHTNING shall be protected against polarity inversion with a diode', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6118]'}, u'ICD_SPI_305': {'status': u' \tMATURE', 'body': u'The SPI master shall discard SPI data that has an undefined CTRL value. ', 'additional': u' \tSee frame format for CTRL bits detail ', 'issue': u' \t2', 'derived': u' \tYES', 'allocation': u' \tESSNESS_BITE_SW, SDSIO_BITE_SW, TIE_BITE_SW', 'verification': u' \tTest', 'rationale': u' \tProtocol requirement', 'conformity': u' \tNA', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7877': {'status': u'\tMATURE', 'body': u'In case of RESS configuration,the BITE microcontroller shall activate CBIT_SHP_CURRENT_CH1 when one of the following condition is true:\nAt power up\nRisind edge on DSI_BACK_UP_PUMP_CABIN_CONV_GALLEY_CMD', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7055]'}, u'SSCS_ESSNESS_5726': {'status': u'\tMATURE', 'body': u'The DSO_GND_OPEN_50mA_OCP_WITH_LIGHTNING shall be protected against polarity inversion with a diode', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6118]'}, u'SSCS_ESSNESS_2024': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_6071': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall implement one LED in order to show that the board is powered.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_6403]'}, u'SSCS_ESSNESS_4614': {'status': u'\tMATURE', 'body': u'In case of NESS configurations, if SSM_54 is Normal Operation\nThen STBY_TRU_TEMP shall be equal to bit 29 \u2013 20 of label 54 coded in two complement, where bit 29 is the MSB and bit 20 is the LSB\nElse\nSTBY_TRU_TEMP is equal to 0', 'additional': u'\tAdded according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_8063],\t[SDTS_PDS_8058]'}, u'SSCS_ESSNESS_2201': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, the FUNC microcontroller shall manage DSO_CABIN_MASTER_ON according following logic:\nDSO_CABIN_MASTER_ON  is active when DSI_SHP_CABC_STATUS is closed\nDSO_CABIN_MASTER_ON  is inactive when DSI_SHP_CABC_STATUS is open', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_6000],\t[SDTS_PDS_6001]'}, u'SSCS_ESSNESS_2200': {'status': u'\tMATURE', 'body': u'In case of NESS board, at power up, the signal DSO_CABIN_MASTER_ON shall be inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_5723': {'status': u'\tTBC', 'body': u'The DSO_28V_OPEN_400mA_WITH/WITHOUT_LIGHTNING shall implement a current limitation to 400mA (-0 / +50mA TBC)', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_5038],\t[SDTS_PDS_5039]'}, u'SSCS_ESSNESS_8050': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_8051': {'status': u'\tMATURE', 'body': u'No dormant failure shall exist in protection functions', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tTRUE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t1', 'refer': u'[SDTS_PDS_068]'}, u'SSCS_ESSNESS_8052': {'status': u'\tMATURE', 'body': u'Monitoring and control function shall be segregated.', 'additional': u'\t', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tTRUE', 'verification': u'\tInspection', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_070]'}, u'SSCS_ESSNESS_4613': {'status': u'\tMATURE', 'body': u'In case of NESS configurations, at power-up, STBY_TRU_TEMP shall be 0.', 'additional': u'\tAdded according SACR809', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define STBY_TRU_TEMP at power-up', 'issue': u'\t7', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_3704': {'status': u'\tMATURE', 'body': u'When activating the signal L8, if the C9 signal is not closed after 10ms +/-1ms, failure CB_8x_VALID and CB_x9_VALID shall be set to FAIL.', 'additional': u'\tsee \xa73.4.1.2 for CAN ICD,\tWhere x is 1,2,3,4,5,6,7,8,\tModified according SACR361', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tdefine CBIT of the matrix', 'issue': u'\t5', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_4610': {'status': u'\tMATURE', 'body': u'In case of NESS configurations, at power-up, SSM_[LabelNumber] is set to Failure Warning.\nWhere [LabelNumber] is 54, 55, 56, 73 or 74', 'additional': u'\tAdded according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_8065],\t[SDTS_PDS_8066]'}, u'SSCS_ESSNESS_3620': {'status': u'\tMATURE', 'body': u'The BITE microcontroller shall compute CT3_SUM as the sum of each phasis of CT3 (ASI_CT3_PHA, ASI_CT3_PHB and ASI_CT3_PHC)', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tthis data is used for unbalanced phasis detection', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_9122': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'conformity': u'\t', 'derived': u'\t', 'allocation': u'\t', 'safety': u'\t', 'verification': u'\t', 'rationale': u'\t', 'issue': u'\t3', 'refer': 'EMPTY'}, u'ICD_SPI_ESSNESS_DATA_0076': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0077': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0074': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0075': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0072': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0073': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0070': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0071': {'issue': '1'}, u'SSCS_ESSNESS_9202': {'status': u'\tMATURE', 'body': u'BAT_HEATER_FAIL  shall be latch to avoid cycling', 'additional': u'\tmodified according SyCR17', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_2260],\t[SDTS_PDS_6005]'}, u'SSCS_ESSNESS_9203': {'status': u'\tMATURE', 'body': u'BAT_HEATER_FAIL  shall be reset when BAT_SW enters AUTO state.', 'additional': u'\tmodified according SyCR17', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7179],\t[SDTS_PDS_7077]'}, u'SSCS_ESSNESS_9200': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, BAT_HEATER_FAIL shall be active when all the following conditions are true:\nDSO_BAT_HEATER_TRU_FAN_POWER is active\nDSO_BAT_HEATER_RELAY2 is active\nMAIN_115VAC_PRESENCE is active\nCT_BAT_HEATER_MIN  is below 0,7Arms +/-0,2Arms for 500ms +/-5ms', 'additional': u'\tDSO_BAT_HEATER_TRU_FAN_POWER and DSO_BAT_HEATER_RELAY2 are coming from FUNC microcontroller through SPI link', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_2260],\t[SDTS_PDS_6005],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_9201': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, the current flowing through BAT heater (CT_BAT_HEATER_MIN) shall be evaluated as the minimum of ASI_CT2_PhA, ASI_CT2_PhB, ASI_CT2_PhC ', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tAs the monitoring deals with current minimum, the current used to compute the monitoring is the minimum current', 'issue': u'\t2', 'refer': 'EMPTY'}, u'ICD_SPI_ESSNESS_DATA_0078': {'issue': '1'}, u'ICD_SPI_ESSNESS_DATA_0079': {'issue': '1'}, u'SSCS_ESSNESS_8021': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_8020': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2054': {'status': u'\tTBC', 'body': u'The ESSNESS board shall activate DSO_FAN_POWER_PPDB  during 5s +/- 50ms when one at least of the following conditions is true:\nafter PBIT completion\nASI_28V_MAIN_MON rises over  18V +/-0,5V TBC', 'additional': u'\tmodified according SyCR17', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_7169],\t[SDTS_PDS_7176],\t[SDTS_PDS_7217],\t[SDTS_PDS_7177],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_8022': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_2052': {'status': u'\tMATURE', 'body': u'If the PCB_TEMP is not available, DSO_FAN_POWER_PPDB shall be active', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_2160],\t[SDTS_PDS_2162]'}, u'SSCS_ESSNESS_2053': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall deactivate DSO_FAN_POWER_PPDB when all the following conditions are met:\nDSI_FAN_CMD_xH is inactive\nPCB_TEMP is lower than 30 +/-5\xb0C ', 'additional': u'\tPCB_AREA_TEMP is defined in \xa72.6.2', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_2161],\t[SDTS_PDS_2163]'}, u'SSCS_ESSNESS_2050': {'status': u'\tMATURE', 'body': u'At power up, the signal DSO_FAN_POWER_PPDB shall be inactive.', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC,\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_163]'}, u'SSCS_ESSNESS_2051': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall activate DSO_FAN_POWER_PPDB when one at least of the following conditions is met\nDSI_FAN_CMD_xH is active\nPCB_TEMP is higher than 45 +/-5\xb0C', 'additional': u'\tPCB_AREA_TEMP is defined in \xa72.6.2', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_2160],\t[SDTS_PDS_2162]'}, u'SSCS_ESSNESS_4618': {'status': u'\tMATURE', 'body': u'In case of NESS configurations, if SSM_55 is Normal Operation and bit 19 of label 55 is TRUE (1)\nThen ENG1_OFF shall be active\nElse ENG1_OFF is inactive', 'additional': u'\tAdded according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_8054],\t[SDTS_PDS_8059]'}, u'SSCS_ESSNESS_4619': {'status': u'\tMATURE', 'body': u'In case of NESS configurations, at power-up, ENG2_OFF shall be inactive.', 'additional': u'\tAdded according SACR809', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tIn order to define ENG2_OFF at power-up', 'issue': u'\t7', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5714': {'status': u'\tMATURE', 'body': u'The following types of output shall withstand a voltage of 80V for up to 100ms without functional impact:\nDSO_28V_OPEN_150mA_WITH_LIGHTNING\nDSO_28V_OPEN_400mA_WITHOUT_LIGHTNING\nDSO_28V_OPEN_400mA_WITH_LIGHTNING\nDSO_28V_OPEN_20mA_WITHOUT_LIGHTNING', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThere\u2019s voltage transients on DC network', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5715': {'status': u'\tTBC', 'body': u'The DSO_GND_OPEN_20mA_WITH/WITHOUT_LIGHTNING and DSO_PWM_20mA_WITH_LIGHTNING shall implement a current limitation to 20mA (-0 / +10mA [TBC])', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_5038],\t[SDTS_PDS_5039]'}, u'SSCS_ESSNESS_5716': {'status': u'\tMATURE', 'body': u'The DSO_GND_OPEN_20mA_WITH/WITHOUT_LIGHTNING and DSO_PWM_20mA_WITH_LIGHTNING shall withstand a continuous voltage of 12V (+3V / -0V)', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThose kinds of DSO are polarized with 12V supply', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5717': {'status': u'\tTBC', 'body': u'The DSO_GND_OPEN_50mA_OCP_WITH_LIGHTNING shall implement a current limitation to 50mA (-0 / +10mA TBC)', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_5038],\t[SDTS_PDS_5039]'}, u'SSCS_ESSNESS_5710': {'status': u'\tMATURE', 'body': u'The ESSNESS board shall be equipped with 10 types of discrete outputs:\nDSO_GND_OPEN_20mA_WITHOUT_LIGHTNING\nDSO_GND_OPEN_20mA_WITH_LIGHTNING\nDSO_GND_OPEN_50mA_OCP_WITH_LIGHTNING\nDSO_GND_OPEN_500mA_WITHOUT_LIGHTNING\nDSO_GND_OPEN_500mA_WITH_LIGHTNING\nDSO_28V_OPEN_150mA_WITH_LIGHTNING\nDSO_28V_OPEN_400mA_WITHOUT_LIGHTNING\nDSO_28V_OPEN_400mA_WITH_LIGHTNING\nDSO_28V_OPEN_20mA_WITHOUT_LIGHTNING\nDSO_PWM_20mA_WITH_LIGHTNING', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThe discrete outputs of the ESSNESS board control different kind of loads', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5711': {'status': u'\tMATURE', 'body': u'The following types of output shall implement lightning protection (level A3J33 according section 22 of DO160 [40] )\nDSO_GND_OPEN_20mA_WITH_LIGHTNING\nDSO_GND_OPEN_50mA_OCP_WITH_LIGHTNING\nDSO_GND_OPEN_500mA_WITH_LIGHTNING\nDSO_28V_OPEN_150mA_WITH_LIGHTNING\nDSO_28V_OPEN_400mA_WITH_LIGHTNING\nDSO_PWM_20mA_WITH_LIGHTNING', 'additional': u'\tThe discrete outputs of the ESSNESS which get out of the PPDS (right or left) have to be protected against lightning', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_2609]'}, u'SSCS_ESSNESS_5712': {'status': u'\tMATURE', 'body': u'The following types of output shall ensure a maximum voltage of 1.5V (+/- 0,1V) when sinking their nominal current\nDSO_GND_OPEN_20mA_WITHOUT_LIGHTNING\nDSO_GND_OPEN_20mA_WITH_LIGHTNING\nDSO_GND_OPEN_50mA_OCP_WITH_LIGHTNING\nDSO_GND_OPEN_500mA_WITHOUT_LIGHTNING\nDSO_GND_OPEN_500mA_WITH_LIGHTNING\nDSO_PWM_20mA_WITH_LIGHTNING', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tWhen enabled, those kinds of DSO generates an electrical GND state', 'issue': u'\t2', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5713': {'status': u'\tMATURE', 'body': u'The following types of output shall be supplied by 28V_BOARD\nDSO_28V_OPEN_150mA_WITH_LIGHTNING\nDSO_28V_OPEN_400mA_WITHOUT_LIGHTNING\nDSO_28V_OPEN_400mA_WITH_LIGHTNING\nDSO_28V_OPEN_20mA_WITHOUT_LIGHTNING', 'additional': u'\tfor ESS board the 28V_4 supply is not used for supplying the DSO 28V/OPEN whereas it is for NESS board', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t2', 'refer': u'[SDTS_PDS_6018],\t[SDTS_PDS_6017]'}, u'SSCS_ESSNESS_7900': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, BAT pinprog failure,CBIT_BAT_PINPROG_FAIL shall be activated when one at least of the following conditions is true:\nDSI_BAT_PIN_PROG1_GNC_STATUS is active AND DSI_BAT_PIN_PROG2_GNC_OPP_STATUS is inactive\nDSI_BAT_PIN_PROG1_GNC_STATUS is inactive AND DSI_BAT_PIN_PROG2_GNC_OPP_STATUS is active\nElse it is inactive', 'additional': u'\tGND corresponds to active,\tOpen corresponds to inactive', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t4', 'refer': u'[SDTS_PDS_2153]'}, u'SSCS_ESSNESS_5718': {'status': u'\tTBC', 'body': u'The DSO_GND_OPEN_50mA_OCP_WITH_LIGHTNING shall withstand a continuous voltage of 12V (+2V / -0V TBC)', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\tThose kinds of DSO are polarized with 12V supply', 'issue': u'\t3', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_5719': {'status': u'\tTBC', 'body': u'The DSO_GND_OPEN_500mA_WITH/WITHOUT_LIGHTNING shall implement a current limitation to 500mA (-0 / +50mA TBC)', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tHardware', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_5038],\t[SDTS_PDS_5039]'}, u'SSCS_ESSNESS_4606': {'status': u'\tTBC', 'body': u'In case of RNESS configuration, when the label [LabelNumber] which b9b10 is 10, SDI of the corresponding label, is not received since more than 1s +/-100ms TBC, LabelReceived_[LabelNumber] shall be set inactive.\nWhere [LabelNumber] is 73', 'additional': u'\tAdded according SACR809', 'conformity': u'\tcompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t7', 'refer': u'[SDTS_PDS_8067]'}, u'SSCS_ESSNESS_8016': {'status': u'\tDEL', 'body': u'DELETED', 'additional': u'\t', 'issue': u'\t2', 'derived': u'\t', 'allocation': u'\t', 'verification': u'\t', 'rationale': u'\t', 'conformity': u'\t', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_7896': {'status': u'\tMATURE', 'body': u'In case of NESS configuration, at power-up BITE and FUNC microcontrollers shall set FREQ_TRU_FAN, to 0Hz.', 'additional': u'\t', 'conformity': u'\tNA', 'derived': u'\tTRUE', 'allocation': u'\tSoftware FUNC,\tSoftware BITE', 'safety': u'\tFALSE', 'verification': u'\tInspection', 'rationale': u'\tIn order to define FREQ_TRU_FAN at power-up', 'issue': u'\t4', 'refer': 'EMPTY'}, u'SSCS_ESSNESS_0403': {'status': u'\tTBC', 'body': u'In case of ESS configuration, TC undervoltage protection shall be activated when ASI_28V_ESS_MON is between 2V +/-0,5V TBC and 20,7V +/-0,5V TBC during 5ms ]-5ms, 0] TBC.', 'additional': u'\tTolerance delay of 1% is not respected due to 5ms minimum software response time', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_2604],\t[SDTS_PDS_2605],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_0402': {'status': u'\tTBC', 'body': u'In case of ESS configuration, TC overload protection shall be activated when one at least of the following conditions is true:\nTRU_OVL_IN_PROGRESS is active since more than 50ms +/-5ms TBC\nTSBC_OVL_IN_PROGRESS is active since more than 50ms +/-5ms TBC', 'additional': u'\tTRU _OVL_IN_PROGRESS is decribed in \xa72.6.3,\tTSBC_OVL_IN_PROGRESS is described in \xa72.6.3,\tTolerance delay of 1% is not respected due to 5ms minimum software response time', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_0440],\t[SDTS_PDS_2079],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_0401': {'status': u'\tTBC', 'body': u'In case of ESS configuration, TC overload protection, TC undervoltage and TC driver fail protections shall be set to inactive 100ms +/-5ms TBC after at least one of the following conditions is true\nBAT_SW enters AUTO state\nDSI_ESSTIED_RELAY_ATRC_OPP_STATUS goes from open to closed\nDSI_TC_RESET_ATRC_STATUS goes from inactive to active.', 'additional': u'\tBAT_SW states are defined in \xa72.4.1,\tTolerance delay of 1% is not respected due to 5ms minimum software response time Modified according SACR439 ', 'conformity': u'\tNO', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t5', 'refer': u'[SDTS_PDS_2080],\t[SDTS_PDS_2081],\t[SDTS_PDS_7014]'}, u'SSCS_ESSNESS_0400': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, TC protections shall be latched to avoid cycling.\nConcerned TC protections are:\nTC overload protection\nTC undervoltage protection\nTC driver fail protection', 'additional': u'\tThe latch of protections means that if a protection is not reset it will be memorised until the next power down ', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_286],\t[SDTS_PDS_288]'}, u'SSCS_ESSNESS_0406': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, TC driver fail protection shall be activated when CONTACT_B_TRIP is active and 28V_B is over 18,5V +/-0,5V.', 'additional': u'\tmodified according SyCR17 / SACR258', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tTRUE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t6', 'refer': u'[SDTS_PDS_7151],\t[SDTS_PDS_7152],\t[SDTS_PDS_8007],\t[SDTS_PDS_8008]'}, u'SSCS_ESSNESS_0405': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, TC_OVL_UV shall be activated when one at least of the following conditions is true:\nTC undervoltage protection is active\nTC overload protection  is active\nElse it is inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_7153]'}, u'SSCS_ESSNESS_0404': {'status': u'\tMATURE', 'body': u'In case of ESS configuration, TC_PROTECTION shall be activated when one at least of the following conditions is TRUE:\nTC overload protection is active\nTC undervoltage protection is active\nTC driver fail protection is active\nElse it is inactive', 'additional': u'\t', 'conformity': u'\tCompliant', 'derived': u'\tFALSE', 'allocation': u'\tSoftware FUNC', 'safety': u'\tFALSE', 'verification': u'\tTest', 'rationale': u'\t', 'issue': u'\t3', 'refer': u'[SDTS_PDS_EQUAT_303],\t[SDTS_PDS_EQUAT_403]'}}
    test_module.getAllocation()
    test_module.closeLog()
    if 0==1:
        from blockdiag.command import BlockdiagApp
        args=["conf/blockdiag_enm.diag"]
        BlockdiagApp().run(args)
